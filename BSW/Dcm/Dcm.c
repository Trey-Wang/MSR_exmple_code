/**********************************************************************************************************************
 *  COPYRIGHT
 *  -------------------------------------------------------------------------------------------------------------------
 *  \verbatim
 *  Copyright (c) 2017 by Vector Informatik GmbH.                                             All rights reserved.
 *
 *                This software is copyright protected and proprietary to Vector Informatik GmbH.
 *                Vector Informatik GmbH grants to you only those rights as set out in the license conditions.
 *                All other rights remain with Vector Informatik GmbH.
 *  \endverbatim
 *  -------------------------------------------------------------------------------------------------------------------
 *  FILE DESCRIPTION
 *  -----------------------------------------------------------------------------------------------------------------*/
/**        \file  Dcm.c
 *        \brief  Implementation of DCM core
 *
 *      \details  MICROSAR DCM based on AR 4.0.3
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 *  REVISION HISTORY
 *  -------------------------------------------------------------------------------------------------------------------
 *  Refer to the module's header file.
 *
 *  FILE VERSION
 *  -------------------------------------------------------------------------------------------------------------------
 *  Refer to the VERSION CHECK below.
 *********************************************************************************************************************/
#define DCM_SOURCE
/* ----------------------------------------------
 ~&&&   Includes
---------------------------------------------- */
                                                                                                                                                     /* PRQA S 0857, 0828 EOF */ /* MD_MSR_1.1_857, MD_MSR_1.1_828 */
#include "Dcm.h"
#include "Rte_Dcm.h"
#include "SchM_Dcm.h"
#if ((DCM_UTI_NVM_READ_ENABLED == STD_ON) || \
    (DCM_UTI_NVM_WRITE_ENABLED == STD_ON))                                                                                                           /* COV_DCM_UNSUPPORTED XF xf xf */
# include "NvM.h"
#endif /* ((DCM_UTI_NVM_READ_ENABLED == STD_ON) || \
 (DCM_UTI_NVM_WRITE_ENABLED == STD_ON)) */
#if (DCM_DEV_ERROR_REPORT == STD_ON)
# include "Det.h"
#endif /* (DCM_DEV_ERROR_REPORT == STD_ON) */
#include "PduR_Dcm.h"
#include "ComM_Dcm.h"
#if (((DCM_MODE_ECU_RESET_ENABLED == STD_ON) || (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)) && (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) || \
    (DCM_DIAG_NOTIF_BSWM_APPL_UPDATED_ENABLED == STD_ON) || \
    (DCM_SVC_28_SUPPORT_ENABLED == STD_ON))
# include "BswM_Dcm.h"
#endif /* (((DCM_MODE_ECU_RESET_ENABLED == STD_ON) || (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)) && (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) || \
 (DCM_DIAG_NOTIF_BSWM_APPL_UPDATED_ENABLED == STD_ON) || \
 (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)) */
#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# include "EcuM_Error.h"
#endif /* (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON) */
#if (((DCM_SVC_02_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)) && ((DCM_DEM_API_403_ENABLED == STD_ON) || (DCM_DEM_API_430_ENABLED == STD_ON)))                         /* COV_DCM_SUPPORT_PARTIALLY TF xf xf xf xf xf tf tf tf xf tf */
# include "Dem.h"
#endif /* (((DCM_SVC_02_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)) && ((DCM_DEM_API_403_ENABLED == STD_ON) || (DCM_DEM_API_430_ENABLED == STD_ON))) */
#if (((DCM_SVC_02_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)) && ((DCM_DEM_API_412_ENABLED == STD_ON) || (DCM_DEM_API_421_ENABLED == STD_ON) || (DCM_DEM_API_430_ENABLED == STD_ON))) /* COV_DCM_SUPPORT_PARTIALLY TF xf xf xf xf xf tf tf tf tf tf tf */
# include "Dem_Dcm.h"
#endif /* (((DCM_SVC_02_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)) && ((DCM_DEM_API_412_ENABLED == STD_ON) || (DCM_DEM_API_421_ENABLED == STD_ON) || (DCM_DEM_API_430_ENABLED == STD_ON))) */
#include "Dcm_Int.h"
/* ----------------------------------------------
 ~&&&   Versions
---------------------------------------------- */
#if ((DCM_SW_MAJOR_VERSION !=  8u) || \
    (DCM_SW_MINOR_VERSION !=  3u) || \
    (DCM_SW_PATCH_VERSION !=  1u))
# error "Vendor specific version numbers of Dcm.c and Dcm.h are inconsistent"
#endif
#if ((DCM_CBK_MAJOR_VERSION !=  8u) || \
    (DCM_CBK_MINOR_VERSION !=  3u) || \
    (DCM_CBK_PATCH_VERSION !=  1u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Cbk.h are inconsistent"
#endif
#if ((DCM_TYPES_MAJOR_VERSION !=  8u) || \
    (DCM_TYPES_MINOR_VERSION !=  3u) || \
    (DCM_TYPES_PATCH_VERSION !=  1u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Types.h are inconsistent"
#endif
#if ((DCM_INT_MAJOR_VERSION !=  8u) || \
    (DCM_INT_MINOR_VERSION !=  3u) || \
    (DCM_INT_PATCH_VERSION !=  1u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Int.h are inconsistent"
#endif
#if ((DCM_CORE_MAJOR_VERSION !=  8u) || \
    (DCM_CORE_MINOR_VERSION !=  3u) || \
    (DCM_CORE_PATCH_VERSION !=  1u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Core.h are inconsistent"
#endif
#if ((DCM_CORECBK_MAJOR_VERSION !=  8u) || \
    (DCM_CORECBK_MINOR_VERSION !=  3u) || \
    (DCM_CORECBK_PATCH_VERSION !=  1u))
# error "Vendor specific version numbers of Dcm.c and Dcm_CoreCbk.h are inconsistent"
#endif
#if ((DCM_CORETYPES_MAJOR_VERSION !=  8u) || \
    (DCM_CORETYPES_MINOR_VERSION !=  3u) || \
    (DCM_CORETYPES_PATCH_VERSION !=  1u))
# error "Vendor specific version numbers of Dcm.c and Dcm_CoreTypes.h are inconsistent"
#endif
#if ((DCM_COREINT_MAJOR_VERSION !=  8u) || \
    (DCM_COREINT_MINOR_VERSION !=  3u) || \
    (DCM_COREINT_PATCH_VERSION !=  1u))
# error "Vendor specific version numbers of Dcm.c and Dcm_CoreInt.h are inconsistent"
#endif
#if ((DCM_EXT_MAJOR_VERSION !=  8u) || \
    (DCM_EXT_MINOR_VERSION !=  3u) || \
    (DCM_EXT_PATCH_VERSION !=  1u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Ext.h are inconsistent"
#endif
#if ((DCM_EXTCBK_MAJOR_VERSION !=  8u) || \
    (DCM_EXTCBK_MINOR_VERSION !=  3u) || \
    (DCM_EXTCBK_PATCH_VERSION !=  1u))
# error "Vendor specific version numbers of Dcm.c and Dcm_ExtCbk.h are inconsistent"
#endif
#if ((DCM_EXTTYPES_MAJOR_VERSION !=  8u) || \
    (DCM_EXTTYPES_MINOR_VERSION !=  3u) || \
    (DCM_EXTTYPES_PATCH_VERSION !=  1u))
# error "Vendor specific version numbers of Dcm.c and Dcm_ExtTypes.h are inconsistent"
#endif
#if ((DCM_EXTINT_MAJOR_VERSION !=  8u) || \
    (DCM_EXTINT_MINOR_VERSION !=  3u) || \
    (DCM_EXTINT_PATCH_VERSION !=  1u))
# error "Vendor specific version numbers of Dcm.c and Dcm_ExtInt.h are inconsistent"
#endif
#if ((DCM_CFG_MAJOR_VERSION !=  8u) || \
    (DCM_CFG_MINOR_VERSION !=  3u) || \
    (DCM_CFG_PATCH_VERSION !=  1u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Cfg.h are inconsistent"
#endif
#if ((DCM_LCFG_MAJOR_VERSION !=  8u) || \
    (DCM_LCFG_MINOR_VERSION !=  3u) || \
    (DCM_LCFG_PATCH_VERSION !=  1u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Lcfg.h are inconsistent"
#endif
#if ((DCM_PBCFG_MAJOR_VERSION !=  8u) || \
    (DCM_PBCFG_MINOR_VERSION !=  3u) || \
    (DCM_PBCFG_PATCH_VERSION !=  1u))
# error "Vendor specific version numbers of Dcm.c and Dcm_PBcfg.h are inconsistent"
#endif
/* ----------------------------------------------
 ~&&&   Switches
---------------------------------------------- */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/* Verify consistency between DCM and DEM configurations.
 * In case of error, please refer to the DCM technical reference (search for the error text) for more information and solution.
 */
# if defined(DEM_CFG_SUPPORT_DTR)
#  if (DEM_CFG_SUPPORT_DTR == STD_ON)
#   if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
#    error "DCM configured to handle OBD DID MIDs via DCM configuration, but MID handling is done by DEM."
#   endif
#  else
#   if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
#    error "DCM configured to handle OBD DID MIDs via DEM configuration, but no MID handling is done by DEM."
#   endif
#  endif
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) || \
     (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) || \
     (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)
#  define DCM_OBDIDMGR_REQ_PARSER_ENABLED                            STD_ON
# else
#  define DCM_OBDIDMGR_REQ_PARSER_ENABLED                            STD_OFF
# endif
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) || \
    (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF xf xf */
# define DCM_UTI_LOOKUP_U16_ENABLED                                  STD_ON
#else
# define DCM_UTI_LOOKUP_U16_ENABLED                                  STD_OFF
#endif

#if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
# define DCM_UTI_LOOKUP_RANGE_U16_ENABLED                            STD_ON
#else
# define DCM_UTI_LOOKUP_RANGE_U16_ENABLED                            STD_OFF
#endif
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
# define DCM_NET_CONN_LOCK_ENABLED                                   STD_ON
#else
# define DCM_NET_CONN_LOCK_ENABLED                                   STD_OFF
#endif

#if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON) || \
    (DCM_SVC_10_RESET_AFTER_RESPONSE == STD_ON) || \
    (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_SUPPORT_PARTIALLY TF tf tf xf */
# define DCM_NET_RX_BLOCKING_ENABLED                                 STD_ON
#else
# define DCM_NET_RX_BLOCKING_ENABLED                                 STD_OFF
#endif
/* derive reentrant scheduling from split task */
#define DCM_TSK_REENTRANT_SCHEDULER_ENABLED                          DCM_SPLIT_TASKS_ENABLED

#define DCM_TSK_TASK_KILL_ENABLED                                    DCM_NET_PROCESSING_CANCELLATION_ENABLED

#if (DCM_TSK_TASK_KILL_ENABLED == STD_ON) && \
    (DCM_TSK_REENTRANT_SCHEDULER_ENABLED == STD_ON)
# define DCM_TSK_TASK_COMPLEX_KILL_ENABLED                           STD_ON
#else
# define DCM_TSK_TASK_COMPLEX_KILL_ENABLED                           STD_OFF
#endif

#define DCM_TSK_TASK_FLAG_SUPPORT_ENABLED                            DCM_TSK_TASK_COMPLEX_KILL_ENABLED

#if (DCM_DEV_ERROR_DETECT == STD_ON) && \
    (DCM_STATE_SECURITY_EXT_SETTER_ENABLED == STD_ON)                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TF tx tf */
# define DCM_TSK_TRACING_ENABLED                                     STD_ON
#else
# define DCM_TSK_TRACING_ENABLED                                     STD_OFF
#endif
/*! Specifies whether at least one diagnostic service needs global data storage.
    Extend this list if needed when adding a new diagnostic service with post-request memory */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_PARTIALLY TF tf xf xf xf */
# define DCM_DIAG_SVC_CONTEXT_ENABLED                                STD_ON
#else
# define DCM_DIAG_SVC_CONTEXT_ENABLED                                STD_OFF
#endif

#if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
# define DCM_DIAG_TOBJ_QUEUE_ENABLED                                 STD_ON
#else
# define DCM_DIAG_TOBJ_QUEUE_ENABLED                                 STD_OFF
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON) || \
    (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
# define DCM_DIAG_SYNCH_FLAGS_ENABLED                                STD_ON
#else
# define DCM_DIAG_SYNCH_FLAGS_ENABLED                                STD_OFF
#endif

#if (DCM_DIAG_SYNCH_FLAGS_ENABLED == STD_ON)
# define DCM_DIAG_PROCESSOR_FLAGS_ENABLED                            STD_ON
#else
# define DCM_DIAG_PROCESSOR_FLAGS_ENABLED                            STD_OFF
#endif

#if (DCM_DIAG_TOBJ_QUEUE_ENABLED    == STD_ON) || \
    (DCM_DIAG_PROCESSOR_FLAGS_ENABLED == STD_ON)
# define DCM_DIAG_SYNCH_DATA_SET_ENABLED                             STD_ON
#else
# define DCM_DIAG_SYNCH_DATA_SET_ENABLED                             STD_OFF
#endif

/*! Specifies whether at least one diagnostic service with a sub-function followed by no other data is active in the configuration */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_3E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX tx tf tf */
# define DCM_DIAG_SF_ONLY_SERVICE_ENABLED                            STD_ON
#else
# define DCM_DIAG_SF_ONLY_SERVICE_ENABLED                            STD_OFF
#endif
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/* Verify consistency between DCM and DEM configurations.
 * In case of error, please refer to the DCM technical reference (search for the error text) for more information and solution.
 */
# if defined(DEM_CFG_SUPPORT_DTR)
#  if (DEM_CFG_SUPPORT_DTR == STD_ON)
#  else
#   error "DCM configured to handle OBD MIDs via DEM configuration, but no MID handling is done by DEM."
#  endif
# endif
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/* Verify consistency between DCM and DEM configurations.
 * In case of error, please refer to the DCM technical reference (search for the error text) for more information and solution.
 */
# if defined(DEM_CFG_SUPPORT_DTR)
#  if (DEM_CFG_SUPPORT_DTR == STD_ON)
#   error "DCM configured to handle OBD MIDs via DCM configuration, but MID handling is done by DEM."
#  endif
# endif
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON) && \
     ( (DCM_SVC_11_USER_ENABLED == STD_ON) || \
     (DCM_SVC_11_RAPID_SHTDWN_ENABLED == STD_ON) )
#  define DCM_SVC_11_ECURESET_EXEC_FILTER_ENABLED                    STD_ON
# else
#  define DCM_SVC_11_ECURESET_EXEC_FILTER_ENABLED                    STD_OFF
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED  == STD_ON ) || \
     (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON ) || \
     (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON )
#  define DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED                   STD_ON
# else
#  define DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED                   STD_OFF
# endif

# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON) && \
     (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_OFF)
#  define DCM_SVC_19_COPY_LINEAR_DATA_ENABLED                        STD_ON
# else
#  define DCM_SVC_19_COPY_LINEAR_DATA_ENABLED                        STD_OFF
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED  == STD_ON) || \
     (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
#  define DCM_SVC_19_RECORD_ITER_ENABLED                             STD_ON
# else
#  define DCM_SVC_19_RECORD_ITER_ENABLED                             STD_OFF
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED       == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED  == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED      == STD_ON) || \
     (DCM_SVC_19_05_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED   == STD_ON) || \
     (DCM_SVC_19_08_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_09_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_14_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_42_SUPPORT_ENABLED                   == STD_ON)
#  define DCM_SVC_19_CHAINING_ENABLED                                STD_ON

#  if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON) || \
      (DCM_SVC_19_05_SUPPORT_ENABLED             == STD_ON) || \
      (DCM_SVC_19_09_SUPPORT_ENABLED             == STD_ON)
#   define DCM_SVC_19_CHAIN_END_ENABLED                              STD_ON
#  else
#   define DCM_SVC_19_CHAIN_END_ENABLED                              STD_OFF
#  endif
# else
#  define DCM_SVC_19_CHAINING_ENABLED                                STD_OFF
#  define DCM_SVC_19_CHAIN_END_ENABLED                               STD_OFF
# endif

# if ((DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)) && \
     (DCM_DEM_API_430_ENABLED == STD_OFF)
#  define DCM_SVC_19_ABSTRACT_RECORD_ITER_ENABLED                    STD_ON
# else
#  define DCM_SVC_19_ABSTRACT_RECORD_ITER_ENABLED                    STD_OFF
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/* Consistent configuration checks */
# if (DCM_NET_PERIODIC_TX_ENABLED == STD_OFF)
#  error "Service 0x2A is enabled, but no periodic messages have been configured for Dcm. Please, refer to the Dcm TechRef for SID 0x2A configuration aspect."
# endif
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_2C_01_SUPPORT_ENABLED != DCM_SVC_2C_02_SUPPORT_ENABLED)
#  define DCM_SVC_2C_HYBRID_MODE_ENABLED                             STD_OFF
# else
#  define DCM_SVC_2C_HYBRID_MODE_ENABLED                             STD_ON
# endif

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)
#  define DCM_SVC_2C_CLEAR_SUPPORT_ENABLED                           STD_ON
# else
#  define DCM_SVC_2C_CLEAR_SUPPORT_ENABLED                           STD_OFF
# endif

# if (DCM_DIDMGR_DYNDID_ASYNC_SUPPORT_ENABLED == STD_ON) && \
     (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
#  define DCM_SVC_2C_RACE_CONDITION_READ_ENABLED                     STD_ON
# else
#  define DCM_SVC_2C_RACE_CONDITION_READ_ENABLED                     STD_OFF
# endif

# if (DCM_DIDMGR_DYNDID_ASYNC_SUPPORT_ENABLED == STD_ON) && \
     ( (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON) || \
     (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON) )
#  define DCM_SVC_2C_CANCELOP_READ_ENABLED                           STD_ON
# else
#  define DCM_SVC_2C_CANCELOP_READ_ENABLED                           STD_OFF
# endif

# if (DCM_DIDMGR_PAGED_DID_SUPPORT_ENABLED == STD_ON)
#  error "Service 0x2C is not allowed when any paged DID is configured!"
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_IODID_READ_SUPPORT_ENABLED == STD_ON) && \
     (DCM_DIDMGR_IODID_DYNLEN_ENABLED == STD_ON)
#  define DCM_SVC_2F_READ_RES_DATA_LEN_ENABLED                       STD_ON
# else
#  define DCM_SVC_2F_READ_RES_DATA_LEN_ENABLED                       STD_OFF
# endif
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
/* ----------------------------------------------
 ~&&&   Defines
---------------------------------------------- */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_MEMMGR_ACCESS_NONE                                      ((Dcm_MemMgrAccessType)0u)
# define DCM_MEMMGR_ACCESS_REQ_EXT                                   ((Dcm_MemMgrAccessType)1u)
# define DCM_MEMMGR_ACCESS_REQ_INT                                   ((Dcm_MemMgrAccessType)2u)

# define DCM_MEMMGR_OP_READ                                          ((Dcm_MemMgrMemoryOpType)0u)
# if (DCM_MEMMGR_MEMOP_READ_ENABLED == STD_ON)
#  define DCM_MEMMGR_OP_WRITE                                        ((Dcm_MemMgrMemoryOpType)(DCM_MEMMGR_OP_READ + 1u))
# else
#  define DCM_MEMMGR_OP_WRITE                                        ((Dcm_MemMgrMemoryOpType)(DCM_MEMMGR_OP_READ + 0u))
# endif
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
# define DCM_OBDIDMGR_PFLAG_NONE                                     ((Dcm_ObdIdMgrParserFlagsType)0x00u)
# define DCM_OBDIDMGR_PFLAG_SINGLEDATAID                             ((Dcm_ObdIdMgrParserFlagsType)0x01u)
# define DCM_OBDIDMGR_PFLAG_REQHASDATA                               ((Dcm_ObdIdMgrParserFlagsType)0x02u)
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
/*! ComM notification allowance states */
#define DCM_NET_COMM_ACTIVE                                          ((Dcm_NetActiveDiagnosticType)TRUE)  /*!< Do notify ComM for ActiveDiagnostics (default state) */
#define DCM_NET_COMM_NOT_ACTIVE                                      ((Dcm_NetActiveDiagnosticType)FALSE) /*!< Do NOT notify ComM for ActiveDiagnostics (sleep prevention by DCM is inhibited by application) */

/*! Network variant/non-variant configuration abstraction */
#define Dcm_PbCfgNetNumRxPduIds                                      (Dcm_NetCfgGetNumRxPduIds(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumTxPduIds                                      (Dcm_NetCfgGetNumTxPduIds(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetCanTpRxPduIdMin                                  (Dcm_NetCfgGetMinCanTpRxPduId(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetCanTpRxPduIdMax                                  (Dcm_NetCfgGetMaxCanTpRxPduId(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumCanRxPduIds                                   (Dcm_NetCfgGetNumCanRxPduIds(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumPerTxObjects                                  (Dcm_NetCfgGetNumPerTxObjects(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumConnections                                   (Dcm_NetCfgGetNumConnections(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumProtocols                                     (Dcm_NetCfgGetNumProtocols(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumComMChannels                                  (Dcm_NetCfgGetNumComMChannels(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumBuffers                                       (Dcm_NetCfgGetNumBuffers(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumTransportObjects                              (Dcm_NetCfgGetNumTranspObjects(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumAllComMChannels                               (Dcm_NetCfgGetNumAllComMChannels(DCM_VARMGR_ACTIVE_COMVAR))

#define Dcm_PbCfgNetRxPduInfo                                        (Dcm_NetCfgGetRxPduInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetConnectionInfo                                   (Dcm_NetCfgGetConnectionInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetProtocolInfo                                     (Dcm_NetCfgGetProtocolInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetConnComMChannelMap                               (Dcm_NetCfgGetNetConnComMChannelMap(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNetworkHdlLookUp                                 (Dcm_NetCfgGetNetworkHdlLookUp(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetTxPdu2ConnMap                                    (Dcm_NetCfgGetTxPdu2ConnMap(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetPerTxPdu2RsrsMap                                 (Dcm_NetCfgGetPerTxPdu2RsrsMap(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetPerTxPduIdInfo                                   (Dcm_NetCfgGetPerTxPduIdInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetComCtrlChannelListAll                            (Dcm_NetCfgGetComCtrlChannelListAll(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetAllComMChannelMap                                (Dcm_NetCfgGetNetAllComMChannelMap(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetCanTp2DcmRxPduIdMap                              (Dcm_NetCfgGetCanTp2DcmRxPduIdMap(DCM_VARMGR_ACTIVE_COMVAR))

#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# define Dcm_PbRamNetBufferContext                                   (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.BufferContexts)
# define Dcm_PbRamNetTransportObject                                 (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.TranspObjects)
# define Dcm_PbRamNetComMContext                                     (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.ComMContexts)
# define Dcm_PbRamNetPeriodicTxObject                                (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.PeriodicTxObjects)
# define Dcm_PbRamNetConnId2TObjMap                                  (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.ConnId2TObjIdMap)
# define Dcm_PbRamNetComCtrlChannels                                 (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.ComCtrlChannels)
# define Dcm_PbCfgNetBufferInfo                                      (DCM_VARMGR_ACTIVE_ROMVAR.NetworkRom.BufferInfo)
#else
# define Dcm_PbRamNetBufferContext                                   (Dcm_SingletonContext.Network.BufferContext)
# define Dcm_PbRamNetTransportObject                                 (Dcm_SingletonContext.Network.TransportObject)
# define Dcm_PbRamNetComMContext                                     (Dcm_SingletonContext.Network.ComMContext)
# define Dcm_PbRamNetPeriodicTxObject                                (Dcm_SingletonContext.Network.PeriodicTxContext.TxObject)
# define Dcm_PbRamNetConnId2TObjMap                                  (Dcm_SingletonContext.Network.ConnId2TObjIdMap)
# define Dcm_PbRamNetComCtrlChannels                                 (Dcm_SingletonContext.Network.ComCtrlChannels)
# define Dcm_PbCfgNetBufferInfo                                      Dcm_CfgNetBufferInfo
#endif

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/*! Converts a Dcm related CanTp PduID to its corresponding DcmRxPduId */
# define Dcm_NetGetDcmRxPduIdOfCanTpPduId(canTpPduId)                (Dcm_PbCfgNetCanTp2DcmRxPduIdMap[(canTpPduId)-Dcm_PbCfgNetCanTpRxPduIdMin])     /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Provides the ECUs network address of a specific client connection */
# define Dcm_NetGetNodeAddress(connId)                               (Dcm_PbCfgNetConnectionInfo[(connId)].EcuAddress)                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetGetDcmRxPduIdOfCanTpPduId(canTpPduId)                /* not used */
# define Dcm_NetGetNodeAddress(connId)                               /* not used */
#endif

#if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
# define Dcm_NetGetDemClientId(protocolIdx)                          (Dcm_NetGetProtObjOfProtId(protocolIdx)->DemClientId)                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetGetDemClientId(protocolIdx)                          ((uint8)DCM_NET_DEFAULT_DEM_CLIENTID)                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif
/*! Retrieves diagnostic protocol specific P2 time justification */
#define Dcm_NetGetP2AdjTime(protocolIdx)                             (Dcm_NetGetProtObjOfProtId(protocolIdx)->SrvAdjTime.P2)                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Retrieves diagnostic protocol specific P2* time justification */
#define Dcm_NetGetP2StarAdjTime(protocolIdx)                         (Dcm_NetGetProtObjOfProtId(protocolIdx)->SrvAdjTime.P2Star)                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! USDT transport object states */
#define DCM_NET_TOBJ_STATE_FREE                                      ((Dcm_NetTransportObjectStateType)0x00u)  /*!< Free to be used */
#define DCM_NET_TOBJ_STATE_ONRX                                      ((Dcm_NetTransportObjectStateType)0x01u)  /*!< USDT reception in progress */
#define DCM_NET_TOBJ_STATE_RX_END                                    ((Dcm_NetTransportObjectStateType)0x02u)  /*!< USDT reception already finished */
#define DCM_NET_TOBJ_STATE_PREPTX                                    ((Dcm_NetTransportObjectStateType)0x04u)  /*!< Ready for USDT transmission */
#define DCM_NET_TOBJ_STATE_ONTX                                      ((Dcm_NetTransportObjectStateType)0x08u)  /*!< USDT transmission in progress */
#define DCM_NET_TOBJ_STATE_READY                                     ((Dcm_NetTransportObjectStateType)0x10u)  /*!< Transmission (Rx/Tx) finished but transport object still in use */
#define DCM_NET_TOBJ_STATE_RESERVED                                  ((Dcm_NetTransportObjectStateType)0x20u)  /*!< Transport object is allocated, but not yet in use (transmission) */

/*! USDT transport object flags */
#define DCM_NET_TOBJ_FLAG_NONE                                       ((Dcm_NetTransportObjectFlagType)0x0000u)  /*!< No flags set */
#define DCM_NET_TOBJ_FLAG_INTERNAL                                   ((Dcm_NetTransportObjectFlagType)0x0001u)  /*!< The transport object is used for internal (virtual) request (e.g. RoE) */
#define DCM_NET_TOBJ_FLAG_COPYHEAD                                   ((Dcm_NetTransportObjectFlagType)0x0002u)  /*!< The diagnostic request head shall be copied into a temporary buffer */
#define DCM_NET_TOBJ_FLAG_BUSY                                       ((Dcm_NetTransportObjectFlagType)0x0004u)  /*!< Current diagnostic request reception is a pseudo-parallel one */
#define DCM_NET_TOBJ_FLAG_CANCELED                                   ((Dcm_NetTransportObjectFlagType)0x0008u)  /*!< Current message transmission (Rx/Tx) was canceled */
#define DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ                               ((Dcm_NetTransportObjectFlagType)0x0010u)  /*!< RCR-RP state: just requested to be sent */
#define DCM_NET_TOBJ_FLAG_RCRRP_ON_TX                                ((Dcm_NetTransportObjectFlagType)0x0020u)  /*!< RCR-RP state: currently on transmission */
#define DCM_NET_TOBJ_FLAG_RCRRP_SENT                                 ((Dcm_NetTransportObjectFlagType)0x0040u)  /*!< RCR-RP state: at least once has been sent */
#define DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL                            ((Dcm_NetTransportObjectFlagType)0x0080u)  /*!< RCR-RP state: current one was triggered by the application */
#define DCM_NET_TOBJ_FLAG_OBSOLETE                                   ((Dcm_NetTransportObjectFlagType)0x0100u)  /*!< Transport object is obsolete and shall be canceled at later time. The difference to FLAG_CANCELED is that the ongoing transmission is not affected */
/*! USDT transport object response types */
#define DCM_NET_TOBJ_RESTYPE_NONE                                    ((Dcm_NetResponseType)0u)  /*!< No response is ongoing */
#define DCM_NET_TOBJ_RESTYPE_LINEAR                                  ((Dcm_NetResponseType)1u)  /*!< Final response (linear buffer) */
#define DCM_NET_TOBJ_RESTYPE_PAGED                                   ((Dcm_NetResponseType)2u)  /*!< Final response (paged-buffer) */
#define DCM_NET_TOBJ_RESTYPE_RCRRP                                   ((Dcm_NetResponseType)3u)  /*!< RCR-RP response */
#define DCM_NET_TOBJ_RESTYPE_UNSOLICITED                             ((Dcm_NetResponseType)4u)  /*!< Unsolicited (response without request) (e.g. FBL final response after power on/reset) */
#define DCM_NET_TOBJ_RESTYPE_SIMPLE                                  ((Dcm_NetResponseType)5u)  /*!< Simply respond (without processing) e.g. final negative response NRC 0x21 for pseudo parallel client handling or protocol switch rejection */

/*! Diagnostic client USDT connection properties */
#define DCM_NET_CONN_PROP_NONE                                       ((Dcm_CfgNetConnPropertiesType)0x00u)  /*!< Nothing special */
#define DCM_NET_CONN_PROP_TX_ON_FUNC_RX                              ((Dcm_CfgNetConnPropertiesType)0x01u)  /*!< No response to be sent on functional requests over this connection */
#define DCM_NET_CONN_PROP_NO_MAIN_TX                                 ((Dcm_CfgNetConnPropertiesType)0x02u)  /*!< The USDT connection does not contain a PduRTxPduId */

#define DCM_NET_INVALID_CONNID                                       ((Dcm_CfgNetNetIdRefMemType)Dcm_PbCfgNetNumConnections)
#define DCM_NET_INVALID_TOBJID                                       ((Dcm_CfgNetTObjHandleMemType)Dcm_PbCfgNetNumTransportObjects)
#define DCM_NET_INVALID_PROTID                                       ((Dcm_NetProtRefMemType)Dcm_PbCfgNetNumProtocols)

/*! State definitions for periodic transport object */
#define DCM_NET_PERIODIC_TX_STATE_FREE                               ((Dcm_NetPerTxObjStateMemType)0)
#define DCM_NET_PERIODIC_TX_STATE_RESERVED                           ((Dcm_NetPerTxObjStateMemType)1)
#define DCM_NET_PERIODIC_TX_STATE_QUEUED                             ((Dcm_NetPerTxObjStateMemType)2)
#define DCM_NET_PERIODIC_TX_STATE_ONTX                               ((Dcm_NetPerTxObjStateMemType)3)
#define DCM_NET_INVALID_PTXOBJ_HANDLE                                ((Dcm_CfgNetPTxObjHandleMemType)Dcm_PbCfgNetNumPerTxObjects)

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
# define DCM_NET_DELAY_BULK_TRANSMISSION                             2u
#else
# define DCM_NET_DELAY_BULK_TRANSMISSION                             0u
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/*! AR 3.x PduR API result values adaption */
# define DCM_NET_ARENV_NTFRSLT_OK                                    NTFRSLT_OK
# define DCM_NET_ARENV_NTFRSLT_NOT_OK                                NTFRSLT_E_NOT_OK
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if (DCM_PDUR_API_401_ENABLED == STD_ON)
/*! AR 4.0.1 PduR API argument values adaption */
#  define DCM_NET_ARENV_NTFRSLT_OK                                   NTFRSLT_OK
#  define DCM_NET_ARENV_NTFRSLT_NOT_OK                               NTFRSLT_E_NOT_OK
# elif (DCM_PDUR_API_403_ENABLED == STD_ON)
/*! AR 4.0.3 PduR API argument values adaption */
#  define DCM_NET_ARENV_NTFRSLT_OK                                   NTFRSLT_OK
#  define DCM_NET_ARENV_NTFRSLT_NOT_OK                               NTFRSLT_E_NOT_OK
# elif (DCM_PDUR_API_412_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
/*! AR 4.1.2+ PduR API argument values adaption */
#  define DCM_NET_ARENV_NTFRSLT_OK                                   E_OK
#  define DCM_NET_ARENV_NTFRSLT_NOT_OK                               E_NOT_OK
# else
#  error "Unsupported PduR version!"
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#define DCM_PAGEDBUFFER_STATE_INACTIVE                               (Dcm_PagedBufferStateType)0x00u /*!< No paged-buffer transmission in progress */
#define DCM_PAGEDBUFFER_STATE_ACTIVATED                              (Dcm_PagedBufferStateType)0x01u /*!< Paged-buffer transmission activated, but not yet passed to the PduR */
#define DCM_PAGEDBUFFER_STATE_CANCELED                               (Dcm_PagedBufferStateType)0x02u /*!< Paged-buffer transmission terminated prior passing it to the PduR */
#define DCM_PAGEDBUFFER_STATE_ONTX                                   (Dcm_PagedBufferStateType)0x03u /*!< Paged-buffer transmission ongoing (passed to the PduR) */

#define DCM_PAGEDBUFFER_ALL_DATA_PROVIDED                            (Dcm_PagedBufferDataProvisionStateType)0x00u /*!< All data provided */
#define DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED                           (Dcm_PagedBufferDataProvisionStateType)0x01u /*!< Already some data provided */
#define DCM_PAGEDBUFFER_WAIT_FOR_DATA                                (Dcm_PagedBufferDataProvisionStateType)0x02u /*!< Waiting for data provision */
#define DCM_REPEATER_USER_NONE                                       ((Dcm_RepeaterUserType)0)
#define DCM_REPEATER_USER_DEM                                        ((Dcm_RepeaterUserType)1)
#define DCM_REPEATER_USER_DIDMGR                                     ((Dcm_RepeaterUserType)2)
#define DCM_REPEATER_PROGRESS_INITIAL                                ((Dcm_RepeaterProgressType)0)

#define DCM_REPEATER_PROGRESS_USERS_FIRST                            ((Dcm_RepeaterProgressType)1)
#define DCM_REPEATER_PROGRESS_USERS_LAST                             ((Dcm_RepeaterProgressType)254)
#define DCM_REPEATER_PROGRESS_INVALID                                ((Dcm_RepeaterProgressType)255)
/* all other progress types are client /service processor specific and shall start with DCM_REPEATER_PROGRESS_USERS_FIRST and end with DCM_REPEATER_PROGRESS_USERS_LAST */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/*! AR 3.x EcuReset related notification data type adapters */
# define Dcm_ModeMgrArEnvModeEcuResetType                            Dcm_ResetModeType
# define Dcm_ModeMgrArEnvModeRapidPowerShutDownType                  Dcm_ResetModeType
/*! AR 3.x EcuReset related notification value adapters. Values are self-explanatory and in AR DCM SWS documented */
# define DCM_MODEMGR_ARENV_MODE_ECURESET_NONE                        DCM_NO_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_HARD                        DCM_HARD_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_KEYONOFF                    DCM_KEY_ON_OFF_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_SOFT                        DCM_SOFT_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_OEM                DCM_BOOTLOADER_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_SYS                DCM_SS_BOOTLOADER_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_EXECUTE                     DCM_RESET_EXECUTION
# define DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_ENABLE                  DCM_ENABLE_RAPID_POWER_SHUTDOWN_RESET
# define DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_DISABLE                 DCM_DISABLE_RAPID_POWER_SHUTDOWN_RESET
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
/*! AR 4.x EcuReset related notification data type adapters */
# define Dcm_ModeMgrArEnvModeEcuResetType                            Rte_ModeType_DcmEcuReset
# define Dcm_ModeMgrArEnvModeRapidPowerShutDownType                  Rte_ModeType_DcmModeRapidPowerShutDown
/*! AR 4.x EcuReset related notification value adapters. Values are self-explanatory and in AR DCM SWS documented */
# define DCM_MODEMGR_ARENV_MODE_ECURESET_NONE                        RTE_MODE_DcmEcuReset_NONE
# define DCM_MODEMGR_ARENV_MODE_ECURESET_HARD                        RTE_MODE_DcmEcuReset_HARD
# define DCM_MODEMGR_ARENV_MODE_ECURESET_KEYONOFF                    RTE_MODE_DcmEcuReset_KEYONOFF
# define DCM_MODEMGR_ARENV_MODE_ECURESET_SOFT                        RTE_MODE_DcmEcuReset_SOFT
# define DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_OEM                RTE_MODE_DcmEcuReset_JUMPTOBOOTLOADER
# define DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_SYS                RTE_MODE_DcmEcuReset_JUMPTOSYSSUPPLIERBOOTLOADER
# define DCM_MODEMGR_ARENV_MODE_ECURESET_EXECUTE                     RTE_MODE_DcmEcuReset_EXECUTE
# define DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_ENABLE                  RTE_MODE_DcmModeRapidPowerShutDown_ENABLE_RAPIDPOWERSHUTDOWN
# define DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_DISABLE                 RTE_MODE_DcmModeRapidPowerShutDown_DISABLE_RAPIDPOWERSHUTDOWN
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/*! Task priorities */
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
# define DCM_TSK_PRIO_NONE                                           /* must not be used */       /*!< Always use a concrete priority! */
# define DCM_TSK_PRIO_LOW                                            ((Dcm_TskTaskPrioMemType)0)  /*!< Low priority - can be interrupted by higher priority tasks and ISRs */
# define DCM_TSK_PRIO_HIGH                                           ((Dcm_TskTaskPrioMemType)1)  /*!< High priority - cannot be interrupted by any other tasks, only ISRs */
# define DCM_TSK_NUM_PRIOS                                           ((Dcm_TskTaskPrioMemType)2)  /*!< The number of different task priorities */
#else
# define DCM_TSK_PRIO_NONE                                           ((Dcm_TskTaskPrioMemType)0)  /*!< Default priority - to be used only in case no task-splitting is used */
# define DCM_TSK_PRIO_LOW                                            DCM_TSK_PRIO_NONE            /*!< Low priority - can be interrupted by ISRs */
# define DCM_TSK_PRIO_HIGH                                           DCM_TSK_PRIO_NONE            /*!< High priority - shares the same priority as low */
# define DCM_TSK_NUM_PRIOS                                           ((Dcm_TskTaskPrioMemType)1)  /*!< The number of different task priorities */
#endif

/*! Task event representing that no events are available */
#define DCM_TSK_EV_NONE                                              ((Dcm_TskTaskEvMemType)0x00u)

/* Task setup informations */
/*! Task execution types */
#define DCM_TSK_ATR_EXEC_ONCE                                        ((Dcm_TskTaskAttributeType)0x00u)  /*!< Task will be executed only once per Dcm_MainFunction() call */
#define DCM_TSK_ATR_EXEC_MULTI                                       ((Dcm_TskTaskAttributeType)0x01u)  /*!< Task can be executed multiple times per Dcm_MainFunction() call if still has any active events */
/*! Task termination ability types */
#define DCM_TSK_ATR_KILL_NEVER                                       ((Dcm_TskTaskAttributeType)0x00u)  /*!< Task can never be terminated on a kill-task signal */
#define DCM_TSK_ATR_KILL_ALWAYS                                      ((Dcm_TskTaskAttributeType)0x02u)  /*!< Task will be terminated on a kill task signal */

/*! Task runtime status flags */
#define DCM_TSK_TASK_FLAG_NONE                                       ((Dcm_TskTaskFlagType)0x00u) /*!< Task is in normal mode (running) */
#define DCM_TSK_TASK_FLAG_KILLED                                     ((Dcm_TskTaskFlagType)0x01u) /*!< Task is in terminated mode (no more events can be set) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_DIDMGR_RANGELOOKUPRSLT_NOMATCH                          ((Dcm_DidMgrRangeLookUpResultType)0x00)
# define DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_SUPPORTED                ((Dcm_DidMgrRangeLookUpResultType)0x01)
# define DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_UNSUPPORTED              ((Dcm_DidMgrRangeLookUpResultType)0x02)
# define DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_ANY                      ((Dcm_DidMgrRangeLookUpResultType)(DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_SUPPORTED | DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_UNSUPPORTED))
# define DCM_DIDMGR_RANGELOOKUPRSLT_PENDING                          ((Dcm_DidMgrRangeLookUpResultType)0x04)

/* DID operation types - derive from the extern filter API */
# define DCM_DIDMGR_OP_READ                                          DCM_DID_OP_READ
# define DCM_DIDMGR_OP_WRITE                                         DCM_DID_OP_WRITE
# define DCM_DIDMGR_OP_IO                                            DCM_DID_OP_IO
# define DCM_DIDMGR_OP_SCALINGINFO                                   DCM_DID_OP_SCALINGINFO
# define DCM_DIDMGR_OP_DEFINE                                        DCM_DID_OP_DEFINE

/* Service port operation types */
# define DCM_DIDMGR_OPTYPE_READ                                      ((Dcm_DidMgrOpCallMemType)0x01u)
# define DCM_DIDMGR_OPTYPE_READLENGTH                                ((Dcm_DidMgrOpCallMemType)0x02u)
# define DCM_DIDMGR_OPTYPE_READCHKCOND                               ((Dcm_DidMgrOpCallMemType)0x04u)
# define DCM_DIDMGR_OPTYPE_RANGEREAD                                 DCM_DIDMGR_OPTYPE_READ
# define DCM_DIDMGR_OPTYPE_RANGEREADLENGTH                           DCM_DIDMGR_OPTYPE_READLENGTH

# define DCM_DIDMGR_OPTYPE_WRITE                                     ((Dcm_DidMgrOpCallMemType)0x01u)
# define DCM_DIDMGR_OPTYPE_RANGEWRITE                                DCM_DIDMGR_OPTYPE_WRITE

/* this value shall be for both OP_READ and OP_WRITE OP_TYPES the same! */
# define DCM_DIDMGR_OPTYPE_RANGEISDIDAVAILABLE                       ((Dcm_DidMgrOpCallMemType)0x10u)

# define DCM_DIDMGR_OPTYPE_GETSCALING                                ((Dcm_DidMgrOpCallMemType)0x01u)

# define DCM_DIDMGR_OPTYPE_DEFINE                                    ((Dcm_DidMgrOpCallMemType)0x01u)

# define DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU                            ((Dcm_DidMgrOpCallMemType)0x01u)
# define DCM_DIDMGR_OPTYPE_IO_RST2DEF                                ((Dcm_DidMgrOpCallMemType)0x02u)
# define DCM_DIDMGR_OPTYPE_IO_FRZCURSTATE                            ((Dcm_DidMgrOpCallMemType)0x04u)
# define DCM_DIDMGR_OPTYPE_IO_SHRTTRMADJ                             ((Dcm_DidMgrOpCallMemType)0x08u)

/* Service port operation classes */
# define DCM_DIDMGR_OPCLS_READ_RANGE                                 ((Dcm_DidMgrOpClassType)0)
# define DCM_DIDMGR_OPCLS_READ_SYNC                                  ((Dcm_DidMgrOpClassType)1)
# define DCM_DIDMGR_OPCLS_READ_ASYNC                                 ((Dcm_DidMgrOpClassType)2)
# define DCM_DIDMGR_OPCLS_READ_PAGED                                 ((Dcm_DidMgrOpClassType)3)
# define DCM_DIDMGR_OPCLS_READ_VID                                   ((Dcm_DidMgrOpClassType)4)
# define DCM_DIDMGR_OPCLS_READ_SR                                    ((Dcm_DidMgrOpClassType)5)

# define DCM_DIDMGR_OPCLS_READLENGTH_RANGE                           ((Dcm_DidMgrOpClassType)0)
# define DCM_DIDMGR_OPCLS_READLENGTH_SYNC                            ((Dcm_DidMgrOpClassType)1)
# define DCM_DIDMGR_OPCLS_READLENGTH_ASYNC                           ((Dcm_DidMgrOpClassType)2)

# define DCM_DIDMGR_OPCLS_READCHK_COND_SYNC                          ((Dcm_DidMgrOpClassType)0)
# define DCM_DIDMGR_OPCLS_READCHK_COND_ASYNC                         ((Dcm_DidMgrOpClassType)1)

# define DCM_DIDMGR_OPCLS_WRITE_RANGE                                ((Dcm_DidMgrOpClassType)0)
# define DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_ERROR                 ((Dcm_DidMgrOpClassType)1)
# define DCM_DIDMGR_OPCLS_WRITE_NLEN_ASYNC_NRES_ERROR                ((Dcm_DidMgrOpClassType)2)
# define DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_NRES_ERROR                  ((Dcm_DidMgrOpClassType)3)
# define DCM_DIDMGR_OPCLS_WRITE_LEN_ASYNC_NRES_ERROR                 ((Dcm_DidMgrOpClassType)4)
# define DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_RES_ERROR                   ((Dcm_DidMgrOpClassType)5)
# define DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_NERROR                ((Dcm_DidMgrOpClassType)6)

# define DCM_DIDMGR_OPCLS_ISDIDAVAILABLE                             ((Dcm_DidMgrOpClassType)0)

# define DCM_DIDMGR_OPCLS_GETSCALING_SYNC                            ((Dcm_DidMgrOpClassType)0)
# define DCM_DIDMGR_OPCLS_GETSCALING_ASYNC                           ((Dcm_DidMgrOpClassType)1)

# define DCM_DIDMGR_OPCLS_DEFINE                                     ((Dcm_DidMgrOpClassType)0)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR         ((Dcm_DidMgrOpClassType)0)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_NCEMR_ERROR          ((Dcm_DidMgrOpClassType)1)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_NCEMR_ERROR           ((Dcm_DidMgrOpClassType)2)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR        ((Dcm_DidMgrOpClassType)3)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_NCEMR_ERROR         ((Dcm_DidMgrOpClassType)4)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_NCEMR_ERROR          ((Dcm_DidMgrOpClassType)5)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR            ((Dcm_DidMgrOpClassType)6)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR         ((Dcm_DidMgrOpClassType)7)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR8_ERROR          ((Dcm_DidMgrOpClassType)8)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR8_ERROR           ((Dcm_DidMgrOpClassType)9)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR        ((Dcm_DidMgrOpClassType)10)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR8_ERROR         ((Dcm_DidMgrOpClassType)11)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR8_ERROR          ((Dcm_DidMgrOpClassType)12)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR        ((Dcm_DidMgrOpClassType)13)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR16_ERROR         ((Dcm_DidMgrOpClassType)14)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR16_ERROR          ((Dcm_DidMgrOpClassType)15)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR       ((Dcm_DidMgrOpClassType)16)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR16_ERROR        ((Dcm_DidMgrOpClassType)17)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR16_ERROR         ((Dcm_DidMgrOpClassType)18)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR        ((Dcm_DidMgrOpClassType)19)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR32_ERROR         ((Dcm_DidMgrOpClassType)20)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR32_ERROR          ((Dcm_DidMgrOpClassType)21)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR       ((Dcm_DidMgrOpClassType)22)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR32_ERROR        ((Dcm_DidMgrOpClassType)23)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR32_ERROR         ((Dcm_DidMgrOpClassType)24)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR         ((Dcm_DidMgrOpClassType)25)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMRN_ERROR          ((Dcm_DidMgrOpClassType)26)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMRN_ERROR           ((Dcm_DidMgrOpClassType)27)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR        ((Dcm_DidMgrOpClassType)28)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMRN_ERROR         ((Dcm_DidMgrOpClassType)29)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMRN_ERROR          ((Dcm_DidMgrOpClassType)30)

# define DCM_DIDMGR_OPCLS_IO_FIRST_OPCLS_WITH_EXT_CEMR               DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR

# define DCM_DIDMGR_LOOKUP_STATE_DIDRANGE                            ((Dcm_DidMgrDidLookUpStateType)0)
# define DCM_DIDMGR_LOOKUP_STATE_CONCRETEDID                         ((Dcm_DidMgrDidLookUpStateType)1)
# define DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN                    ((Dcm_DidMgrDidLookUpStateType)2)

# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
#  define Dcm_DidMgrWrapAsyncDidOpStatus(opStatus)                   (opStatus)                                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_DidMgrWrapAsyncDidOpStatus(opStatus)                   (DCM_INITIAL)                                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# if (DCM_DIDMGR_STATIC_DID_ASYNC_SUPPORT_ENABLED == STD_ON)
#  define Dcm_DidMgrWrapStaticDidAsyncOpStatus(opStatus)             (opStatus)                                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_DidMgrWrapStaticDidAsyncOpStatus(opStatus)             (DCM_INITIAL)                                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)
#  if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
#   define Dcm_DidMgrReadDid                                         Dcm_DidMgrReadDidPaged
#  else
#   define Dcm_DidMgrReadDid                                         Dcm_DidMgrReadDidLinear
#  endif
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_RIDMGR_OP_START                                         ((Dcm_RidMgrOpType)0x01u)
# define DCM_RIDMGR_OP_STOP                                          ((Dcm_RidMgrOpType)0x02u)
# define DCM_RIDMGR_OP_REQRSLTS                                      ((Dcm_RidMgrOpType)0x04u)

# define DCM_RIDMGR_OPTYPE_NONE                                      ((Dcm_RidMgrOpCallType)0u)
# define DCM_RIDMGR_OPTYPE_REQ                                       ((Dcm_RidMgrOpCallType)1u)
# define DCM_RIDMGR_OPTYPE_REQ_RES                                   ((Dcm_RidMgrOpCallType)2u)
# define DCM_RIDMGR_OPTYPE_RES                                       ((Dcm_RidMgrOpCallType)3u)
# define DCM_RIDMGR_OPTYPE_REQ_DYNLEN                                ((Dcm_RidMgrOpCallType)4u)
# define DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES                            ((Dcm_RidMgrOpCallType)5u)
# define DCM_RIDMGR_OPTYPE_RES_DYNLEN                                ((Dcm_RidMgrOpCallType)6u)
# define DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_DYNLEN                     ((Dcm_RidMgrOpCallType)7u)
# define DCM_RIDMGR_OPTYPE_REQ_RES_DYNLEN                            ((Dcm_RidMgrOpCallType)8u)

# define DCM_RIDMGR_DYNLEN_MASK_REQ                                  ((Dcm_RidMgrDynLenMaskType)0x01u)
# define DCM_RIDMGR_DYNLEN_MASK_RES                                  ((Dcm_RidMgrDynLenMaskType)0x02u)

# define Dcm_Svc31Op                                                 (Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.Op)
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
# define DCM_OBDDTCMGR_PROGRESS_INITAL                               ((Dcm_RepeaterProgressType)0)
# define DCM_OBDDTCMGR_PROGRESS_GETNUMFLTRDDTC                       ((Dcm_RepeaterProgressType)1)
# define DCM_OBDDTCMGR_PROGRESS_COPYLINEARDATA                       ((Dcm_RepeaterProgressType)2)
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/*! Network to diagnostic variant bridge abstraction */
#if (DCM_VARMGR_MODE_POSTBUILD_ANY_ENABLED == STD_ON) && (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
# define Dcm_PbCfgDiagSvcId2ProtMap                                  (DCM_VARMGR_ACTIVE_BRIDGEVAR.Svc2ProtocolMap)
#else
# define Dcm_PbCfgDiagSvcId2ProtMap                                  Dcm_CfgDiagSvcId2ProtMap
#endif

/*! Diagnostic entity evaluation level */
#define DCM_DIAG_CHK_LVL_SERVICE_ID                                  ((Dcm_DiagCheckLvlType)0u) /*!< Evaluation on diagnostic service ID level */
#define DCM_DIAG_CHK_LVL_PARAMETER                                   ((Dcm_DiagCheckLvlType)1u) /*!< Evaluation on diagnostic parameter ID level */
#define DCM_DIAG_CHK_LVL_SUBFUNC                                     ((Dcm_DiagCheckLvlType)2u) /*!< Evaluation on diagnostic sub-function ID level */

/*! Total number of diagnostic entities that can be verified (use always the one with highest ID as reference) */
#define DCM_DIAG_NUM_CHK_LVLS                                        (DCM_DIAG_CHK_LVL_SUBFUNC + 1u)

/*! Bitmap encoding for the enumerator values below (used to build the AR standard confirmation status values e.g. DCM_RES_POS_OK !) */
#define DCM_DIAG_RES_ANY_OK                                          ((Dcm_ConfirmationStatusType)0x00u) /*!< The response (positive/negative) was successfully sent */
#define DCM_DIAG_RES_ANY_NOT_OK                                      ((Dcm_ConfirmationStatusType)0x01u) /*!< The response (positive/negative) transmission failed */
#define DCM_DIAG_RES_POS_ANY                                         ((Dcm_ConfirmationStatusType)0x00u) /*!< It is a positive response */
#define DCM_DIAG_RES_NEG_ANY                                         ((Dcm_ConfirmationStatusType)0x02u) /*!< It is a negative response */

/*! Diagnostic kernel application notification levels reached during diagnostic service processing.
    This levels are used to determine which finalization callouts shall be performed later (e.g. service execution confirmation, post-handlers etc.) */
#define DCM_DIAG_APPL_NOTIFICATION_NONE                              ((Dcm_DiagApplNotificationType)0x00u) /*!< No application call was made */
#define DCM_DIAG_APPL_NOTIFICATION_OEM                               ((Dcm_DiagApplNotificationType)0x01u) /*!< Manufacturer specific request indication(s) reached (Xxx_Indication()) */
#define DCM_DIAG_APPL_NOTIFICATION_SYS                               ((Dcm_DiagApplNotificationType)0x02u) /*!< System supplier specific request indication(s) reached (Xxx_Indication()) */
#define DCM_DIAG_APPL_NOTIFICATION_SVC_HDLR                          ((Dcm_DiagApplNotificationType)0x04u) /*!< Diagnostic service handler reached (Dcm_ServiceXXProcessor() or user defined service callout) */
#define DCM_DIAG_APPL_NOTIFICATION_SID_FOUND                         ((Dcm_DiagApplNotificationType)0x08u) /*!< The look-up engine has verified the requested SID as a valid one */

/*! Diagnostic kernel request queued flags. These are used to keep track of any overlapping diagnostic request in processing with a new one just won a request prioritization
    Especially in case of split-task this mechanism provides a look-ahead whether a new request is already queue to be processed within the low-priority Dcm_DiagTaskWorker() */
#define DCM_DIAG_QUEUE_FLAG_NONE                                     ((Dcm_DiagProcessorFlagType)0x00u) /*!< There is no diagnostic request queued to be processed */
#define DCM_DIAG_QUEUE_FLAG_IS_WAITING                               ((Dcm_DiagProcessorFlagType)0x01u) /*!< There is already a diagnostic request queued (waiting) to be processed */
#define DCM_DIAG_QUEUE_FLAG_IS_ACTIVE                                ((Dcm_DiagProcessorFlagType)0x02u) /*!< There diagnostic request in started processing */

/*! Diagnostic service specific properties */
#define DCM_DIAG_SVC_CFG_PROP_HAS_SUBFUNC                            ((DcmCfg_DiagServicePropertiesType)0x01u) /*!< Has a sub-function parameter */
#define DCM_DIAG_SVC_CFG_PROP_CALL_POST_HDLR_ALWAYS                  ((DcmCfg_DiagServicePropertiesType)0x02u) /*!< Requires the post-handler (Dcm_ServiceXXPostHandler()) to be called always once the service evaluation has started */

/*! Getter for the diagnostic session specific P2 timings */
#define Dcm_DiagGetP2Time(sesStateIdx)                               (Dcm_CfgStateSessionInfo[(sesStateIdx)].P2ServerTime.P2)                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_DiagGetP2StarTime(sesStateIdx)                           (Dcm_CfgStateSessionInfo[(sesStateIdx)].P2ServerTime.P2Star)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Specifies the maximum buffer size required for the final unsolicited response (i.e. after ECU re-programming)
  Note: Currently the longest possible response is for SID 0x10, that has: SID*1 + SF*1 + P2*2 + P2Ex*2 = 6 Bytes */
#define DCM_DIAG_START_UP_FBL_RES_SIZE                               6u
/*! Variant management optimization abstraction */
#define DCM_VARMGR_ACTIVE_COMVAR                                     (Dcm_SingletonContext.VarMgr.ActiveComVariant)      /*!< Substitution for COM-criteria storage */
#define DCM_VARMGR_ACTIVE_BRIDGEVAR                                  (Dcm_SingletonContext.VarMgr.ActiveBridgeVariant)   /*!< Substitution for COM-to-CFG bridge storage */
#define DCM_VARMGR_ACTIVE_RAMVAR                                     (Dcm_SingletonContext.VarMgr.ActiveRamVariant)      /*!< Substitution for PBL RAM storage */
#define DCM_VARMGR_ACTIVE_ROMVAR                                     (Dcm_SingletonContext.VarMgr.ActiveRomVariant)      /*!< Substitution for PBL ROM storage */
#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# define Dcm_PbCfgVarMgrDiagVariantFilter                            (DCM_VARMGR_ACTIVE_ROMVAR.DiagRom.VariantFilter)
#else
# define Dcm_PbCfgVarMgrDiagVariantFilter                            Dcm_CfgVarMgrVariantTable
#endif
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC03_PROGRESS_READDTCBYSTATUSMASK                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC04_PROGRESS_REPEATERPROXY_SELECT_DTC                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC04_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC07_PROGRESS_READDTCBYSTATUSMASK                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC09_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC0A_PROGRESS_READDTCBYSTATUSMASK                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
/*! Service 0x10 processing steps */
# define DCM_SVC10_PROGRESS_WAIT_RESET_ACK                           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK                           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
# define DCM_SVC10_PROGRESS_SET_PRGCOND                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2))
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
/*! Service 0x11 processing steps */
# define DCM_SVC11_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC11_PROGRESS_ECURST_WAITFORACK                        ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
# define DCM_SVC11_RAPPWRDWN_WAITFORACK                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2))
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/*! Service 0x14 processing steps */
# define DCM_SVC14_PROGRESS_REPEATERPROXY_SELECT_DTC                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC14_PROGRESS_REPEATERPROXY_CHECK_SELECTION_RESULT     ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
# define DCM_SVC14_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2))
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/*! Service 0x19 processing steps */
# define DCM_SVC19_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC19_PROGRESS_UTI_COPYLINEARDATA                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))

# define DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 10))
# define DCM_SVC19_PROGRESS_DEMCHAIN_DISABLERECORDUPDATE             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 11))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC                  ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 12))
# define DCM_SVC19_PROGRESS_DEMCHAIN_SELECTFFREC                     ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 13))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFFFREC                  ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 14))
# define DCM_SVC19_PROGRESS_DEMCHAIN_SELECTEXTDATAREC                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 15))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFEXTDATAREC             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 16))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC                  ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 17))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDSEVERITY            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 18))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETSEVERITYOFDTC                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 19))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETFUNCUNITOFDTC                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 20))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDDTC                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 21))
# define DCM_SVC19_PROGRESS_DEMCHAIN_PUTNUMFLTRDDTC                  ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 22))
# define DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDFDC                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 23))
# define DCM_SVC19_PROGRESS_DEMCHAIN_WWHOBD_GETNEXTFLTRDSEVERITY     ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 24))

# define DCM_SVC19_PROGRESS_CHAIN_END                                DCM_REPEATER_PROGRESS_USERS_LAST /*!< Service 0x19 final processing step */

/*! Service 0x19 paged-buffer updater dispatching items IDs */
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_RECORD                      ((Dcm_Svc19SubUpdaterType)0u)
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY                    ((Dcm_Svc19SubUpdaterType)1u)
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_FDC                         ((Dcm_Svc19SubUpdaterType)2u)
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY_WWHOBD             ((Dcm_Svc19SubUpdaterType)3u)
# define DCM_SVC_19_UPDATE_GET_NXT_FLTRD_DTC                         ((Dcm_Svc19SubUpdaterType)4u)
# define DCM_SVC_19_UPDATE_GET_EXT_RECORD                            ((Dcm_Svc19SubUpdaterType)5u)
# define DCM_SVC_19_UPDATE_SELECT_FF_RECORD                          ((Dcm_Svc19SubUpdaterType)6u)
# define DCM_SVC_19_UPDATE_GET_FF_RECORD                             ((Dcm_Svc19SubUpdaterType)7u)
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/*! List of DEM filter configurations */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_01                           ((Dcm_Svc19DemSetFilterClassType)0u) /*!< For SF 0x01, 0x02, 0x14, 0x0A */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_02                           ((Dcm_Svc19DemSetFilterClassType)1u) /*!< For SF 0x07, 0x08 */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_03                           ((Dcm_Svc19DemSetFilterClassType)2u) /*!< For SF 0x11, 0x0F */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_04                           ((Dcm_Svc19DemSetFilterClassType)3u) /*!< For SF 0x12, 0x13 */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_05                           ((Dcm_Svc19DemSetFilterClassType)4u) /*!< For SF 0x15 */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_06                           ((Dcm_Svc19DemSetFilterClassType)5u) /*!< For SF 0x17 */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_07                           ((Dcm_Svc19DemSetFilterClassType)6u) /*!< For SF 0x42 */

/*! Total number of DEM filter configurations */
# define DCM_SVC_19_DEM_SETFILTER_NUM_CLASSES                        (DCM_SVC_19_DEM_SETFILTER_CLASS_07+1u)

/*! API Dcm_Svc19UtiReportDtcByStatusMaskData DTC status mask usage parametrization */
# define DCM_SVC_19_USE_MASK_REQ                                     ((Dcm_Svc19DemSetFilterMaskUsageType)0u) /*!< Extract and use the mask from request data */
# define DCM_SVC_19_USE_MASK_ALL                                     ((Dcm_Svc19DemSetFilterMaskUsageType)1u) /*!< Do report all supported DTCs */

/*! DTC extended record number wildcard types */
# define DCM_SVC_19_RECNUM_ALL                                       ((uint8)0xFFu) /*!< All supported extended data records */
# define DCM_SVC_19_RECNUM_OBD_ALL                                   ((uint8)0xFEu) /*!< Report only OBD related extended data records */
/*! DTC (extended/freeze frame) record list end marker (0xFF is not a valid single record ID) */
# define DCM_SVC_19_RECLIST_END                                      ((uint8)0xFFu)

/*! Abstract DTC record iterator result values */
# define DCM_SVC19_UTI_REC_ITER_RSLT_OK                              ((Dcm_Svc19UtiRecordIterResultType)0) /*!< Next DTC record found and can be used */
# define DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS                 ((Dcm_Svc19UtiRecordIterResultType)1) /*!< Iteration ends here */
/*! Vector DCM to Vector DEM Interface check */
# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
#  if ( defined(DCM_SVC_19_NUM_EXTDATA_RECID) && !defined (DCM_SVC_19_LST_EXTDATA_RECID)) || \
      (!defined(DCM_SVC_19_NUM_EXTDATA_RECID) &&  defined (DCM_SVC_19_LST_EXTDATA_RECID))
#   error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#  else
#   if (defined(DCM_SVC_19_NUM_EXTDATA_RECID) && defined (DCM_SVC_19_LST_EXTDATA_RECID))                                                             /* COV_DCM_UNSUPPORTED XF xf xf */
/* the DCM knows the extended data records of the DEM */
#   else
#    if ( defined(DEM_DCM_NUM_EXTDATA_RECID) && !defined (DEM_DCM_LST_EXTDATA_RECID)) || \
        (!defined(DEM_DCM_NUM_EXTDATA_RECID) &&  defined (DEM_DCM_LST_EXTDATA_RECID))
#     error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#    else
#     if (defined(DEM_DCM_NUM_EXTDATA_RECID) && defined (DEM_DCM_LST_EXTDATA_RECID))                                                                 /* COV_DCM_SUPPORT_WITH_MSR_DEM TX tx tx */
/* use the information provided by DEM */
#      define DCM_SVC_19_NUM_EXTDATA_RECID                           DEM_DCM_NUM_EXTDATA_RECID
#      define DCM_SVC_19_LST_EXTDATA_RECID                           DEM_DCM_LST_EXTDATA_RECID
#     else
#      define DCM_SVC_19_NUM_EXTDATA_RECID                           0
#      define DCM_SVC_19_LST_EXTDATA_RECID                           /* empty */
#      error "Missing information for the supported DTC Extended Data Records! See DCM TechRef!"
#     endif
#    endif
#   endif
#  endif
/*! Actual complete extended data record list sizes */
#  define DCM_SVC_19_EXTDATA_RECID_SIZE                              (DCM_SVC_19_NUM_EXTDATA_RECID     + 1)
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
#  if ( defined(DCM_SVC_19_NUM_OBD_EXTDATA_RECID) && !defined (DCM_SVC_19_LST_OBD_EXTDATA_RECID)) || \
      (!defined(DCM_SVC_19_NUM_OBD_EXTDATA_RECID) &&  defined (DCM_SVC_19_LST_OBD_EXTDATA_RECID))
#   error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#  else
#   if (defined(DCM_SVC_19_NUM_OBD_EXTDATA_RECID) && defined (DCM_SVC_19_LST_OBD_EXTDATA_RECID))                                                     /* COV_DCM_UNSUPPORTED XF xf xf */
/* the DCM knows the OBD extended data records of the DEM */
#   else
#    if ( defined(DEM_DCM_NUM_OBD_EXTDATA_RECID) && !defined (DEM_DCM_LST_OBD_EXTDATA_RECID)) || \
        (!defined(DEM_DCM_NUM_OBD_EXTDATA_RECID) &&  defined (DEM_DCM_LST_OBD_EXTDATA_RECID))
#     error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#    else
#     if ( defined(DEM_DCM_NUM_OBD_EXTDATA_RECID) && defined (DEM_DCM_LST_OBD_EXTDATA_RECID))                                                        /* COV_DCM_SUPPORT_WITH_MSR_DEM TX tx tx */
/* use the information provided by DEM */
#      define DCM_SVC_19_NUM_OBD_EXTDATA_RECID                       DEM_DCM_NUM_OBD_EXTDATA_RECID
#      define DCM_SVC_19_LST_OBD_EXTDATA_RECID                       DEM_DCM_LST_OBD_EXTDATA_RECID
#     else
#      define DCM_SVC_19_NUM_OBD_EXTDATA_RECID                       0
#      define DCM_SVC_19_LST_OBD_EXTDATA_RECID                       /* empty */
#     endif
#    endif
#   endif
#  endif
/*! Actual OBD extended data record list sizes */
#  define DCM_SVC_19_OBD_EXTDATA_RECID_SIZE                          (DCM_SVC_19_NUM_OBD_EXTDATA_RECID + 1)

#  if (DCM_SVC_19_NUM_OBD_EXTDATA_RECID > 0)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
#   define DCM_SVC_19_OBD_EXT_RECORD_ENABLED                         STD_ON
#  endif
# endif

# if defined(DCM_SVC_19_OBD_EXT_RECORD_ENABLED)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/* already set */
# else
#  define DCM_SVC_19_OBD_EXT_RECORD_ENABLED                          STD_OFF
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
#  if ( defined(DCM_SVC_19_NUM_FRZFRAME_RECID) && !defined (DCM_SVC_19_LST_FRZFRAME_RECID)) || \
      (!defined(DCM_SVC_19_NUM_FRZFRAME_RECID) &&  defined (DCM_SVC_19_LST_FRZFRAME_RECID))
#   error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#  else
#   if (defined(DCM_SVC_19_NUM_FRZFRAME_RECID) && defined (DCM_SVC_19_LST_FRZFRAME_RECID))                                                           /* COV_DCM_UNSUPPORTED XF xf xf */
/* the DCM knows the OBD extended data records of the DEM */
#   else
#    if ( defined(DEM_DCM_NUM_FRZFRAME_RECID) && !defined (DEM_DCM_LST_FRZFRAME_RECID)) || \
        (!defined(DEM_DCM_NUM_FRZFRAME_RECID) &&  defined (DEM_DCM_LST_FRZFRAME_RECID))
#     error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#    else
#     if ( defined(DEM_DCM_NUM_FRZFRAME_RECID) && defined (DEM_DCM_LST_FRZFRAME_RECID))                                                              /* COV_DCM_SUPPORT_WITH_MSR_DEM TX tx tx */
/* use the information provided by DEM */
#      define DCM_SVC_19_NUM_FRZFRAME_RECID                          DEM_DCM_NUM_FRZFRAME_RECID
#      define DCM_SVC_19_LST_FRZFRAME_RECID                          DEM_DCM_LST_FRZFRAME_RECID
#     else
#      define DCM_SVC_19_NUM_FRZFRAME_RECID                          0
#      define DCM_SVC_19_LST_FRZFRAME_RECID                          /* empty */
#      error "Missing information for the supported DTC Freeze Frame Records! See DCM TechRef!"
#     endif
#    endif
#   endif
#  endif
/*! Actual complete freeze frame data record list sizes */
#  define DCM_SVC_19_FRZFRAME_RECID_SIZE                             (DCM_SVC_19_NUM_FRZFRAME_RECID    + 1)
# endif
/*! Per default - no patching of DTC status masks required */
# if !defined(DCM_EXT_SVC19_PATCH_CONTEXT)                                                                                                           /* COV_DCM_UNSUPPORTED TX */
#  define DCM_EXT_SVC19_PATCH_CONTEXT                                /* not used */
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC22_PROGRESS_DIDLOOKUP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC22_PROGRESS_CHECKCONDITION                           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
# define DCM_SVC22_PROGRESS_GETLENGTH                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2))
# define DCM_SVC22_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3))
# define DCM_SVC22_PROGRESS_READDATA                                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 4))
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC23_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC23_PROGRESS_READMEMORY                               ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC24_PROGRESS_DIDLOOKUP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC24_PROGRESS_EXECUTEOP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/*! Service 0x27 processing steps */
# define DCM_SVC27_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC27_PROGRESS_SETATTEMPTCNTR                           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
# define DCM_SVC27_PROGRESS_SEEDREPEATER                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2))
# define DCM_SVC27_PROGRESS_KEYREPEATER                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3))
# define DCM_SVC27_PROGRESS_CHECKATTEMPTSEXCEEDED                    ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 4))

/*! Get-Seed port operation classes  */
# define DCM_SVC27_OPCLS_SEED_WITHOUT_ADR                            ((Dcm_Svc27OpClassType)0)
# define DCM_SVC27_OPCLS_SEED_WITH_ADR                               ((Dcm_Svc27OpClassType)1)
# define DCM_SVC_27_LEVEL_MASK                                       (Dcm_UtiGetMaskFromXintType(uint8, DCM_STATE_SECURITY_NUM_LEVELS))
# define DCM_SVC_27_SEED_LVL_INVALID                                 ((uint8)0x00u)
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/*! Service 0x28 processing steps */
# define DCM_SVC28_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))

# define DCM_SVC_28_CTRL_OP_MASK                                     (0x03u)/*!< Leaves the relevant bits for the conversion function "sub-function id -> operation type" since only sub-functions 0x00-0x03 are handled in DCM */
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC2A_RATE_TYPE_SLOW                                    ((Dcm_Svc2ASchedRateMemType)0)
# define DCM_SVC2A_RATE_TYPE_MED                                     ((Dcm_Svc2ASchedRateMemType)1)
# define DCM_SVC2A_RATE_TYPE_FAST                                    ((Dcm_Svc2ASchedRateMemType)2)

# define DCM_SVC2A_RATE_TYPE_MASK                                    ((Dcm_Svc2ASchedRateMemType)0x03u)

# define DCM_SVC2A_RATE_TYPE_STOPPED                                 ((Dcm_Svc2ASchedRateMemType)0x10u)
# define DCM_SVC2A_RATE_TYPE_RESERVED                                ((Dcm_Svc2ASchedRateMemType)0x40u)
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC2A_MAX_RESPONSE_LEN                                  ((uint8)(DCM_NET_PERIODIC_BUFFER_SIZE - 1u))

# define DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC2A_PROGRESS_DID_CHECKCONDITION                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
# define DCM_SVC2A_PROGRESS_DID_GETLENGTH                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2))
# define DCM_SVC2A_PROGRESS_STOPPED_DID_LOOKUP                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3))
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC2C_INVALID_DYNDID_HDL                                (Dcm_UtiMaxValueOfUintType(Dcm_CfgDidMgrDynDidHandleMemType))

# define DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED                        0u

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON) && \
     (DCM_DIDMGR_STATIC_DID_ASYNC_SUPPORT_ENABLED == STD_ON) && \
     (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_COND_ENABLED == STD_ON)
#  define DCM_SVC_2C_NUM_PROCESS_CONTEXTS                            2u
#  define DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY                     1u
# else
#  define DCM_SVC_2C_NUM_PROCESS_CONTEXTS                            1u
#  define DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY                     0u
# endif

# if(DCM_DEV_ERROR_REPORT == STD_ON)
#  define DCM_SVC_2C_READ_BUFFER_OVERHEAD                            DCM_DEBUG_BUFFEROVFLPATTERN_SIZE
# else
#  define DCM_SVC_2C_READ_BUFFER_OVERHEAD                            0
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC2C_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP                          ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
# define DCM_SVC2C_PROGRESS_01SRC_DIDCHECKCONDITIONS                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2))
# define DCM_SVC2C_PROGRESS_01SRC_DIDGETLENGTH                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3))
# define DCM_SVC2C_PROGRESS_03_DIDLOOKUP                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 4))
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC2E_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)1)
# define DCM_SVC2E_PROGRESS_ECECUTEOP                                ((Dcm_RepeaterProgressType)2)
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC2F_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC2F_PROGRESS_EXECUTEOP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
# define DCM_SVC2F_PROGRESS_GETLENGTH                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2))
# define DCM_SVC2F_PROGRESS_READDATA                                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3))
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC31_PROGRESS_EXECUTEOP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC3D_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
# define DCM_SVC3D_PROGRESS_WRITEMEMORY                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1))
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/*! Service 0x14 processing steps */
# define DCM_SVC85_PROGRESS_REPEATERPROXY                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC86_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0))
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
/* ----------------------------------------------
 ~&&&   Function-like macros
---------------------------------------------- */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define Dcm_MemMgrGetMemBlockLenSize(formatByte)                    (Dcm_UtiGetHiNibble(formatByte))                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_MemMgrGetMemBlockAddrSize(formatByte)                   (Dcm_UtiGetLoNibble(formatByte))                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_MemMgrGetMemBlockInfoLength(formatByte)                 ((uint8)(Dcm_MemMgrGetMemBlockAddrSize(formatByte) + Dcm_MemMgrGetMemBlockLenSize(formatByte))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/* Check if it is an available ID at all: (id MOD 0x20) == 0 */
# define Dcm_ObdIdMgrIsAvailabilityId(obdId)                         (((obdId) & 0x1Fu) == 0)                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ObdIdMgrGetObdIdMaskBit(obdId)                          ((uint32)(0x01UL << (31u - (((obdId)-1u) & 0x1Fu))))                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ObdIdMgrIsIdSupported(availMask, obdId)                 (Dcm_UtiBitOpTest(uint32, (availMask), Dcm_ObdIdMgrGetObdIdMaskBit(obdId)))     /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ObdIdMgrGetAvailabilityIdIdx(obdId)                     ((uint8)(((uint8)(obdId)) >> 5u))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ObdIdMgrGetAvailabilityId(id)                           ((uint8)((id) & 0xE0))                                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ObdIdMgrGetMaskValue(obdAidId, pMaskData)               ((pMaskData)[Dcm_ObdIdMgrGetAvailabilityIdIdx(obdAidId)])                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/*! AR3.x SchM enter exclusive area implementation */
# define Dcm_UtiArEnvEnterCriticalSection()                          SchM_Enter_Dcm(DCM_EXCLUSIVE_AREA_0)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! AR3.x SchM leave exclusive area implementation */
# define Dcm_UtiArEnvLeaveCriticalSection()                          SchM_Exit_Dcm(DCM_EXCLUSIVE_AREA_0)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
/*! AR4.x SchM enter exclusive area adapter implementation */
# define Dcm_UtiArEnvEnterCriticalSection()                          SchM_Enter_Dcm_DCM_EXCLUSIVE_AREA_0()                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! AR4.x SchM leave exclusive area adapter implementation */
# define Dcm_UtiArEnvLeaveCriticalSection()                          SchM_Exit_Dcm_DCM_EXCLUSIVE_AREA_0()                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! AR4.x NvM_GetErrorStatus() API adapter implementation */
# define Dcm_UtiArEnvNvMGetErrorStatus(blockId, nvmStatus)           (NvM_GetErrorStatus((blockId),(nvmStatus)))                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/*! Returns modules initialization state for internal optimized invocations */
#define Dcm_DebugOptIsModuleInitialized()                            (Dcm_DebugInitState == DCM_DEBUG_INITSTATE_INIT)                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Puts DCM into uninitialized state (isolate from the rest of the world) */
#define Dcm_DebugDeInit()                                            (Dcm_DebugInitState = DCM_DEBUG_INITSTATE_UNINIT)                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Memory initialization hook for the debugging sub-component */
#define Dcm_DebugInitMemory()                                        (Dcm_DebugDeInit())                                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Initialization hook for the debugging sub-component */
#define Dcm_DebugInit()                                              (Dcm_DebugInitState = DCM_DEBUG_INITSTATE_INIT)                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Protection against parallel request from another communication channel */
#if(DCM_NET_MULTI_CHANNEL_ENABLED == STD_ON)
# define Dcm_NetMultiChannelEnterCS()                                Dcm_UtiArEnvEnterCriticalSection()                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetMultiChannelLeaveCS()                                Dcm_UtiArEnvLeaveCriticalSection()                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetMultiChannelEnterCS()                                /* not used */
# define Dcm_NetMultiChannelLeaveCS()                                /* not used */
#endif

/*! USDT buffer management */
#define Dcm_NetBufferIsFree(pBufferContext)                          ((pBufferContext)->IsInUseCnt == 0u)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetBufferLock(pBufferContext)                            ((pBufferContext)->IsInUseCnt=1u)                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetBufferRelease(pBufferContext)                         ((pBufferContext)->IsInUseCnt--)                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetBufferUsageEnter(pBufferContext)                      ((pBufferContext)->IsInUseCnt++)                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetBufferUsageLeave(pBufferContext)                      (Dcm_NetBufferRelease(pBufferContext))                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dcm_NetGetConnIdOfRxPduId(rxPduId)                           (Dcm_NetCfgGetConnIdOfRxPduId(DCM_VARMGR_ACTIVE_COMVAR, (rxPduId)))             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetConnIdOfTxPduId(txPduId)                           (Dcm_PbCfgNetTxPdu2ConnMap[(txPduId)])                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
# define Dcm_NetGetProtIdOfActiveProtocol()                          (Dcm_SingletonContext.Network.ActiveProtocol)                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetGetProtIdOfConnection(connId)                        (Dcm_PbCfgNetConnectionInfo[(connId)].ProtRef)                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetGetProtIdOfTranspObj(pTranspObj)                     (Dcm_NetGetProtIdOfConnection((pTranspObj)->ConnId))                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetGetProtIdOfActiveProtocol()                          0u                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetGetProtIdOfConnection(connId)                        0u                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetGetProtIdOfTranspObj(pTranspObj)                     0u                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#define Dcm_NetGetProtObjOfProtId(protId)                            (&Dcm_PbCfgNetProtocolInfo[(protId)])                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetProtObjOfConnection(connId)                        (Dcm_NetGetProtObjOfProtId(Dcm_NetGetProtIdOfConnection(connId)))               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetProtObjOfTranspObj(pTranspObj)                     (Dcm_NetGetProtObjOfConnection((pTranspObj)->ConnId))                           /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
# if (DCM_NET_PERIODIC_TX_CONN_SPECIFIC_NUM_TX_OBJ_ENABLED == STD_ON)
#  define Dcm_NetPeriodicMsgGetTxPduIdByConn(connId, txObjIdx)       (Dcm_PbCfgNetPerTxPduIdInfo[Dcm_PbCfgNetConnectionInfo[(connId)].PeriodicTxRef + (txObjIdx)]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgGetNumMsgsFor(connId)                    (Dcm_PbCfgNetConnectionInfo[(connId)].NumPeriodicTxPduIds)                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_NetPeriodicMsgGetTxPduIdByConn(connId, txObjIdx)       (Dcm_PbCfgNetPerTxPduIdInfo[((connId) * Dcm_PbCfgNetNumPerTxObjects) + (txObjIdx)]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgGetNumMsgsFor(connId)                    ((Dcm_CfgNetPTxObjHandleMemType)Dcm_PbCfgNetNumPerTxObjects)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# define Dcm_NetPeriodicMsgGetTxPduIdCurrConn(txObjIdx)              (Dcm_NetPeriodicMsgGetTxPduIdByConn(Dcm_NetPeriodicMsgGetConnection(),(txObjIdx))) /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_NetPeriodicMsgSetConnection(connId)                     (Dcm_SingletonContext.Network.PeriodicTxContext.ConnIdInUse = (connId))         /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPeriodicMsgGetConnection()                           (Dcm_SingletonContext.Network.PeriodicTxContext.ConnIdInUse)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPeriodicMsgSupportedFor(connId)                      (Dcm_NetPeriodicMsgGetNumMsgsFor(connId) != 0)                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_NetPeriodicMsgGetTxBuffer(txObjHandle)                  (Dcm_PbRamNetPeriodicTxObject[(txObjHandle)].TxBuffer)                          /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_NetPeriodicMsgNumMsgsCurrConnection()                   (Dcm_NetPeriodicMsgGetNumMsgsFor(Dcm_NetPeriodicMsgGetConnection()))            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId)             ((Dcm_CfgNetPTxObjHandleOptType)(Dcm_PbCfgNetPerTxPdu2RsrsMap[txPduId]))        /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_NetPeriodicMsgGetNextMsgHdl()                           (Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl)                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPeriodicMsgResetNextMsgHdl()                         (Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl = 0u)           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPeriodicMsgIncNextMsgHdl()                           (++Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl)              /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_NetPeriodicMsgGetTxObjectSentCntr()                     (Dcm_SingletonContext.Network.PeriodicTxContext.TxObjectSentCntr)               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPeriodicMsgResetTxObjectSentCntr()                   (Dcm_SingletonContext.Network.PeriodicTxContext.TxObjectSentCntr = 0u)          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPeriodicMsgIncTxObjectSentCntr()                     (++Dcm_SingletonContext.Network.PeriodicTxContext.TxObjectSentCntr)             /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
#  define Dcm_NetPeriodicMsgGetDelayCntr()                           (Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr)                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgIncDelayCntr()                           (++Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgDecDelayCntr()                           (--Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgInitDelayCntr()                          (Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr = DCM_NET_DELAY_BULK_TRANSMISSION) /* PRQA S 3453 */ /* MD_MSR_19.7 */

#  define Dcm_NetPeriodicMsgResetNextDelayTimer()                    (Dcm_SingletonContext.Network.PeriodicTxContext.NextDelayTimer = 0)             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgGetNextDelayTimer()                      (Dcm_SingletonContext.Network.PeriodicTxContext.NextDelayTimer)                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgIncNextDelayTimer()                      {++Dcm_SingletonContext.Network.PeriodicTxContext.NextDelayTimer; if (Dcm_NetPeriodicMsgGetNextDelayTimer() >= DCM_NET_DELAY_BULK_TRANSMISSION) { Dcm_NetPeriodicMsgResetNextDelayTimer(); } } /* PRQA S 3453, 3458 */ /* MD_MSR_19.4, MD_MSR_19.7 */

#  define Dcm_NetPeriodicMsgGetFastestRate()                         (Dcm_SingletonContext.Network.PeriodicTxContext.FastestRate)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgInitFastestRate()                        (Dcm_SingletonContext.Network.PeriodicTxContext.FastestRate = 0)                /* PRQA S 3453 */ /* MD_MSR_19.7 */

#  define Dcm_NetGetPeriodicDelayTime(Rate)                          (Dcm_CfgNetPeriodicDelayTime[Rate])                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */

#  define Dcm_NetDelayTimerGet(Timer)                                (Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[(Timer)])            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetDelayTimerSet(Timer, value)                         (Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[(Timer)] = (Dcm_TmrTimerCntrMemType)(value)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetDelayTimerDec(Timer)                                (--Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[(Timer)])          /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetDelayTimerExpired(Timer)                            (Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[(Timer)] == 0u)      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_NetPeriodicMsgGetDelayCntr()                           0u
#  define Dcm_NetPeriodicMsgIncDelayCntr()                           /* not used */
#  define Dcm_NetPeriodicMsgDecDelayCntr()                           /* not used */
#  define Dcm_NetPeriodicMsgInitDelayCntr()                          /* not used */

#  define Dcm_NetPeriodicMsgGetFastestRate()                         0u
#  define Dcm_NetPeriodicMsgInitFastestRate()                        /* not used */

#  define Dcm_NetGetPeriodicDelayTime(Rate)                          0u
# endif

# define Dcm_NetPTxObjTimerStart(perTxObjHandle, value)              {if(Dcm_TmrGetTimer(DCM_TMR_ID_PERIODIC_TX) == 0){Dcm_TmrStartTimer(DCM_TMR_ID_PERIODIC_TX, 1u);}Dcm_SplitTaskEnterCS(); Dcm_PbRamNetPeriodicTxObject[(perTxObjHandle)].Timer = (Dcm_TmrTimerCntrMemType)(value); Dcm_SplitTaskLeaveCS();  } /* PRQA S 3109, 3412, 3453, 3458 */ /* MD_MSR_14.3, MD_MSR_19.4, MD_MSR_19.7 */
# define Dcm_NetPTxObjTimerStop(perTxObjHandle)                      {Dcm_SplitTaskEnterCS(); Dcm_PbRamNetPeriodicTxObject[(perTxObjHandle)].Timer = 0u; Dcm_SplitTaskLeaveCS();  } /* PRQA S 3109, 3412, 3453, 3458 */ /* MD_MSR_14.3, MD_MSR_19.4, MD_MSR_19.7 */
# define Dcm_NetPTxObjTimerExpired(perTxObjHandle)                   (Dcm_PbRamNetPeriodicTxObject[(perTxObjHandle)].Timer == 0u)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPTxObjTimerDec(perTxObjHandle)                       (--Dcm_PbRamNetPeriodicTxObject[(perTxObjHandle)].Timer)                        /* PRQA S 3453 */ /* MD_MSR_19.7 */

#endif /* (DCM_NET_PERIODIC_TX_ENABLED == STD_ON) */

#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
# define Dcm_NetGetSessionConnection()                               (Dcm_SingletonContext.Network.SessionConnection)                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetSetSessionConnection(connId)                         (Dcm_SingletonContext.Network.SessionConnection = (connId))                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetGetSessionConnection()                               /* not used */
# define Dcm_NetSetSessionConnection(connId)                         /* not used */
#endif

#define Dcm_NetGetComStateByConnection(connId)                       (Dcm_NetGetComStateByChannelId(Dcm_PbCfgNetConnectionInfo[(connId)].NetworkIdRef)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetComStateByRxPduId(rxPduId)                         (Dcm_NetGetComStateByConnection(Dcm_NetGetConnIdOfRxPduId(rxPduId)))            /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dcm_NetGetComStateByTranspObject(pTranspObj)                 (Dcm_NetGetComStateByConnection((pTranspObj)->ConnId))                          /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DCM_NET_CONN_PROPERTIES_ENABLED == STD_ON)
# define Dcm_NetGetProperties(pTranspObj)                            (Dcm_PbCfgNetConnectionInfo[(pTranspObj)->ConnId].Properties)                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetIsPropertieSet(pTranspObj, prop)                     (Dcm_UtiBitOpTest(Dcm_CfgNetConnPropertiesType, Dcm_NetGetProperties(pTranspObj), (prop))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetGetProperties(pTranspObj)                            /* not used */
# define Dcm_NetIsPropertieSet(pTranspObj, prop)                     /* not used */
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/*! AR 3.x ComM Active Diagnostics notification */
# define Dcm_NetArEnvComMActiveDiag(channel)                         (ComM_DCM_ActiveDiagnostic())                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! AR 3.x ComM Inactive Diagnostics notification */
# define Dcm_NetArEnvComMInactiveDiag(channel)                       (ComM_DCM_InactiveDiagnostic())                                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! AR 3.x PduR API adaption */
# define Dcm_NetArEnvPduRCancelReceive(rxPduId)                      (PduR_DcmCancelReceive((rxPduId)))                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetArEnvPduRCancelTransmit(txPduId)                     (PduR_DcmCancelTransmit((txPduId)))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetArEnvGetTransmResult(notifResult)                    ((Dcm_NetTransmissionResultType)(((notifResult) == DCM_NET_ARENV_NTFRSLT_OK)?DCM_E_OK:DCM_E_NOT_OK)) /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_NetGetComStateByChannelId(channelId)                    (Dcm_PbRamNetComMContext[0].ComState)                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
/*! AR 4.x ComM Active Diagnostics notification */
# define Dcm_NetArEnvComMActiveDiag(channel)                         (ComM_DCM_ActiveDiagnostic((channel)))                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! AR 4.x ComM Inactive Diagnostics notification */
# define Dcm_NetArEnvComMInactiveDiag(channel)                       (ComM_DCM_InactiveDiagnostic((channel)))                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_PDUR_API_401_ENABLED == STD_ON)
/*! AR 4.0.1 PduR API adaption */
#  define Dcm_NetArEnvGetTransmResult(notifResult)                   ((Dcm_NetTransmissionResultType)(((notifResult) == DCM_NET_ARENV_NTFRSLT_OK)?DCM_E_OK:DCM_E_NOT_OK)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelReceive(rxPduId)                     (PduR_DcmCancelReceiveRequest((rxPduId)))                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelTransmit(txPduId)                    (PduR_DcmCancelTransmitRequest((txPduId)))                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# elif (DCM_PDUR_API_403_ENABLED == STD_ON)
/*! AR 4.0.3 PduR API adaption */
#  define Dcm_NetArEnvGetTransmResult(notifResult)                   ((Dcm_NetTransmissionResultType)(((notifResult) == DCM_NET_ARENV_NTFRSLT_OK)?DCM_E_OK:DCM_E_NOT_OK)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelReceive(rxPduId)                     (PduR_DcmCancelReceive((rxPduId)))                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelTransmit(txPduId)                    (PduR_DcmCancelTransmit((txPduId)))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# elif (DCM_PDUR_API_412_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
/*! AR 4.1.2+ PduR API adaption */
#  define Dcm_NetArEnvGetTransmResult(notifResult)                   (notifResult)                                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelReceive(rxPduId)                     (PduR_DcmCancelReceive((rxPduId)))                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelTransmit(txPduId)                    (PduR_DcmCancelTransmit((txPduId)))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  error "Unsupported PduR version!"
# endif

# define Dcm_NetGetComStateByChannelId(channelId)                    (Dcm_PbRamNetComMContext[(channelId)].ComState)                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
# define Dcm_RepeaterSetUser(repUser)                                (Dcm_InstanceContext.Repeater.Contexts.User = (repUser))                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_RepeaterSetUser(repUser)                                /* not used */
#endif

#define Dcm_RepeaterResetOpStatus()                                  (Dcm_InstanceContext.Repeater.Contexts.OpStatus = DCM_INITIAL)

#define Dcm_RepeaterGetProgress()                                    (Dcm_InstanceContext.Repeater.Contexts.Progress)
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
/*! Configuration dependent getter/setter access to the communication control state */
# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
#  define Dcm_ModeGetCommControlState(networkRef)                    (Dcm_PbRamNetComCtrlChannels[(networkRef)])                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_ModeSetCommControlState(networkRef, mode)              (Dcm_NetSetComControlChannelState((networkRef), (mode)))                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_ModeGetCommControlState(networkRef)                    /* not used */
#  define Dcm_ModeSetCommControlState(networkRef, mode)              /* not used */
# endif

/*! Configuration dependent getter/setter access to the DTC setting state */
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
#  define Dcm_ModeGetControlDtcSettingMode()                         (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.Mode)                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_ModeSetControlDtcSettingMode(newMode)                  (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.Mode = (newMode))                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_ModeGetControlDtcSettingMode()                         /* not used */
#  define Dcm_ModeSetControlDtcSettingMode(newMode)                  /* not used */
# endif

/*! Configuration dependent getter/setter access to the DTC group associated to the already set DTC setting's state */
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON) && \
     (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
#  define Dcm_ModeGetControlDtcSettingGroup()                        (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.DTCGroup)                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_ModeSetControlDtcSettingGroup(newGroup)                (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.DTCGroup = (newGroup))             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_ModeGetControlDtcSettingGroup()                        /* not used */
#  define Dcm_ModeSetControlDtcSettingGroup(newGroup)                /* not used */
# endif
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/*! AR 3.x BswM ComunicationControl related notification adapter */
# define Dcm_ModeArEnvBswMComControlModeChange(network, newMode)     (BswM_Dcm_RequestCommunicationMode((network), (newMode)))                       /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! AR 3.x EcuReset related notification adapters */
# define Dcm_ModeMgrArEnvSwitchReqEcuReset(newMode)                  (Dcm_ModeSwitchEcuReset(newMode))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ModeMgrArEnvSwitchAckEcuReset()                         (Dcm_ModeSwitchAckEcuReset())                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_ModeMgrArEnvSwitchReqRapidPowerShutDown(newMode)        (Dcm_ModeSwitchEcuReset(newMode))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ModeMgrArEnvSwitchAckRapidPowerShutDown()               (Dcm_ModeSwitchAckEcuReset())                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
/*! AR 4.x BswM ComunicationControl related notification adapter */
# define Dcm_ModeArEnvBswMComControlModeChange(network, newMode)     (BswM_Dcm_CommunicationMode_CurrentState((network), (newMode)))                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! AR 4.x EcuReset related notification adapters */
# define Dcm_ModeMgrArEnvSwitchReqEcuReset(newMode)                  (Dcm_ModeSwitchEcuReset(newMode))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ModeMgrArEnvSwitchAckEcuReset()                         (Dcm_ModeSwitchAckEcuReset())                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ModeMgrArEnvSwitchReqRapidPowerShutDown(newMode)        (Dcm_ModeSwitchRapidShutDown(newMode))                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ModeMgrArEnvSwitchAckRapidPowerShutDown()               (Dcm_ModeSwitchAckRapidShutDown())                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/*! Set the new (not yet finally committed, but probably "will become active") diagnostic session */
#define Dcm_StateSetPendingSession(session)                          (Dcm_SingletonContext.StateMgr.PendingSession = (session))                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns the new (not yet finally committed, but probably "will become active") diagnostic session */
#define Dcm_StateGetPendingSession()                                 (Dcm_SingletonContext.StateMgr.PendingSession)                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Synchronizes both pending and committed (active) diagnostic session to have the same state (i.e. the pending session becomes the state of the last valid diagnostic session */
#define Dcm_StateSyncPendingSession()                                (Dcm_StateSetPendingSession(Dcm_SingletonContext.StateMgr.Preconditions.Session)) /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Returns the diagnostic state related pre-conditions of a diagnostic entity */
#define Dcm_StateGetPreconditionStates(precondPckgRef)               (Dcm_CfgStatePreconditions[(precondPckgRef)].States)                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns the currently active (committed) diagnostic session state */
#define Dcm_StateGetSession()                                        (Dcm_SingletonContext.StateMgr.Preconditions.Session)                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns the diagnostic session pre-condition(s) of a diagnostic entity */
#define Dcm_StateGetPreconditionSession(precondPckgRef)              (Dcm_StateGetPreconditionStates(precondPckgRef).Session)                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/*! Returns the currently active security access level related state */
# define Dcm_StateGetSecurity()                                      (Dcm_SingletonContext.StateMgr.Preconditions.Security)                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns the security access pre-condition(s) of a diagnostic entity */
# define Dcm_StateGetPreconditionSecurity(precondPckgRef)            (Dcm_StateGetPreconditionStates(precondPckgRef).Security)                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif
/*! Returns TRUE if current (committed) diagnostic session is the Default-Session. Otherwise returns FALSE */
#define Dcm_StateIsDefaultSessionActive()                            ((Dcm_StateGetSession() & DCM_STATE_VALUE_SESSION_INIT) != 0)                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns TRUE if the diagnostic session precondition of a diagnostic entity is met */
#define Dcm_StateIsSupportedInSession(preconditionPackage)           ((Dcm_StateGetSession() & (preconditionPackage).Session) != 0)                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns the diagnostic session ID of the diagnostic session state */
#define Dcm_StateGetSessionValue(stateIdx)                           (Dcm_CfgStateSessionInfo[stateIdx].Value)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/*! Returns TRUE if current security level is the Locked-Level. Otherwise returns FALSE */
# define Dcm_StateIsSecurityLocked()                                 ((Dcm_StateGetSecurity() & DCM_STATE_VALUE_SECURITY_INIT) != 0)                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns TRUE if the security access pre-condition of a diagnostic entity is met */
# define Dcm_StateIsSupportedInSecurityLevel(preconditionPackage)    ((Dcm_StateGetSecurity() & (preconditionPackage).Security) != 0)                /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Returns the security access level ID of the security access state */
# define Dcm_StateGetSecurityValue(stateIdx)                         ((Dcm_SecLevelType)(((stateIdx) == 0)?0u:Dcm_CfgStateSecurityInfo[(stateIdx)-1u].Value)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#if (DCM_STATE_MULTIPLE_SECURITYFIXEDBYTES_ENABLED == STD_ON)                                                                                        /* COV_DCM_UNSUPPORTED XF */
# define Dcm_StateGetVsgMaskInfoIdx(stateIdx)                        (Dcm_CfgStateVsgSecurityFixedByteInfo[(stateIdx)])                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_StateGetNumberOfVsgs(stateIdx)                          ((Dcm_VsgSizeType)(Dcm_CfgStateVsgSecurityFixedByteInfo[(stateIdx) + 1] - Dcm_CfgStateVsgSecurityFixedByteInfo[(stateIdx) + 0])) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_StateGetVsgMaskInfoIdx(stateIdx)                        (stateIdx)                                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_StateGetNumberOfVsgs(stateIdx)                          (((Dcm_CfgStateSecurityFixedByteInfo[(stateIdx) + 1] - Dcm_CfgStateSecurityFixedByteInfo[(stateIdx) + 0]) > 0)?1u:0u) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif
/*! Returns the current events of a specific task */
#define Dcm_TskGetEvent(taskId)                                      (Dcm_SingletonContext.TaskMgr.TaskContext[(taskId)].TaskEvents)                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Task runtime flag management abstraction */
#if (DCM_TSK_TASK_FLAG_SUPPORT_ENABLED == STD_ON)
# define Dcm_TskIsFlagSet(pTaskContext, flg)                         (Dcm_UtiBitOpTest(Dcm_TskTaskFlagType, (pTaskContext)->TaskFlags, (flg)))       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskSetFlag(pTaskContext, flg)                           (Dcm_UtiBitOpSet(Dcm_TskTaskFlagType, (pTaskContext)->TaskFlags, (flg)))        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskClrFlag(pTaskContext, flg)                           (Dcm_UtiBitOpClr(Dcm_TskTaskFlagType, (pTaskContext)->TaskFlags, (flg)))        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_TskIsFlagSet(pTaskContext)                              FALSE /* not used */
# define Dcm_TskSetFlag(pTaskContext, flg)                           /* not used */
# define Dcm_TskClrFlag(pTaskContext, flg)                           /* not used */
#endif

/*! Task activation tracing utilities. Used to detect whether a function call (API) is performed while any or a specific task is (not) running */
#if (DCM_TSK_TRACING_ENABLED == STD_ON)
# define Dcm_TskTraceInit()                                          (Dcm_UtiStackInit(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskTraceTskPush(taskId)                                 (Dcm_UtiStackPush(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack, (Dcm_TskMgrTraceStackBaseType)(taskId))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskTraceTskPop()                                        (Dcm_UtiStackPop(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskTraceIsFull()                                        (Dcm_UtiStackIsFull(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack, Dcm_TskMgrTraceStackBaseType)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskTraceIsEmpty()                                       (Dcm_UtiStackIsEmpty(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))        /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Returns the ID of the task currently executed */
# define Dcm_TskTraceGetCurrTskId()                                  (Dcm_UtiStackTop(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_TskTraceInit()                                          /* not used */
# define Dcm_TskTraceTskPush(taskId)                                 /* not used */
# define Dcm_TskTraceTskPop()                                        /* not used */
# define Dcm_TskTraceIsFull()                                        /* not used */
# define Dcm_TskTraceIsEmpty()                                       /* not used */

# define Dcm_TskTraceGetCurrTskId()                                  /* not used */
#endif
/*! Gets the value of a timer of the given timerId */
#define Dcm_TmrGetTimer(timerId)                                     (Dcm_SingletonContext.TimerMgr.Timer[(timerId)])                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define Dcm_DidMgrIsOpSupported(pDidInfo,   op)                     (((op) & (pDidInfo)->Operations) != 0)                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_DidMgrIsOpTypeSupported(pDidOpInfo, opType)             (((opType) & (pDidOpInfo)->CallTypes) != 0)                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_DIDMGR_DYNDID_DEEP_CHECK_ON_READ_ENABLED == STD_ON)
/* a real function is used for optimal code size */
# else
#  define Dcm_DidMgrDynDidStateCheck(pDidInfoContext, pErroCode)     (Dcm_DidMgrStaticDidStateCheck((pDidInfoContext)->Descriptor.DidOpInfoPtr->ExecCondRef, (pErroCode))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# define Dcm_DidMgrStaticDidStateCheck(ExecCondRef, pErroCode)       (Dcm_StateCheck((ExecCondRef), DCM_DIAG_CHK_LVL_PARAMETER, (pErroCode)))        /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_DIDMGR_OP_INFO_COMBINED_ENABLED == STD_ON)
#  define Dcm_DidMgrOpInfoRedirector(opRef, opRefType)               (Dcm_CfgDidMgrOpInfoCombined[(opRef)].opRefType)                                /* PRQA S 3453, 3410 */ /* MD_MSR_19.7, MD_Dcm_AbstractTokenReplacement_3410 */
# else
#  define Dcm_DidMgrOpInfoRedirector(opRef, opRefType)               (opRef)                                                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# if (DCM_DIDMGR_IO_MASKRECORD_ENABLED == STD_ON)
#  define Dcm_DidMgrGetCtrlEnblMaskLength(pDidInfo)                  (Dcm_CfgDidMgrOpInfoIoControl[Dcm_DidMgrOpInfoRedirector((pDidInfo)->OpRef, OpRefIoControl)].CtrlEnblMaskLength) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_DidMgrGetCtrlEnblMaskLength(pDidInfo)                  0u                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# define Dcm_DidMgrGetCtrlOpInfoRef(opRef)                           (Dcm_CfgDidMgrOpInfoIoControl[Dcm_DidMgrOpInfoRedirector(opRef, OpRefIoControl)].RetCtrlToEcuOpRef) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_DidMgrGetCtrlOpExecCondRef(opRef)                       (Dcm_CfgDidMgrOpInfoIoControl[Dcm_DidMgrOpInfoRedirector(opRef, OpRefIoControl)].CtrlExecCondRef) /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_DIDMGR_OP_INFO_SCALING_ENABLED == STD_ON)
#  define Dcm_DidMgrGetScalingLayoutRef(pDidInfo)                    (Dcm_CfgDidMgrOpInfoScaling[Dcm_DidMgrOpInfoRedirector((pDidInfo)->OpRef, OpRefScaling)].ScalingInfoRef) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_DidMgrGetSignalScalingSize(pDidInfo)                   (Dcm_CfgDidMgrSignalScalingInfo[Dcm_DidMgrGetScalingLayoutRef(pDidInfo)])       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# if (DCM_DIDMGR_DYNDID_VAR_NUM_ITEMS_ENABLED == STD_ON)
#  define Dcm_DidMgrGetDynDidSize(dynDidHandle)                      (Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].NumItems)                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle)           (Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].SrcItemRef)                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_DidMgrGetDynDidSize(dynDidHandle)                      ((uint8)DCM_NUM_ITEMS_PER_DYNDID)                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle)           ((Dcm_CfgDidMgrDynDidSrcItemIdxMemType)((Dcm_CfgDidMgrDynDidSrcItemIdxMemType)(dynDidHandle)) * ((uint8)DCM_NUM_ITEMS_PER_DYNDID)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
# if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
#  define Dcm_DidMgrGetDynDidReadExecPrecond(dynDidHandle)           (Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].ReadExecCondRef)                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
#  define Dcm_DidMgrGetDynDidIdFromHandle(dynDidHandle)              ((Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].Did))                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
#  define Dcm_DidMgrGetOpClassRef(opInfoRef)                         (Dcm_CfgDidMgrDidOpClassInfo[(opInfoRef)].OpClassRef)                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_DidMgrGetOpClassRef(opInfoRef)                         (opInfoRef)                                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define Dcm_RidMgrConvOpOfSubFunc(sf)                               ((Dcm_RidMgrOpType)(((sf) < 4)?Dcm_RidMgrSubFunc2OpMap[(sf)]:0u))               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_RidMgrStateCheckRid(execCondRef, pErroCode)             (Dcm_StateCheck((execCondRef), DCM_DIAG_CHK_LVL_PARAMETER, (pErroCode)))        /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_CfgRidMgrRidInfoOpBaseIdx(idx)                          (Dcm_CfgRidMgrRidInfo[(idx)].OpBaseIdx)                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_CfgRidMgrRidInfoExecCondRef(idx)                        (Dcm_CfgRidMgrRidInfo[(idx)].ExecCondRef)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_CfgRidMgrRidInfoOperations(idx)                         (Dcm_CfgRidMgrRidInfo[(idx)].Operations)                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_CfgRidMgrRidInfoRoutineInfoByte(idx)                    (Dcm_CfgRidMgrRidInfo[(idx)].RoutineInfoByte)                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_CfgRidMgrOpInfoOpFunc(idx)                              (Dcm_CfgRidMgrOpInfo[(idx)].OpFunc)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_CfgRidMgrOpInfoReqMaxLength(idx)                        (Dcm_CfgRidMgrOpInfo[(idx)].ReqMaxLength)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_CfgRidMgrOpInfoReqMinLength(idx)                        (Dcm_CfgRidMgrOpInfo[(idx)].ReqMinLength)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_CfgRidMgrOpInfoResMinLength(idx)                        (Dcm_CfgRidMgrOpInfo[(idx)].ResMinLength)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_CfgRidMgrOpInfoOpType(idx)                              (Dcm_CfgRidMgrOpInfo[(idx)].OpType)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
/*! Splittask related critical section management */
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
# define Dcm_SplitTaskEnterCS()                                      Dcm_UtiArEnvEnterCriticalSection()                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_SplitTaskLeaveCS()                                      Dcm_UtiArEnvLeaveCriticalSection()                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_SplitTaskEnterCS()                                      /* Not used */
# define Dcm_SplitTaskLeaveCS()                                      /* Not used */
#endif
/*! Getter/Setter of the transport object carrying the diagnostic request currently in processing */
#define Dcm_DiagGetTranspObj()                                       (Dcm_NetGetTransportObject(Dcm_InstanceContext.Diag.TObjHdl))                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_DiagSetTranspObj(tObjPtr)                                (Dcm_InstanceContext.Diag.TObjHdl = (tObjPtr)->Handle)                          /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! Abstract interface of getter of the transport object carrying the diagnostic request to be processed at next Dcm_DiagTaskWorker() activation */
#if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON)
/*! Get/Set the queued transport object */
# define Dcm_DiagGetQueuedTranspObj()                                (Dcm_NetGetTransportObject(Dcm_InstanceContext.Diag.QueuedSet.TObjHdl))         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
/*! No queuing needed, do directly get the transport object in processing */
# define Dcm_DiagGetQueuedTranspObj()                                (Dcm_DiagGetTranspObj())                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif
/*! Abstract interface of the RCR-RP limiter counter management */
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
/*! Reset the RCR-RP limiter */
# define Dcm_DiagResetRcrRpLimiter()                                 (Dcm_InstanceContext.Diag.NumRcrRpTimeouts = DCM_DIAG_RCRRP_LIMIT_COUNT)        /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Get current RCR-RP limiter value */
# define Dcm_DiagGetRcrRpLimiter()                                   (Dcm_InstanceContext.Diag.NumRcrRpTimeouts)                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Decrement by one RCR-RP limiter value */
# define Dcm_DiagDecrementRcrRpLimiter()                             (--Dcm_InstanceContext.Diag.NumRcrRpTimeouts)                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_DiagResetRcrRpLimiter()                                 /* not used */
# define Dcm_DiagGetRcrRpLimiter()                                   /* not used */
# define Dcm_DiagDecrementRcrRpLimiter()                             /* not used */
#endif
/*! Variant bitmap access */
#define Dcm_VarMgrBitSetCalcSize(bits)                               (Dcm_UtiBitSetCalcSize(Dcm_CfgVarMgrBitSetBaseType, (bits)))                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_VarMgrBitSetTestBit(bitSet, bit)                         (Dcm_UtiBitSetTestBit(Dcm_CfgVarMgrBitSetBaseType, (bitSet), (bit)))            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_VarMgrBitSetSetBit(bitSet, bit)                          (Dcm_UtiBitSetSetBit(Dcm_CfgVarMgrBitSetBaseType, (bitSet), (bit)))             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_VarMgrBitSetClrBit(bitSet, bit)                          (Dcm_UtiBitSetClrBit(Dcm_CfgVarMgrBitSetBaseType, (bitSet), (bit)))             /* PRQA S 3453 */ /* MD_MSR_19.7 */

/*! EcuM notification for run-time variant initialization errors */
#if(DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# define Dcm_EcuMErrorNotification(errorCode)                        (EcuM_BswErrorHook((uint16) DCM_MODULE_ID, (uint8) (errorCode)))                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_EcuMErrorNotification(errorCode)                        /* not used */
#endif
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/*! Per default - all patching hooks of DTC status masks are not required */
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusInit)                                                                                                     /* COV_DCM_UNSUPPORTED TX */
#  define Dcm_ExtSvc19UtiPatchDtcStatusInit()                        /* not used */
# endif
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest)                                                                                           /* COV_DCM_UNSUPPORTED TX */
#  define Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(dtcStatusPtr)  /* not used */
# endif
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusApplyByResult)                                                                                            /* COV_DCM_UNSUPPORTED TX */
#  define Dcm_ExtSvc19UtiPatchDtcStatusApplyByResult(dtcStatusPtr)   /* not used */
# endif
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusSetForApply)                                                                                              /* COV_DCM_UNSUPPORTED TX */
#  define Dcm_ExtSvc19UtiPatchDtcStatusSetForApply()                 /* not used */
# endif
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter)                                                                                             /* COV_DCM_UNSUPPORTED TX */
#  define Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter(dtcStatusMaskPtr) /* not used */
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc27OnStateChanged()                                   (Dcm_Svc27ResetSequence())                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27ResetSequence()                                    (Dcm_InstanceContext.Diag.Services.Svc27.SeedLevel = DCM_SVC_27_SEED_LVL_INVALID) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27IsKeyRequestExpected()                             (Dcm_InstanceContext.Diag.Services.Svc27.SeedLevel != DCM_SVC_27_SEED_LVL_INVALID) /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_Svc27GetSecLvlRef(subSvcRef)                            ((uint8)((subSvcRef) / 2u))                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27IsKeyRequest(subSvcRef)                            (((subSvcRef) & 0x01u) != 0u) /* Odd subSvcRef means "send key" request */      /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_SVC_27_MULTI_ATTEMPT_COUNTER_ENABLED == STD_ON)
#  define Dcm_Svc27GetCounterIdx(secLvl)                             (secLvl)                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_Svc27GetCounterIdx(secLvl)                             0u
# endif

# if (DCM_SVC_27_MULTI_DELAY_TIMER_ENABLED == STD_ON)
#  define Dcm_Svc27GetTimerIdx(secLvl)                               (secLvl)                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_Svc27GetTimerIdx(secLvl)                               0u
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
#  if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
#   define Dcm_Svc27ReloadReadFailedGet(secLev)                      (Dcm_UtiBitOpTest(uint32, Dcm_InstanceContext.Diag.Services.Svc27.ReloadMask, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, (secLev)))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#   define Dcm_Svc27ReloadReadFailedSet(secLev)                      (Dcm_UtiBitOpSet(uint32, Dcm_InstanceContext.Diag.Services.Svc27.ReloadMask, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, (secLev)))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  else
#   define Dcm_Svc27ReloadReadFailedGet(secLev)                      /* not used */
#   define Dcm_Svc27ReloadReadFailedSet(secLev)                      /* not used */
#  endif
#  define Dcm_Svc27CounterGet(secLev)                                (Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[Dcm_Svc27GetCounterIdx((secLev))]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc27CounterReset(secLev)                              (Dcm_Svc27CounterSet((secLev), 0u))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc27TimerGet(secLev)                                  (Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[Dcm_Svc27GetTimerIdx((secLev))]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc27TimerReset(secLev)                                (Dcm_Svc27TimerSet((secLev), 0u))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc27TimerStart(secLev)                                {if(Dcm_TmrGetTimer(DCM_TMR_ID_SECURITY_0) == 0){Dcm_TmrStartTimer(DCM_TMR_ID_SECURITY_0, 1u);} } /* PRQA S 3453, 3458 */ /* MD_MSR_19.4, MD_MSR_19.7 */
#  define Dcm_Svc27TimerExpired(secLev)                              ((boolean)(Dcm_Svc27TimerGet((secLev)) == 0u))                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc27TimerJustExpired(mask, secLev)                    ((boolean)(Dcm_UtiBitOpTest(uint32, (mask), Dcm_UtiGetBitFromIndex(uint32_least, Dcm_Svc27GetTimerIdx((secLev)))))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc27TimerDec(secLev)                                  (Dcm_Svc27TimerSet((secLev), Dcm_Svc27TimerGet((secLev)) - 1u))                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_Svc27CounterGet(secLev)                                /* not used */
#  define Dcm_Svc27CounterReset(secLev)                              /* not used */
#  define Dcm_Svc27TimerGet(secLev)                                  /* not used */
#  define Dcm_Svc27TimerReset(secLev)                                /* not used */
#  define Dcm_Svc27TimerStart(secLev, time)                          /* not used */
#  define Dcm_Svc27TimerExpired(secLev)                              /* not used */
#  define Dcm_Svc27TimerJustExpired(mask, secLev)                    /* not used */
#  define Dcm_Svc27TimerDec(secLev)                                  /* not used */
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define Dcm_Svc2ASchdGetFreeSpace()                                 ((Dcm_Svc2ASchdItemHandleMemType)(DCM_SVC_2A_SCHEDULER_SIZE - Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2AGetSchedulingTimeOfEntry(pSchedTableEntry)         (Dcm_CfgSvc2ASchdRateTime[(pSchedTableEntry)->Rate & DCM_SVC2A_RATE_TYPE_MASK]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define Dcm_Svc2AIsPeriodicDid(did)                                 ((((uint16)(did)) & 0xFF00u) == 0xF200u)                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2AMakePeriodicDid(didLoByte)                         (Dcm_UtiMake16Bit((uint8)0xF2u, (didLoByte)))                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2AMakeSchdRateFromUdsRate(udsRate)                   (Dcm_Svc2ASchedRateMemType)((udsRate)-1u)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_2C_HYBRID_MODE_ENABLED == STD_ON)
#  define Dcm_Svc2CIsDidSrcItem(srcItemIdx)                          (Dcm_UtiGenericBitSetTestBit(Dcm_InstanceContext.Diag.Services.Svc2C.Sequencer,(srcItemIdx))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc2CSetDidSrcItem(srcItemIdx)                         (Dcm_UtiGenericBitSetSetBit(Dcm_InstanceContext.Diag.Services.Svc2C.Sequencer,(srcItemIdx))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc2CSetMemSrcItem(srcItemIdx)                         (Dcm_UtiGenericBitSetClrBit(Dcm_InstanceContext.Diag.Services.Svc2C.Sequencer,(srcItemIdx))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_Svc2CIsDidSrcItem(srcItemIdx)                          /* not used */
#  define Dcm_Svc2CSetDidSrcItem(srcItemIdx)                         /* not used */
#  define Dcm_Svc2CSetMemSrcItem(srcItemIdx)                         /* not used */
# endif

# define Dcm_Svc2CGetSrcItemIndex(dynDidHandle, offset)              ((Dcm_CfgDidMgrDynDidSrcItemIdxMemType)(Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle)  + (offset))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define Dcm_Svc2CIsDynDidDefined(dynDidHandle)                      (Dcm_InstanceContext.Diag.Services.Svc2C.Items[(dynDidHandle)].Count != 0u)     /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2CIsDidDefined(pDidInfo)                             ((!Dcm_DidMgrIsOpSupported(pDidInfo, DCM_DIDMGR_OP_DEFINE)) || Dcm_Svc2CIsDynDidDefined((pDidInfo)->OpRef)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2CGetMaxDynDidProtocolLen()                          ((Dcm_CfgNetBufferSizeMemType)(Dcm_NetGetBufferInfo(Dcm_DiagGetTranspObj()->BufferHdl)->Size - 3u)) /* for response: 0x62 DID_H DID_L <DATA> */ /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define Dcm_Svc2FIsDidActive(ioDidHdl)                              (Dcm_UtiGenericBitSetTestBit(Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids,(ioDidHdl))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2FSetDidActive(ioDidHdl)                             (Dcm_UtiGenericBitSetSetBit(Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids,(ioDidHdl))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2FClrDidActive(ioDidHdl)                             (Dcm_UtiGenericBitSetClrBit(Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids,(ioDidHdl))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
/* ----------------------------------------------
 ~&&&   Typedefs Exported Level 2
---------------------------------------------- */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef uint8 Dcm_MemMgrAccessType;
typedef uint8 Dcm_MemMgrMemoryOpType;

/*!< Shared memory block descriptor data type for other service processors (e.g. 0x2C) */
struct DCM_MEMMGRMEMBLOCKTYPE_TAG
{
  Dcm_CfgMemMgrReqAddrType  Address;  /*!< The address to access */
  Dcm_CfgMemMgrReqSizeType  Length;   /*!< The number of bytes requested */
# if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
  uint8                     Mid;      /*!< The memory identifier */
# endif
};
typedef struct DCM_MEMMGRMEMBLOCKTYPE_TAG Dcm_MemMgrMemBlockType;
typedef P2VAR(Dcm_MemMgrMemBlockType, TYPEDEF, DCM_VAR_NOINIT) Dcm_MemMgrMemBlockPtrType;
# if (DCM_MEMMGR_RAM_CONTEXT_ENABLED == STD_ON)
struct DCM_MEMMANAGERCONTEXTTYPE_TAG
{
#  if(DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_MemMgrAccessType  LockedByClient;
#  endif
};
typedef struct DCM_MEMMANAGERCONTEXTTYPE_TAG Dcm_MemManagerContextType;
# endif
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
typedef uint8 Dcm_ObdIdMgrParserFlagsType;

typedef union
{                                                                                                                                                    /* PRQA S 0750 */ /* MD_Dcm_Optimize_0750 */
  uint32                    MaskValue;
  Dcm_ObdIdMgrHandleMemType Handle;
}Dcm_ObdIdMgrListItemResultType;

struct DCM_OBDIDMGRLISTITEMTYPE_TAG
{
  Dcm_ObdIdMgrListItemResultType Result;
  uint8                          Id;
};
typedef struct DCM_OBDIDMGRLISTITEMTYPE_TAG Dcm_ObdIdMgrListItemType;

typedef P2VAR(Dcm_ObdIdMgrListItemType, AUTOMATIC, DCM_VAR_NOINIT)   Dcm_ObdIdMgrListItemPtrType;

typedef P2FUNC(sint16_least, DCM_CODE, Dcm_ObdIdMgrGetAvailabilityMaskFuncType) (uint8, Dcm_Uint32VarDataPtrType);

struct DCM_OBDIDMGRDESCTYPE_TAG
{
  Dcm_ObdIdMgrGetAvailabilityMaskFuncType                       GetMaskFunc;
  Dcm_ObdIdMgrListItemType                                      ParseResult[6]; /* OUT: The list of supported IDs to be processed later */
  uint8                                                         ParseCount;     /* OUT: actual parseResult size */
  Dcm_ObdIdMgrParserFlagsType                                   ParseFlags;     /* IN: single/multi ID, contains data */
  boolean                                                       IsAvailabilityId; /* OUT: specifies whether the request has availability IDs or DATA ID(s) */
};
typedef struct DCM_OBDIDMGRDESCTYPE_TAG Dcm_ObdIdMgrDescType;

typedef P2VAR(Dcm_ObdIdMgrDescType, AUTOMATIC, DCM_VAR_NOINIT)           Dcm_ObdIdMgrDescPtrType;
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
typedef P2CONST(Dcm_CfgNetBufferInfoType, TYPEDEF, DCM_CONST_PBCFG) Dcm_PbCfgNetBufferInfoPtrType;
typedef P2VAR(Dcm_CfgNetBufferSizeOptType, TYPEDEF, DCM_VAR_NOINIT) Dcm_CfgNetBufferSizePtrType;
typedef boolean Dcm_NetActiveDiagnosticType;

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/*! Periodic message transmitter control states */
struct DCM_NETPERIODICTXCONTEXTTYPE_TAG
{
  DCM_PB_RAM_DATA_DECL(Dcm_NetPeriodicTxObjectType, TxObject, DCM_NET_MAX_NUM_PERIODIC_TX_OBJ_CONST) /*!< Periodic message control objects */
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  DCM_VOLATILE_ON_SPLITTASK Dcm_TmrTimerCntrMemType DelayTimer[DCM_NET_DELAY_BULK_TRANSMISSION]; /*!< Array of delay timers that assure gap times between periodic DIDs */
  Dcm_CfgNetPTxObjHandleMemType    DelayCntr;        /*!< Number of remaining messages that can be dispatched before a delay is required */
  uint8                            NextDelayTimer;   /*!< Index of next delay timer to use */
  uint8                            FastestRate;      /*!< The fastest rate in which periodic DIDs are currently scheduled */
# endif
  Dcm_NetConnRefMemType            ConnIdInUse;      /*!< Current owner (diagnostic client) of the periodic transmitter */
  Dcm_CfgNetPTxObjHandleMemType    NextTxObjectHdl;  /*!< Pointer to the next periodic message to be sent. Scope is only the current periodic transmitter owners list of periodic messages */
  Dcm_CfgNetPTxObjHandleMemType    TxObjectSentCntr; /*!< Keeps track of the already sent periodic messages. Scope is only the current periodic transmitter owners list of periodic messages */
};
typedef struct DCM_NETPERIODICTXCONTEXTTYPE_TAG Dcm_NetPeriodicTxContextType;
#endif

typedef P2VAR(Dcm_NetTransportObjectType, TYPEDEF, DCM_VAR_NOINIT) Dcm_NetTransportObjectPtrType;
typedef P2VAR(Dcm_NetComMContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_NetComMContextPtrType;
typedef P2VAR(Dcm_NetBufferContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_NetBufferContextPtrType;

/*! Control states of the network sub-component */
struct DCM_NETCONTEXTTYPE_TAG
{
  DCM_PB_RAM_DATA_DECL(Dcm_NetBufferContextType, BufferContext, DCM_NET_NUM_BUFFERS_CONST)        /*!< Control states of the USDT message buffers (main and additional) */
  DCM_PB_RAM_DATA_DECL(Dcm_NetTransportObjectType, TransportObject, DCM_NET_MAX_NUM_TRANSP_OBJECTS_CONST) /*!< Transport objects for simultaneous servicing of multiple clients */
  DCM_PB_RAM_DATA_DECL(Dcm_NetComMContextType, ComMContext, DCM_NET_MAX_NUM_COMM_CHANNELS_CONST)  /*!< Control states of ComM status notifications per DCM related com-channel (i.e. channel on which DCM communicates with a client */
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
  Dcm_NetPeriodicTxContextType  PeriodicTxContext;                                                /*!< Composition relation to the periodic message transmitter */
#endif
  DCM_PB_RAM_DATA_DECL(Dcm_CfgNetTObjHandleMemType, ConnId2TObjIdMap, DCM_NET_MAX_NUM_CONNECTIONS_CONST)  /*!< A map of type <key = connectionId, value = TransportObject>. Used for fast transport object allocation */
#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  DCM_PB_RAM_DATA_DECL(Dcm_CommunicationModeType, ComCtrlChannels, DCM_NET_MAX_NUM_ALL_COMM_CHANNELS)     /*!< Communication state [Rx/Tx][On/Off] of each ComM channel known to DCM */
#endif
#if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
  Dcm_NetProtRefMemType         ActiveProtocol;       /*!< The protocol handle last activated */
#endif
  Dcm_NetConnRefMemType         NumActiveConnections; /*!< Current number of simultaneously serviced clients/connections */
#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  Dcm_NetConnRefMemType         SessionConnection;    /*!< Owner (client) of the non-default session last started */
#endif
  Dcm_NetActiveDiagnosticType   ActiveDiagnostic;     /*!< Guard for prevention of DCMs automatic ComM diag-activate signal notification (this state is managed by the application) */
#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
  boolean                       RxAllowed;            /*!< Guard for global blocking of any request reception */
#endif
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
  boolean                       KeepAlive;            /*!< Guard for prevention of diag-inactive notifications from DCM to ComM (e.g. in the default-session) */
#endif
};
typedef struct DCM_NETCONTEXTTYPE_TAG Dcm_NetContextType;
typedef uint8 Dcm_PagedBufferStateType;
typedef uint8 Dcm_PagedBufferDataProvisionStateType;

/*! Paged-buffer control data */
struct DCM_PAGEDBUFFERCONTEXTTYPE_TAG
{
  Dcm_MsgLenType                        RemainingLen;                 /*!< Keeps track on the data exchange progress */
  Dcm_CfgNetBufferSizeMemType           WriteIndex;                   /*!< Pointer to the next free buffer position ready to be written with new data portion */
  Dcm_CfgNetBufferSizeMemType           ReadIndex;                    /*!< Pointer to the next ready-to-send buffer position */
  Dcm_PagedBufferStateType              State;                        /*!< Paged-buffer state machine */
  Dcm_CfgNetBufferRefMemType            BufferHdl;                    /*!< Zero based reference to the USDT buffer object in use */
  uint8                                 UpdateFuncRef;                /*!< Zero based reference to the data provider handler Xxx_<Name>Update */
  uint8                                 CancelFuncRef;                /*!< Zero based reference to the data provider cancellation notification Xxx_<Name>Cancel */
  boolean                               UpdateFinished;               /*!< Data provider will no longer be called (job done) */
  Dcm_PagedBufferDataProvisionStateType UpdaterDataProvisionState;    /*!< Data provision state of Updater */
};
typedef struct DCM_PAGEDBUFFERCONTEXTTYPE_TAG Dcm_PagedBufferContextType;
typedef uint8 Dcm_RepeaterProgressType;
typedef uint8 Dcm_RepeaterUserType;
typedef P2CONST(Dcm_CfgDiagServiceInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgDiagServiceInfoPtrType;
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
/*! DTC setting control states */
struct DCM_MODECTRLDTCSETTINGCONTEXTTYPE_TAG
{
#  if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
  uint32                             DTCGroup;               /*!< The DTC group associated with the disabled DTC setting state */
#  endif
  Rte_ModeType_DcmControlDtcSetting  Mode;                   /*!< Current DTC setting state (ENABLEDTCSETTING, DISABLEDTCSETTING) */
  uint8                              LastDisableDTCClientID; /*!< ClientID that was last used to disable DTC setting */
};
typedef struct DCM_MODECTRLDTCSETTINGCONTEXTTYPE_TAG Dcm_ModeCtrlDtcSettingContextType;
# endif

/*! Control data of the mode manager sub-component */
struct DCM_MODECONTEXTTYPE_TAG
{
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  Dcm_ModeCtrlDtcSettingContextType CtrlDtcSetting; /*!< DTC setting mode management control data */
# else
  uint8 spare;                                      /*!< Reserved unused place for future extensions */
# endif
};
typedef struct DCM_MODECONTEXTTYPE_TAG Dcm_ModeContextType;
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
/*! Pointer to a execution precondition reference index located in the DCM ROM data */
typedef P2CONST(Dcm_CfgStateRefMemType, TYPEDEF, DCM_CONST)  Dcm_CfgStateRefMemPtrType;

/* Control data of the sub-component state manager */
struct DCM_STATECONTEXTTYPE_TAG
{
  Dcm_CfgStateDiagStateInfoType Preconditions;   /*!< Current (active) state of all diagnostic state related execution pre-conditions */
  Dcm_CfgStateGroupMemType      PendingSession;  /*!< Pending diagnostic session, still in transition, waiting for the diagnostic service processing confirmation */
};
typedef struct DCM_STATECONTEXTTYPE_TAG Dcm_StateContextType;
typedef uint8        Dcm_TskTaskPrioMemType;
typedef uint8_least  Dcm_TskTaskPrioOptType;

typedef uint8        Dcm_TskTaskAttributeType;
typedef uint8        Dcm_TskTaskFlagType;

typedef Dcm_TskTaskIdMemType  Dcm_TskMgrTraceStackBaseType;
/*! Stack with the running tasks (entry per task priority) */
typedef Dcm_UtiStackType(Dcm_TskMgrTraceStackBaseType, DCM_TSK_NUM_PRIOS) Dcm_TskMgrTraceStackType;

/*! Single task runtime data */
struct DCM_TSKTASKCONTEXTTYPE_TAG
{
  Dcm_TskTaskEvMemType    TaskEvents;  /*!< Task related events */
#if (DCM_TSK_TASK_FLAG_SUPPORT_ENABLED == STD_ON)
  Dcm_TskTaskFlagType     TaskFlags;   /*!< Runtime status */
#endif
};
typedef struct DCM_TSKTASKCONTEXTTYPE_TAG Dcm_TskTaskContextType;
typedef volatile P2VAR(Dcm_TskTaskContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_TskTaskContextPtrType;

/*! Task scheduler (one per task priority) control data */
struct DCM_TSKSCHEDULERCONTEXTTYPE_TAG
{
  boolean SchdIsActive;  /*!< Activity state of scheduler (TRUE - scheduler has at least one active task, FALSE - scheduler is suspended) */
};
typedef struct DCM_TSKSCHEDULERCONTEXTTYPE_TAG Dcm_TskSchedulerContextType;
typedef volatile P2VAR(Dcm_TskSchedulerContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_TskSchedulerContextPtrType;

/*! Control states of the task manager sub-component */
struct DCM_TSKCONTEXTTYPE_TAG
{
  volatile Dcm_TskTaskContextType      TaskContext[DCM_TSK_NUM_TASKS];    /*!< Runtime data of each available task (priority independent) */
  volatile Dcm_TskSchedulerContextType TaskScheduler[DCM_TSK_NUM_PRIOS];  /*!< Control data of each scheduler (one per priority) */
#if (DCM_TSK_TRACING_ENABLED == STD_ON)
  volatile Dcm_TskMgrTraceStackType    CurrentTaskPrioStack;              /*!< Active task ID stack for tracing purposes (e.g. check whether a low prio task is interrupted by another one and which one or just see which task is active at a time) */
#endif
};
typedef struct DCM_TSKCONTEXTTYPE_TAG Dcm_TskContextType;
/*! Control data of the timer sub-component */
struct DCM_TMRCONTEXTTYPE_TAG
{
  volatile Dcm_TmrTimerCntrMemType   Timer[DCM_TMR_NUM_TIMERS];  /*!< All configured system timers */
};
typedef struct DCM_TMRCONTEXTTYPE_TAG Dcm_TmrContextType;
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2CONST(Dcm_CfgDidMgrDidInfoType, TYPEDEF, DCM_CONST)            Dcm_DidMgrDidInfoPtrType;
typedef P2CONST(Dcm_CfgDidMgrOpInfoType, TYPEDEF, DCM_CONST)             Dcm_DidMgrOpInfoPtrType;
typedef P2CONST(Dcm_CfgDidMgrSignalOpClassInfoType, TYPEDEF, DCM_CONST)  Dcm_DidMgrSignalOpClassInfoPtrType;
# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
typedef P2CONST(Dcm_CfgDidMgrDidOpClassInfoType, TYPEDEF, DCM_CONST)     Dcm_DidMgrDidOpClassInfoPtrType;
typedef P2CONST(Dcm_CfgDidMgrSignalInfoType, TYPEDEF, DCM_CONST)         Dcm_DidMgrSignalInfoPtrType;
# endif

# if(DCM_DIDMGR_XX_ACCESS_LOCK_ENABLED == STD_ON)
struct DCM_DIDMGRDIDRSRCCONTEXTTYPE_TAG
{
#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
  uint16 ReadOnce;
#  endif
#  if (DCM_DIDMGR_2A_ACCESS_LOCK_ENABLED == STD_ON)
  uint16 ReadPeriodic;
#  endif
#  if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
  uint16 ReadDynamic;
#  endif
#  if (DCM_DIDMGR_2E_ACCESS_LOCK_ENABLED == STD_ON)
  uint16 Write;
#  endif
#  if (DCM_DIDMGR_2F_ACCESS_LOCK_ENABLED == STD_ON)
  uint16 Io;
#  endif
};
typedef struct DCM_DIDMGRDIDRSRCCONTEXTTYPE_TAG Dcm_DidMgrDidRsrcContextType;
# endif

# if (DCM_DIDMGR_RAM_CONTEXT_ENABLED == STD_ON)
struct DCM_DIDMANAGERCONTEXTTYPE_TAG
{
#  if(DCM_DIDMGR_XX_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_DidMgrDidRsrcContextType  DidRsrcContext;
#  endif
#  if (DCM_DIDMGR_IODID_NBYTE_EXT_CEMR_ENABLED == STD_ON)
  Dcm_MsgItemType IoControlCemrSessionMask[DCM_DIDMGR_IODID_MAX_EXT_CEMR_SIZE_CONST];
#  endif
};
typedef struct DCM_DIDMANAGERCONTEXTTYPE_TAG Dcm_DidManagerContextType;
# endif
# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
struct DCM_DIDMGRDIDOPTYPEWORKCONTEXTTYPE_TAG
{
  Dcm_DidMgrSignalOpClassInfoPtrType    SignalOpList;
  Dcm_DidMgrSignalInfoPtrType           SignalInfoList;
  Dcm_CfgDidMgrSignalIterMemType        NumSignals;
};
typedef struct DCM_DIDMGRDIDOPTYPEWORKCONTEXTTYPE_TAG Dcm_DidMgrDidOpTypeBaseContextType;
# endif

# if (DCM_DIDMGR_OPTYPECONTEXT_READ_ENABLED == STD_ON)
struct DCM_DIDMGROPTYPEREADCONTEXTTYPE_TAG
{
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_ENABLED == STD_ON)
  Dcm_CfgDidMgrOptimizedDidLengthType  Offset;
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
  Dcm_CfgDidMgrOptimizedDidLengthType  Progress;
#   if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
  Dcm_OpStatusType                     OpStatus;
#   endif
#  endif
};
typedef struct DCM_DIDMGROPTYPEREADCONTEXTTYPE_TAG Dcm_DidMgrOpTypeReadContextType;
# endif

# if (DCM_DIDMGR_OPTYPECONTEXT_LOOKUP_ENABLED == STD_ON)
typedef uint8 Dcm_DidMgrDidLookUpStateType;
struct DCM_DIDMGRLOOKUPCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidLookUpStateType State;
};
typedef struct DCM_DIDMGRLOOKUPCONTEXTTYPE_TAG Dcm_DidMgrLookUpContextType;
# endif

# if (DCM_DIDMGR_OPTYPECONTEXT_GETSCALING_ENABLED == STD_ON)
typedef P2CONST(Dcm_CfgNetBufferSizeMemType, TYPEDEF, DCM_CONST) Dcm_CfgDidMgrScalingInfoLengthPtrType; /* shall always fit the biggest buffer */
struct DCM_DIDMGROPTYPEREADSCALINGCONTEXTTYPE_TAG
{
  Dcm_CfgDidMgrScalingInfoLengthPtrType  LayoutList;
};
typedef struct DCM_DIDMGROPTYPEREADSCALINGCONTEXTTYPE_TAG Dcm_DidMgrOpTypeReadScalingContextType;
# endif

# if (DCM_DIDMGR_OPTYPECONTEXT_IO_ENABLED == STD_ON)
struct DCM_DIDMGROPTYPEIOCONTEXTTYPE_TAG
{
  Dcm_MsgType                     EnableMaskPtr;
#  if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_EXT_CEMR_ENABLED == STD_ON)
  uint32                          ControlEnableMaskRecord;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_INT_CEMR_ENABLED == STD_ON)
  boolean                         OperExecuted;
  Dcm_CfgDidMgrSignalIterMemType  SignalIter;
  Dcm_MsgItemType                 BitScanner;
#  endif
};
typedef struct DCM_DIDMGROPTYPEIOCONTEXTTYPE_TAG Dcm_DidMgrOpTypeIoContextType;
# endif

# if (DCM_DIDMGR_OPTYPECONTEXT_SHARED_ENABLED == STD_ON)
typedef union
{                                                                                                                                                    /* PRQA S 0750 */ /* MD_Dcm_Optimize_0750 */
#  if (DCM_DIDMGR_OPTYPECONTEXT_LOOKUP_ENABLED == STD_ON)
  Dcm_DidMgrLookUpContextType               LookUp;
#  endif
#  if (DCM_DIDMGR_OPTYPECONTEXT_READ_ENABLED == STD_ON)
  Dcm_DidMgrOpTypeReadContextType           Read;
#  endif
#  if (DCM_DIDMGR_OPTYPECONTEXT_IO_ENABLED == STD_ON)
  Dcm_DidMgrOpTypeIoContextType             Io;
#  endif
#  if (DCM_DIDMGR_OPTYPECONTEXT_GETSCALING_ENABLED == STD_ON)
  Dcm_DidMgrOpTypeReadScalingContextType    ReadScaling;
#  endif
}Dcm_DidMgrDidSharedOpTypeContextType;
# endif

struct DCM_DIDMGRDIDOPTYPECONTEXTTYPE_TAG
{
# if (DCM_DIDMGR_OPTYPECONTEXT_ENABLED == STD_ON)
#  if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
  Dcm_DidMgrDidOpTypeBaseContextType    Base;
#  endif
#  if (DCM_DIDMGR_OPTYPECONTEXT_SHARED_ENABLED == STD_ON)
  Dcm_DidMgrDidSharedOpTypeContextType  OpType;
#  endif
# else
  uint8 spare;
# endif
};
typedef struct DCM_DIDMGRDIDOPTYPECONTEXTTYPE_TAG Dcm_DidMgrDidOpTypeContextType;
typedef P2VAR(Dcm_DidMgrDidOpTypeContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_DidMgrDidOpTypeContextPtrType;

struct DCM_DIDMGRDIDDESCRIPTORTYPE_TAG
{
  Dcm_DidMgrDidInfoPtrType            DidInfoPtr;
  Dcm_DidMgrOpInfoPtrType             DidOpInfoPtr;
# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
  Dcm_DidMgrDidOpClassInfoPtrType     DidOpClassInfoPtr;
# endif
  Dcm_DidMgrSignalOpClassInfoPtrType  DidSignalOpClassInfoPtr;
};
typedef struct DCM_DIDMGRDIDDESCRIPTORTYPE_TAG Dcm_DidMgrDidDescriptorType;

struct DCM_DIDMGRDIDINFOCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidDescriptorType      Descriptor;
  uint16                           Did;
  uint16                           DidLength;
};
typedef struct DCM_DIDMGRDIDINFOCONTEXTTYPE_TAG Dcm_DidMgrDidInfoContextType;
typedef P2VAR(Dcm_DidMgrDidInfoContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_DidMgrDidInfoContextPtrType;
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2CONST(Dcm_CfgRidMgrRidInfoType, TYPEDEF, DCM_CONST)  Dcm_RidMgrRidInfoPtrType;
typedef P2CONST(Dcm_CfgRidMgrOpInfoType, TYPEDEF, DCM_CONST)   Dcm_RidMgrOpInfoPtrType;
typedef P2VAR(Dcm_CfgRidMgrInfoHandleOptType, AUTOMATIC, DCM_VAR_NOINIT) Dcm_CfgRidMgrInfoHandlePtrType;
typedef P2VAR(Dcm_CfgRidMgrOpHandleOptType, TYPEDEF, DCM_VAR_NOINIT) Dcm_CfgRidMgrOpHandlePtrType;
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
struct DCM_OBDDTCMGRREADDTCCONTEXTTYPE_TAG
{
  Dem_DTCOriginType  Origin;
  uint8              StatusMask;
};
typedef struct DCM_OBDDTCMGRREADDTCCONTEXTTYPE_TAG Dcm_ObdDtcMgrReadDtcContextType;

struct DCM_OBDDTCMANAGERCONTEXTTYPE_TAG
{
  Dcm_RepeaterProgressType  DcmObdDtcManagerProgress;
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
  uint8                     DemClientId;
# endif
};
typedef struct DCM_OBDDTCMANAGERCONTEXTTYPE_TAG Dcm_ObdDtcManagerContextType;
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/*! Base type for the diagnostic service verification level */
typedef uint8 Dcm_DiagCheckLvlType;

/*! Control data for diagnostic service post-processing */
struct DCM_DIAGPOSTPROCESSORCONTEXTTYPE_TAG
{
  uint16 SrcAddr;
  uint8  Sid;
  uint8  ReqType;
};
typedef struct DCM_DIAGPOSTPROCESSORCONTEXTTYPE_TAG Dcm_DiagPostProcessorContextType;

/*! Function pointer prototype for a diagnostic service specific length getter */
typedef P2FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE, Dcm_DiagServiceLengthGetterFuncType) (Dcm_DiagSubServiceRefOptType /* IN: Abstract (diagnostic service processor specific) sub-function handle */);
#if(DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
/*! Package with current communication and diagnostic variant selection (cached variant references) */
struct DCM_VARMANAGERCONTEXTTYPE_TAG
{
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)                                                                                                        /* COV_DCM_SUPPORT_ALWAYS TX */
  Dcm_CfgVarMgrComVariantType    ActiveComVariant;      /*!< Points to the COM-criteria */
# endif
# if ((DCM_DIAG_MULTI_SVC_TABLE_ENABLED == STD_ON) && (DCM_VARMGR_MODE_POSTBUILD_ANY_ENABLED == STD_ON))                                             /* COV_DCM_SUPPORT_PARTIALLY TF tf tx */
  Dcm_CfgVarMgrBridgeVariantType ActiveBridgeVariant;   /*!< Points to the COM-to-CFG-bridge information */
# endif
# if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
  Dcm_CfgVarMgrRamVariantType    ActiveRamVariant;      /*!< Points to the overall variant post-build-loadable RAM data */
  Dcm_CfgVarMgrRomVariantType    ActiveRomVariant;      /*!< Points to the overall variant post-build-loadable ROM data */
# endif
# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
#  if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                             /* COV_DCM_UNSUPPORTED XF */
  Dcm_CfgVarMgrBitSetBaseType    ActiveCfgVariants[Dcm_VarMgrBitSetCalcSize(DCM_VARMGR_NUM_CFG_VARIANTS_CONST)];  /*!< Contains all active CFG-criteria IDs */
#  else
  Dcm_CfgVarMgrDiagVariantIdMemType  ActiveCfgVariantId; /*!< Contains the active CFG-criteria ID */
#  endif
# endif
};
typedef struct DCM_VARMANAGERCONTEXTTYPE_TAG Dcm_VarManagerContextType;
#endif
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC01REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdIdMgrDescType    ParserDesc;
};
typedef struct DCM_SVC01REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc01RepeaterProxyContextType;
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC03REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdDtcManagerContextType  ReadDtcContext;
};
typedef struct DCM_SVC03REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc03RepeaterProxyContextType;
#endif /* (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC04REPEATERPROXYCONTEXTTYPE_TAG
{
  uint8 DemClientId;
};
typedef struct DCM_SVC04REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc04RepeaterProxyContextType;
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
struct DCM_SVC06REPEATERPROXYCONTEXTTYPE_TAG
{
  uint8 Spare; /* Currently not used */
};
typedef struct DCM_SVC06REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc06RepeaterProxyContextType;
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
struct DCM_SVC06REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdIdMgrDescType    ParserDesc;
};
typedef struct DCM_SVC06REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc06RepeaterProxyContextType;
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC07REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdDtcManagerContextType  ReadDtcContext;
};
typedef struct DCM_SVC07REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc07RepeaterProxyContextType;
#endif /* (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC08REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdIdMgrDescType    ParserDesc;
};
typedef struct DCM_SVC08REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc08RepeaterProxyContextType;
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC09REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdIdMgrDescType        ParserDesc;
};
typedef struct DCM_SVC09REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc09RepeaterProxyContextType;
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC0AREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdDtcManagerContextType  ReadDtcContext;
};
typedef struct DCM_SVC0AREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc0ARepeaterProxyContextType;
#endif /* (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
/*! Service 0x10 temporary processing context */
struct DCM_SVC10REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_StateIndexMemType             SesStateIdx;             /*!< Stores the requested new Session State to execute transition in post processor */
# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
  Dcm_ProgConditionsType            ProgConditions;          /*!< Stores the programming condition for further processing steps */
  Dcm_ModeMgrArEnvModeEcuResetType  ResetMode;               /*!< Stores the reset mode for Ecu reset */
# endif
};
typedef struct DCM_SVC10REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc10RepeaterProxyContextType;
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
/*! Service 0x11 temporary processing context */
struct DCM_SVC11REPEATERPROXYCONTEXTTYPE_TAG
{
  uint8                          SubFuncId;  /*!< Stores the sub-function ID of the current request */
  Dcm_DiagSubServiceRefMemType   SubSvcRef;  /*!< Reference to Dcm_CfgSvc11SubFuncInfo[] entry */
};
typedef struct DCM_SVC11REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc11RepeaterProxyContextType;

typedef P2CONST(Dcm_CfgSvc11SubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc11SubFuncInfoPtrType;
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/*! Service 0x14 temporary processing context */
struct DCM_SVC14REPEATERPROXYCONTEXTTYPE_TAG
{
  uint32   Dtc;         /*!< Stores the requested DTC for futher DEM interaction */
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
  uint8    DemClientId; /*!< Stores the DEM ClientId */
# endif
};
typedef struct DCM_SVC14REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc14RepeaterProxyContextType;
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/*! Service 0x19 paged-buffer updater dispatching item ID type */
typedef uint8 Dcm_Svc19SubUpdaterType;

/*! Service 0x19 temporary processing context */
struct DCM_19_REPEATERPROXYCONTEXTTYPE_TAG
{
  P2CONST(Dcm_RepeaterProgressType, TYPEDEF, DCM_CONST)  FuncChain;     /*!< Pointer to valid list of processing DEM API list */
# if (DCM_SVC_19_RECORD_ITER_ENABLED == STD_ON)
  Dcm_Uint8ConstDataPtrType                              RecordNumList; /*!< Pointer to DEM (extended/freeze-frame) record list */
# endif
  uint32                                                 Dtc;           /*!< Stores the requested DTC for futher DEM interaction */
  uint16                                                 NumDtc;        /*!< Stores the read number of DTCs reported by DEM to be passed to next processing stage */
  Dem_DTCOriginType                                      Origin;        /*!< Stores the requested DTC origin */
  uint8                                                  SubUpdater;    /*!< Stores the current paged-buffer updater within this diagnostic service */
  uint8                                                  RecordNum;     /*!< Stores either the requested or next record number to be read out from DEM */
  Dcm_DiagSubServiceRefMemType                           SubSvcRef;     /*!< Stores a validly dispatched sub-function requested for this diagnostic service */
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
  uint8                                                  DemClientId;   /*!< Stores the DEM ClientId */
# endif
  DCM_EXT_SVC19_PATCH_CONTEXT                                           /*!< A placeholder for optional on the fly DTC report patching (applicable in some specific customer requirements) */
};
typedef struct DCM_19_REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc19RepeaterProxyContextType;
typedef P2VAR(Dcm_Svc19RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc19RepeaterProxyContextPtrType;

typedef P2CONST(Dcm_CfgSvc19SubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc19SubFuncInfoPtrType;
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC22REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextPtrType  DidInfoContextPtr;
  Dcm_DidMgrDidInfoContextType     DidInfoContextList[DCM_SVC_22_MAX_DID_LIST_LEN_CONST];
  Dcm_DidMgrDidOpTypeContextType   DidOpTypeContext;
  Dcm_MsgLenType                   TotalLength;
  uint8                            NumDids;
  uint8                            DidIter;
# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
  Dcm_OpStatusType                 OpStatus;
# endif
};
typedef struct DCM_SVC22REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc22RepeaterProxyContextType;
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC23REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_MemMgrMemBlockType  MemBlock;
};
typedef struct DCM_SVC23REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc23RepeaterProxyContextType;
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC24REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType      DidInfoContext;
  Dcm_DidMgrDidOpTypeContextType    DidOpTypeContext;
};
typedef struct DCM_SVC24REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc24RepeaterProxyContextType;
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
typedef uint16 Dcm_Svc27TimerType;
# endif

/*! Service 0x27 temporary processing context */
struct DCM_SVC27REPEATERPROXYCONTEXTTYPE_TAG
{
  boolean                       IsZeroSeed;  /*!< Inidication for zero seed (unloced security level) */
  Dcm_DiagSubServiceRefMemType  SubSvcRef;   /*!< Reference to Dcm_CfgSvc27SubFuncInfo[] entry */
  uint8                         SecLvlRef;   /*!< Reference to Dcm_CfgSvc27SecLevelInfo[] entry */
  Dcm_NegativeResponseCodeType  ErrorCode;   /*!< Stores the error code */
};
typedef struct DCM_SVC27REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc27RepeaterProxyContextType;
typedef P2VAR(Dcm_Svc27RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc27RepeaterProxyContextPtrType;

/*! Context for attempt counter handling */
struct DCM_SVC27CONTEXTTYPE_TAG
{
# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
                            uint32              GetAttCntrEventMask;                            /*!< State of attempt counter read operations */
                            uint32              SetAttCntrEventMask;                            /*!< State of attempt counter write operations */
#  endif
#  if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
                            uint32              ReloadMask;                                     /*!< Infinite delay timer mask */
#  endif
  DCM_VOLATILE_ON_SPLITTASK Dcm_Svc27TimerType  DelayTime[DCM_SVC_27_NUM_DELAY_TIMERS];
                            uint8               AttemptCount[DCM_SVC_27_NUM_ATTEMPT_COUNTERS];  /*!< Array of attempt counters */
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
                            Dcm_OpStatusType    GetAttOpStatus;                                 /*!< Operation state of attempt counter read operation */
                            Dcm_OpStatusType    SetAttOpStatus;                                 /*!< Operation state of attempt counter write operation */
#  endif
# endif
                            uint8               SeedLevel;                                      /*!< Last requested security level for which a seed was sent */
};
typedef struct DCM_SVC27CONTEXTTYPE_TAG Dcm_Svc27ContextType;

typedef P2CONST(Dcm_CfgSvc27SubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc27SubFuncInfoPtrType;
typedef P2CONST(Dcm_CfgSvc27SecLevelInfoType, TYPEDEF, DCM_CONST)  Dcm_CfgSvc27SecLevelInfoPtrType;
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/*! Service 0x28 temporary processing context */
struct DCM_SVC28REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_CommunicationModeType  ComMode;               /*!< Stores the calculated CommunicationControl ModeDeclarationGroup mode value of the current service request */
  Dcm_CfgNetNetIdRefMemType  NetworkRef;            /*!< Stores the ComM channel of the current service request */
  uint8                      SubServiceId;          /*!< Stores the sub-function ID of the current service request */
# if (DCM_SVC_28_USER_ENABLED == STD_ON)
  boolean                    IsInternallyProcessed; /*!< Specifies whether the processed sub-function is internally handled (TRUE) or within application code (FALSE)*/
# endif
  Dcm_DiagSubServiceRefMemType  SubSvcRef;          /*!< Stores a validly dispatched sub-function requested for this diagnostic service */
};
typedef struct DCM_SVC28REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc28RepeaterProxyContextType;

typedef P2CONST(Dcm_CfgSvc28SubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc28SubFuncInfoPtrType;
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef uint8       Dcm_Svc2ASchedRateMemType;
typedef uint8_least Dcm_Svc2ASchedRateOptType;
typedef uint8       Dcm_Svc2ASchdItemHandleMemType;
typedef uint8_least Dcm_Svc2ASchdItemHandleOptType;

struct DCM_SVC2ASCHDENTRYTYPE_TAG
{
                            Dcm_DidMgrDidInfoContextType DidContext;
  DCM_VOLATILE_ON_SPLITTASK Dcm_TmrTimerCntrMemType      Timer;
                            Dcm_Svc2ASchedRateMemType    Rate;
};
typedef struct DCM_SVC2ASCHDENTRYTYPE_TAG Dcm_Svc2ASchdEntryType;

typedef P2VAR(Dcm_Svc2ASchdEntryType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2ASchdEntryPtrType;

struct DCM_SVC2ASCHEDULERTYPE_TAG
{
  Dcm_DidMgrDidInfoContextPtrType DidContextPtr;
  Dcm_Svc2ASchdEntryType          Table[DCM_SVC_2A_SCHEDULER_SIZE_CONST];
  Dcm_DidMgrDidOpTypeContextType  DidOpTypeContext;
  Dcm_Svc2ASchdItemHandleMemType  NumActiveEntries;
  Dcm_Svc2ASchdItemHandleMemType  NextEntryIdx;
  Dcm_CfgNetPTxObjHandleMemType   MsgTxHandle;
# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
  Dcm_OpStatusType                OpStatus;
# endif
};
typedef struct DCM_SVC2ASCHEDULERTYPE_TAG Dcm_Svc2ASchedulerType;
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC2AREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType    DidInfoContext;
  Dcm_DidMgrDidOpTypeContextType  DidOpTypeContext;
  Dcm_NetConnRefMemType           ConnId;
  uint8                           UdsRate;
  boolean                         HasAnySupportedDids;
};
typedef struct DCM_SVC2AREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc2ARepeaterProxyContextType;

struct DCM_SVC2ACONTEXTTYPE_TAG
{
  Dcm_Svc2ASchedulerType Scheduler;
};
typedef struct DCM_SVC2ACONTEXTTYPE_TAG Dcm_Svc2AContextType;
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/* Define by DID properties */
typedef uint8  Dcm_Svc2CSrcDidOffsetType;
typedef uint8  Dcm_Svc2CSrcDidSizeType;
typedef Dcm_UtiBitSetBaseType  Dcm_Svc2CSrcClassType;

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
struct DCM_SVC2CSRCDIDITEMINFOTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType DidContext;
  Dcm_Svc2CSrcDidOffsetType    Offset;
  Dcm_Svc2CSrcDidSizeType      Size;
};
typedef struct DCM_SVC2CSRCDIDITEMINFOTYPE_TAG Dcm_Svc2CSrcDidItemInfoType;
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
struct DCM_SVC2CSRCMEMITEMINFOTYPE_TAG
{
  Dcm_MemMgrMemBlockType MemBlock;
};
typedef struct DCM_SVC2CSRCMEMITEMINFOTYPE_TAG Dcm_Svc2CSrcMemItemInfoType;
# endif

typedef union
{                                                                                                                                                    /* PRQA S 0750 */ /* MD_Dcm_Optimize_0750 */
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2CSrcDidItemInfoType      DidDescriptor;
# endif
# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2CSrcMemItemInfoType      MemDescriptor;
# endif
}Dcm_Svc2CDynDidSrcItemType;

typedef P2VAR(Dcm_Svc2CDynDidSrcItemType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2CDynDidSrcItemPtrType;

struct DCM_SVC2CDYNDIDITEMTYPE_TAG
{
  Dcm_CfgNetBufferSizeMemType     Length;
  uint8                           Count;
};
typedef struct DCM_SVC2CDYNDIDITEMTYPE_TAG Dcm_Svc2CDynDidItemType;

struct DCM_SVC2CDYNDIDPROCESSCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidOpTypeContextType       DidOpTypeContext;
  Dcm_CfgDidMgrDynDidSrcItemIdxMemType ItemInProgress;
  Dcm_CfgDidMgrDynDidSrcItemIdxMemType ItemToStop;
};
typedef struct DCM_SVC2CDYNDIDPROCESSCONTEXTTYPE_TAG Dcm_Svc2CDynDidProcessContextType;

struct DCM_SVC2CDYNDIDACCESSCONTEXT_TAG
{
  Dcm_MsgType                       ResData;
  Dcm_Svc2CDynDidProcessContextType ProcessContext[DCM_SVC_2C_NUM_PROCESS_CONTEXTS];
# if (DCM_DIDMGR_DYNDID_ASYNC_SUPPORT_ENABLED == STD_ON)
  Dcm_CfgDidMgrDynDidHandleMemType  DynDidHandleInUse;
# endif
  Dcm_MsgItemType                   Buffer[DCM_SVC_2C_READ_BUFFER_SIZE + DCM_SVC_2C_READ_BUFFER_OVERHEAD];
};
typedef struct DCM_SVC2CDYNDIDACCESSCONTEXT_TAG Dcm_Svc2CDynDidReadAccessContext;
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC2CCONTEXTTYPE_TAG
{
  Dcm_Svc2CDynDidSrcItemType        SrcItems[DCM_NUM_DYNDID_ITEMS_CONST];
# if (DCM_SVC_2C_HYBRID_MODE_ENABLED == STD_ON)
  Dcm_Svc2CSrcClassType             Sequencer[Dcm_UtiGenericBitSetCalcSize(DCM_NUM_DYNDID_ITEMS_CONST)];
# endif
  Dcm_Svc2CDynDidItemType           Items[DCM_NUM_DYNDIDS_CONST];
  Dcm_Svc2CDynDidReadAccessContext  DynDidAccessContext;
};
typedef struct DCM_SVC2CCONTEXTTYPE_TAG Dcm_Svc2CContextType;

typedef P2CONST(Dcm_CfgSvc2CSubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc2CSubFuncInfoPtrType;
struct DCM_SVC2CREPEATERPROXYCONTEXTTYPE_TAG
{
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2CDynDidSrcItemPtrType          SrcItemPtr;
# endif
  Dcm_DidMgrDidInfoContextType           DynDidInfoContext;
  Dcm_DidMgrDidOpTypeContextType         DynDidOpTypeContext;
  Dcm_CfgDidMgrDynDidSrcItemIdxMemType   SrcItemIndex;
  Dcm_CfgDidMgrDynDidHandleMemType       DynDidHandle;
  Dcm_CfgNetBufferSizeMemType            MaxAllowedLength;
  Dcm_CfgNetBufferSizeMemType            DynDidLength;
  uint8                                  DynDidItemCount;
  uint8                                  ReqNumOfItems;
  Dcm_DiagSubServiceRefMemType           SubSvcRef;
};
typedef struct DCM_SVC2CREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc2CRepeaterProxyContextType;
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC2EREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType       DidInfoContext;
  Dcm_DidMgrDidOpTypeContextType     DidOpTypeContext;
};
typedef struct DCM_SVC2EREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc2ERepeaterProxyContextType;
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC2FCONTEXTTYPE_TAG
{
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  Dcm_UtiBitSetBaseType ActiveIoDids[Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS_CONST)];
  boolean               HasAnyActiveIoDid;
# else
  uint8 spare; /* not used */
# endif
};
typedef struct DCM_SVC2FCONTEXTTYPE_TAG Dcm_Svc2FContextType;
struct DCM_SVC2FREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType    DidInfoContext;
  Dcm_DidMgrDidOpTypeContextType  DidOpTypeContext;
  Dcm_DidMgrOpMemType             OpType;
};
typedef struct DCM_SVC2FREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc2FRepeaterProxyContextType;
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC31REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_CfgRidMgrInfoHandleOptType RidInfoIdx;
  Dcm_CfgRidMgrOpHandleOptType   RidOpInfoIdx;
  Dcm_RidMgrOpType               Op;
# if (DCM_RIDMGR_SUPPORT_ROUTINEINFOBYTE_ENABLED == STD_ON)
  Dcm_DiagBufferIndexType        RIBResIdx;
# endif
};
typedef struct DCM_SVC31REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc31RepeaterProxyContextType;
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC3DREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_MemMgrMemBlockType  MemBlock;
};
typedef struct DCM_SVC3DREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc3DRepeaterProxyContextType;
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
struct DCM_SVC85_REPEATERPROXYCONTEXTTYPE_TAG
/*! Service 0x85 temporary processing context */
{
  uint32                             DTCGroup;    /*!< Stores the requested DTC for the ModeSwitch operation during the post-processing */
  Rte_ModeType_DcmControlDtcSetting  ReqMode;     /*!< Stores the requested mode for the ModeSwitch operation during the post-processing */
  Dcm_DiagSubServiceRefOptType       SubSvcRef;   /*!< Reference to Dcm_CfgSvc85SubFuncInfo[] entry */
  uint8                              DemClientId; /*!< Stores the DEM ClientId */
};
typedef struct DCM_SVC85_REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc85RepeaterProxyContextType;
typedef P2CONST(Dcm_CfgSvc85SubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc85SubFuncInfoPtrType;
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC86REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ExtSvc86RepeaterContextType ExtSvc86RepeaterContext;
  Dcm_DiagSubServiceRefMemType    SubSvcRef;
};
typedef struct DCM_SVC86REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc86RepeaterProxyContextType;

typedef P2CONST(Dcm_CfgSvc86SubFuncInfoType, TYPEDEF, DCM_CONST)   Dcm_CfgSvc86SubFuncInfoPtrType;
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
/* ----------------------------------------------
 ~&&&   Typedefs Exported Level 1
---------------------------------------------- */
typedef Std_ReturnType Dcm_NetTransmissionResultType;
/*! Base data type for the application notification levels */
typedef uint8 Dcm_DiagApplNotificationType;
/*! Base data type for the diagnostic kernel processing state flags */
typedef uint8 Dcm_DiagProcessorFlagType;

/* Control data of the unsolicited response at ECU start-up task */
struct DCM_STARTUPRESPONSECONTEXTTYPE_TAG
{
  Dcm_ProgConditionsType          ProgConditions;                             /*!< Dedicated programming condition storage in case a parallel request needs the repeater proxy pool */
  Dcm_MsgItemType                 ResBuffer[DCM_DIAG_START_UP_FBL_RES_SIZE];  /*!< Dedicated response buffer for the final response */
  boolean                         IsResponseRequired;                         /*!< Stores the response-required information extracted from the pre-boot time context */
  Dcm_NetTransmissionResultType   TxStatus;                                   /*!< Transports the response transmission result to the Dcm_DiagTaskFblRes() */
  sint8                           SessStateRef;                               /*!< Stores the diagnostic session index (values <0 mean no session transition). Use sint8 since no more than 127 sessions are possible */
  Dcm_NetConnRefMemType           ConnId;                                     /*!< Stores the connection handle on which the unsolicited response was sent for post-processing purposes */
};
typedef struct DCM_STARTUPRESPONSECONTEXTTYPE_TAG Dcm_DiagStartUpResContextType;

/*! Storage of all diagnostic services contexts that shall be kept in memory not only during a diagnostic request but during the whole ECU operation cycle */
#if(DCM_DIAG_SVC_CONTEXT_ENABLED == STD_ON)
struct DCM_DIAGSERVICESCONTEXTTYPE_TAG
{
# if(DCM_SVC_27_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
  Dcm_Svc27ContextType          Svc27;  /*!< Storage place for all "SecurityAccess" data */
# endif
# if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2AContextType          Svc2A;  /*!< Storage place for all "ReadDataByPeriodicId" data */
# endif
# if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2CContextType          Svc2C;  /*!< Storage place for all "DynamicallyDefineIdentifier" data */
# endif
# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2FContextType          Svc2F;  /*!< Storage place for all "IOControlByIdentifier" data */
# endif
};
typedef struct DCM_DIAGSERVICESCONTEXTTYPE_TAG Dcm_DiagServicesContextType;
#endif

/*! Diagnostic kernel synchronization data */
#if (DCM_DIAG_SYNCH_DATA_SET_ENABLED == STD_ON)
struct DCM_DIAGSYNCHDATATYPE_TAG
{
# if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON)
  Dcm_CfgNetTObjHandleMemType      TObjHdl;  /*!< A single element queue for the transport object handle that holds the request data to be processed at next Dcm_DiagTaskWorker() activation */
#  if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
  Dcm_TskTaskEvMemType             QueuedTObjects;
#  endif
# endif
# if (DCM_DIAG_PROCESSOR_FLAGS_ENABLED == STD_ON)                                                                                                    /* COV_DCM_SUPPORT_ALWAYS TX */
  Dcm_DiagProcessorFlagType        Flags;    /*!< The diagnostic kernel status flags (Valid values: DCM_DIAG_QUEUE_FLAG_*) */
# endif
};
typedef struct DCM_DIAGSYNCHDATATYPE_TAG Dcm_DiagSynchDataType;
#endif

/*! Control data of the sub-component diagnostic kernel */
struct DCM_DIAGCONTEXTTYPE_TAG
{
  Dcm_MsgContextType               MsgContext;            /*!< The diagnostic service/sub-service processor message context */
#if (DCM_DIAG_SYNCH_DATA_SET_ENABLED == STD_ON)
volatile Dcm_DiagSynchDataType     QueuedSet;             /*!< Diagnostic kernel processing synchronization data */
#endif
#if(DCM_DIAG_ANY_NOTIFICATION_ENABLED == STD_ON)
  Dcm_DiagPostProcessorContextType PostProcessorContext;  /*!< Post-processing context */
#endif
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
  Dcm_DiagStartUpResContextType    StartUpFbl;            /*!< The global data of the unsolicited response task (Dcm_DiagTaskFblRes()) */
#endif
  Dcm_CfgNetTObjHandleMemType      TObjHdl;               /*!< The transport object handle of the diagnostic request in processing */
  Dcm_DiagP2TimingsType            P2Timings;             /*!< Currently active set of the P2/P2* timings */
  Dcm_NetTransmissionResultType    TxStatus;              /*!< Transports the (RCR-RP and final) USDT response transmission result to the Dcm_DiagTaskWorker() */
  Dcm_DiagApplNotificationType     ApplNotification;      /*!< Application notification level reached for current diagnostic request (Valid values: DCM_DIAG_APPL_NOTIFICATION_*) */
  volatile Dcm_DiagProcessorStateType State;              /*!< Keeps track of the diagnostic kernel processing state per diagnostic request */
  Dcm_NegativeResponseCodeType     ErrorRegister;         /*!< Keeps the NRC for the current diagnostic service in processing */
  uint8                            SidIndex;              /*!< Reference to Dcm_CfgDiagServiceInfo[] entry */
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
  uint8                            NumRcrRpTimeouts;      /*!< Keeps track of the number of RCR-RPs sent for the current diagnostic service processing */
#endif
#if(DCM_DIAG_SVC_CONTEXT_ENABLED == STD_ON)
  Dcm_DiagServicesContextType      Services;              /*!< Diagnostic service processors "long term" memory */
#endif
#if(DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  boolean                          IsInternRequest;       /*!< Specifies whether current request in processing is internal i.e. send via Dcm_ProcessVirtualRequest() or internal Dcm_NetRxIndInternal() API (TRUE - internal, FALSE - external (normal)) */
#endif
  boolean                          DoSuppressResponse;    /*!< Used dedicated flag instead of "NRC 0x11 and func_req" combination with the same effect, because of possible application confirmation functions! */
};
typedef struct DCM_DIAGCONTEXTTYPE_TAG Dcm_DiagContextType;
/* ----------------------------------------------
 ~&&&   Typedefs
---------------------------------------------- */
typedef union
{                                                                                                                                                    /* PRQA S 0750 */ /* MD_Dcm_Optimize_0750 */
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc01RepeaterProxyContextType Svc01;
#endif
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc03RepeaterProxyContextType Svc03;
#endif
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc04RepeaterProxyContextType Svc04;
#endif
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc06RepeaterProxyContextType Svc06;
#endif
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc07RepeaterProxyContextType Svc07;
#endif
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc08RepeaterProxyContextType Svc08;
#endif
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc09RepeaterProxyContextType Svc09;
#endif
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc0ARepeaterProxyContextType Svc0A;
#endif
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
  Dcm_Svc10RepeaterProxyContextType Svc10;
#endif
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc11RepeaterProxyContextType Svc11;
#endif
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc14RepeaterProxyContextType Svc14;
#endif
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc19RepeaterProxyContextType Svc19;
#endif
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc22RepeaterProxyContextType Svc22;
#endif
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc23RepeaterProxyContextType Svc23;
#endif
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc24RepeaterProxyContextType Svc24;
#endif
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc27RepeaterProxyContextType Svc27;
#endif
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc28RepeaterProxyContextType Svc28;
#endif
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2ARepeaterProxyContextType Svc2A;
#endif
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2CRepeaterProxyContextType Svc2C;
#endif
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2ERepeaterProxyContextType Svc2E;
#endif
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2FRepeaterProxyContextType Svc2F;
#endif
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc31RepeaterProxyContextType Svc31;
#endif
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc3DRepeaterProxyContextType Svc3D;
#endif
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc85RepeaterProxyContextType Svc85;
#endif
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc86RepeaterProxyContextType Svc86;
#endif
#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
  Dcm_RecoveryContextType           Recovery;
#endif
  uint8 reserved; /* just in case no other element is available */
}Dcm_RepeaterProxySvcContextType;

struct DCM_REPEATERPROXYCONTEXTPOOLTYPE_TAG
{
  Dcm_RepeaterProxySvcContextType Context;                                                                                                           /* PRQA S 0759 */ /* MD_Dcm_Optimize_0759 */
  Dcm_OpStatusType                OpStatus;
  Dcm_RepeaterProgressType        Progress;
#if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  Dcm_RepeaterUserType            User;
#endif
};
typedef struct DCM_REPEATERPROXYCONTEXTPOOLTYPE_TAG Dcm_RepeaterProxyContextPoolType;

struct DCM_REPEATERCONTEXTTYPE_TAG
{
  uint8                            CalleeIdx;
  Dcm_RepeaterProxyContextPoolType Contexts;
};
typedef struct DCM_REPEATERCONTEXTTYPE_TAG Dcm_RepeaterContextType;
/*! Function pointer prototype for a system task handler */
typedef P2FUNC(void, DCM_CODE, Dcm_TskTaskFuncType) (Dcm_TskTaskEvOptType /* IN: currently active events */
                                                    ,Dcm_TskTaskEvPtrType /* INOUT: events to be activated at next main-function cycle */);

/*! Single task configuration data */
struct DCM_TSKTASKINFOTYPE_TAG
{
  Dcm_TskTaskFuncType      TskFunc;        /*!< Pointer to the task handler Dcm_<SubComp>Task<Name>() (e.g. Dcm_NetTaskRx()) */
  Dcm_TskTaskAttributeType TskAtr;         /*!< Configuration attributes (e.g. can be terminated, number of executions per Dcm_MainFunction() call etc.) */
  Dcm_TskTaskPrioMemType   TskPrio;        /*!< The priority of the task (e.g. DEFAULT, HIGH, LOW etc.) */
  Dcm_TskTaskEvMemType     NonKillEvents;  /*!< If a task is determined as a killable one (DCM_TSK_ATR_KILL_ALWAYS) here are kept all events that shall not be reset during task termination */
};
typedef struct DCM_TSKTASKINFOTYPE_TAG Dcm_TskTaskInfoType;

typedef P2CONST(Dcm_TskTaskInfoType, TYPEDEF, DCM_CONST) Dcm_TskTaskInfoPtrType;
/*! Function pointer prototype for a system timer related time-out notification */
typedef P2FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE, Dcm_TmrTimeoutFuncType) (void);
/*! Single timer configuration data */
struct DCM_TMRTIMERINFOTYPE_TAG
{
  Dcm_TmrTimeoutFuncType ToFunc;  /*!< Pointer to the timeout notification handler of kind Dcm_OnTimeout<TimerName>() (e.g. Dcm_OnTimeoutP2()) */
};
typedef struct DCM_TMRTIMERINFOTYPE_TAG Dcm_TmrTimerInfoType;

typedef P2CONST(Dcm_TmrTimerInfoType, TYPEDEF, DCM_CONST) Dcm_TmrTimerInfoPtrType;

typedef volatile P2VAR(Dcm_TmrTimerCntrMemType, TYPEDEF, DCM_VAR_NOINIT) Dcm_TmrTimerCntrPtrType;
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/* Read port operations */
# if (DCM_DIDMGR_OPCLS_READ_SYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadSyncType)(Dcm_MsgType);
# endif
# if (DCM_DIDMGR_OPCLS_READ_SR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadSRType)(Dcm_MsgType);
# endif
# if (DCM_DIDMGR_OPCLS_READ_ASYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadAsyncType)(Dcm_OpStatusType
                                                                       ,Dcm_MsgType);
# endif
# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadPagedDidType)(Dcm_OpStatusType
                                                                          ,Dcm_MsgType
                                                                          ,Dcm_DidMgrDidLengthPtrType);
# endif
# if (DCM_DIDMGR_OPCLS_READ_RANGE_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadDidRangeType)(uint16
                                                                          ,Dcm_MsgType
                                                                          ,Dcm_OpStatusType
                                                                          ,Dcm_DidMgrDidLengthPtrType
                                                                          ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_READ_VID_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadVidType)(Dcm_OpStatusType
                                                                     ,Dcm_MsgType
#  if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
                                                                     ,Dcm_Uint8VarDataPtrType
#  endif
                                                                     );
# endif

/* Read Length port operations */
# if (DCM_DIDMGR_OPCLS_READ_LENGTH_RANGE_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadDidRangeLengthType)(uint16
                                                                                ,Dcm_OpStatusType
                                                                                ,Dcm_DidMgrDidLengthPtrType);
# endif
# if (DCM_DIDMGR_OPCLS_READ_LENGTH_SYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadLengthSyncType)(Dcm_DidMgrDidLengthPtrType);
# endif
# if (DCM_DIDMGR_OPCLS_READ_LENGTH_ASYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadLengthAsyncType)(Dcm_OpStatusType
                                                                             ,Dcm_DidMgrDidLengthPtrType);
# endif
/* Read CheckCondition port operations */
# if (DCM_DIDMGR_OPCLS_READ_CHECKCOND_SYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadCheckCondSyncType)(Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_READ_CHECKCOND_ASYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadCheckCondAsyncType)(Dcm_OpStatusType
                                                                                ,Dcm_NegativeResponseCodePtrType);
# endif
/* ScalingInformation port operations */
# if (DCM_DIDMGR_OPCLS_GETSCALINGINFO_SYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncGetScalingInfoSyncType)(Dcm_MsgType
                                                                                ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_GETSCALINGINFO_ASYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncGetScalingInfoAsyncType)(Dcm_OpStatusType
                                                                                 ,Dcm_MsgType
                                                                                 ,Dcm_NegativeResponseCodePtrType);
# endif
/* Write port operations */
# if (DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteNLenSyncNResErrorType)(Dcm_MsgType
                                                                                    ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_WRITE_NLEN_ASYNC_NRES_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteNLenAsyncNResErrorType)(Dcm_MsgType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_RES_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteLenSyncResErrorType)(Dcm_ReadOnlyMsgType
                                                                                  ,Dcm_DidMgrDidLengthPtrType
                                                                                  ,Dcm_MsgType
                                                                                  ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_WRITE_LEN_ASYNC_NRES_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteLenAsyncNResErrorType)(Dcm_MsgType
                                                                                    ,Dcm_DidMgrDidLengthType
                                                                                    ,Dcm_OpStatusType
                                                                                    ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_NRES_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteLenSyncNResErrorType)(Dcm_MsgType
                                                                                   ,Dcm_DidMgrDidLengthType
                                                                                   ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_NERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteNLenSyncNResNErrorType)(Dcm_MsgType);                                                  /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteDidRangeType)(uint16
                                                                           ,Dcm_MsgType
                                                                           ,Dcm_OpStatusType
                                                                           ,Dcm_DidMgrDidLengthType
                                                                           ,Dcm_NegativeResponseCodePtrType);
#  if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
/* IsAvailable range DID port operations */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncRangeIsAvailDidType)(uint16
                                                                             ,Dcm_OpStatusType
                                                                             ,P2VAR(Dcm_DidSupportedType, AUTOMATIC, DCM_VAR_NOINIT));
#  endif
# endif

/* IO Control port operations */

/* No CEMR */
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncNCemrErrorType)(Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncNCemrErrorType)(Dcm_OpStatusType
                                                                                       ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncNCemrErrorType)(Dcm_MsgType
                                                                                     ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncNCemrErrorType)(Dcm_MsgType
                                                                                    ,Dcm_DidMgrDidLengthType
                                                                                    ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncNCemrErrorType)(Dcm_MsgType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncNCemrErrorType)(Dcm_MsgType
                                                                                     ,Dcm_DidMgrDidLengthType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncResNCemrErrorType)(Dcm_ReadOnlyMsgType
                                                                                       ,Dcm_DidMgrDidLengthPtrType
                                                                                       ,Dcm_MsgType
                                                                                       ,Dcm_NegativeResponseCodePtrType);                            /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif

/* CEMR 8Bit */
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemr8ErrorType)(uint8, Dcm_NegativeResponseCodePtrType);                      /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemr8ErrorType)(Dcm_OpStatusType
                                                                                       ,uint8
                                                                                       ,Dcm_NegativeResponseCodePtrType);                            /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemr8ErrorType)(Dcm_MsgType
                                                                                     ,uint8
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemr8ErrorType)(Dcm_MsgType
                                                                                    ,Dcm_DidMgrDidLengthType
                                                                                    ,uint8
                                                                                    ,Dcm_NegativeResponseCodePtrType);                               /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemr8ErrorType)(Dcm_MsgType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,uint8
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemr8ErrorType)(Dcm_MsgType
                                                                                     ,Dcm_DidMgrDidLengthType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,uint8
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif

/* CEMR 16Bit */
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemr16ErrorType)(uint16, Dcm_NegativeResponseCodePtrType);                    /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemr16ErrorType)(Dcm_OpStatusType
                                                                                       ,uint16
                                                                                       ,Dcm_NegativeResponseCodePtrType);                            /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemr16ErrorType)(Dcm_MsgType
                                                                                     ,uint16
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemr16ErrorType)(Dcm_MsgType
                                                                                    ,Dcm_DidMgrDidLengthType
                                                                                    ,uint16
                                                                                    ,Dcm_NegativeResponseCodePtrType);                               /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemr16ErrorType)(Dcm_MsgType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,uint16
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemr16ErrorType)(Dcm_MsgType
                                                                                     ,Dcm_DidMgrDidLengthType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,uint16
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif

/* CEMR 32Bit */
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemr32ErrorType)(uint32, Dcm_NegativeResponseCodePtrType);                    /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemr32ErrorType)(Dcm_OpStatusType
                                                                                        ,uint32
                                                                                        ,Dcm_NegativeResponseCodePtrType);                           /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemr32ErrorType)(Dcm_MsgType
                                                                                      ,uint32
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemr32ErrorType)(Dcm_MsgType
                                                                                     ,Dcm_DidMgrDidLengthType
                                                                                     ,uint32
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemr32ErrorType)(Dcm_MsgType
                                                                                       ,Dcm_OpStatusType
                                                                                       ,uint32
                                                                                       ,Dcm_NegativeResponseCodePtrType);                            /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemr32ErrorType)(Dcm_MsgType
                                                                                      ,Dcm_DidMgrDidLengthType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,uint32
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif

/* CEMR NBit */
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemrNErrorType)(Dcm_MsgType, Dcm_NegativeResponseCodePtrType);                /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemrNErrorType)(Dcm_OpStatusType
                                                                                       ,Dcm_MsgType
                                                                                       ,Dcm_NegativeResponseCodePtrType);                            /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemrNErrorType)(Dcm_MsgType
                                                                                     ,Dcm_MsgType
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemrNErrorType)(Dcm_MsgType
                                                                                    ,Dcm_DidMgrDidLengthType
                                                                                    ,Dcm_MsgType
                                                                                    ,Dcm_NegativeResponseCodePtrType);                               /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemrNErrorType)(Dcm_MsgType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,Dcm_MsgType
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemrNErrorType)(Dcm_MsgType
                                                                                     ,Dcm_DidMgrDidLengthType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,Dcm_MsgType
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_RIDMGR_OPTYPE_NONE_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncNoParamsType)(Dcm_OpStatusType
                                                                           ,Dcm_NegativeResponseCodePtrType);
# endif

# if (DCM_RIDMGR_OPTYPE_REQ_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqType)(Dcm_ReadOnlyMsgType
                                                                      ,Dcm_OpStatusType
                                                                      ,Dcm_NegativeResponseCodePtrType);
# endif

# if (DCM_RIDMGR_OPTYPE_REQ_RES_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqResType)(Dcm_ReadOnlyMsgType
                                                                         ,Dcm_OpStatusType
                                                                         ,Dcm_MsgType
                                                                         ,Dcm_NegativeResponseCodePtrType);
# endif

# if (DCM_RIDMGR_OPTYPE_RES_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncResType)(Dcm_OpStatusType
                                                                      ,Dcm_MsgType
                                                                      ,Dcm_NegativeResponseCodePtrType);
# endif

# if (DCM_RIDMGR_OPTYPE_REQ_DYNLEN_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqDynLenType)(Dcm_ReadOnlyMsgType
                                                                            ,Dcm_OpStatusType
                                                                            ,Dcm_RidMgrRidLengthType
                                                                            ,Dcm_NegativeResponseCodePtrType);
# endif

# if (DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqDynLenResType)(Dcm_ReadOnlyMsgType
                                                                               ,Dcm_OpStatusType
                                                                               ,Dcm_MsgType
                                                                               ,Dcm_RidMgrRidLengthType
                                                                               ,Dcm_NegativeResponseCodePtrType);
# endif

# if (DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_DYNLEN_ENABLED == STD_ON) || \
     (DCM_RIDMGR_OPTYPE_REQ_RES_DYNLEN_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqAnyLenResDynLenType)(Dcm_ReadOnlyMsgType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,Dcm_MsgType
                                                                                     ,Dcm_RidMgrRidLengthPtrType
                                                                                     ,Dcm_NegativeResponseCodePtrType);
# endif

# if (DCM_RIDMGR_OPTYPE_RES_DYNLEN_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncResDynLenType)(Dcm_OpStatusType
                                                                            ,Dcm_MsgType
                                                                            ,Dcm_RidMgrRidLengthPtrType
                                                                            ,Dcm_NegativeResponseCodePtrType);
# endif
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
typedef P2VAR(Dcm_ObdDtcManagerContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_ObdDtcManagerContextPtrType;
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/*! Data container with all instantiatable elements (i.e. for multi-server mode)  */
struct DCM_INSTANCECONTEXTTYPE_TAG
{
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_PagedBufferContextType    PagedBuffer;    /*!< Paged-buffer manager sub-component per-instance memory */
#endif
  Dcm_DiagContextType           Diag;           /*!< Diagnostic kernel sub-component per-instance memory */
  Dcm_RepeaterContextType       Repeater;       /*!< Diagnostic service processor repeater sub-component per-instance memory */
#if (DCM_DIDMGR_RAM_CONTEXT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_UNSUPPORTED XF */
  Dcm_DidManagerContextType     DidMgr;         /*!< DID manager sub-component per-instance memory */
#endif
#if (DCM_MEMMGR_RAM_CONTEXT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_UNSUPPORTED XF */
  Dcm_MemManagerContextType     MemMgr;         /*!< Direct memory access manager sub-component per-instance memory */
#endif
};
typedef struct DCM_INSTANCECONTEXTTYPE_TAG Dcm_InstanceContextType;

/*! Data container for data shared among all DCM instances (in multi-server mode)  */
struct DCM_SINGLETONCONTEXTTYPE_TAG
{
  Dcm_NetContextType         Network;         /*!< Network sub-component shared memory */
  Dcm_TskContextType         TaskMgr;         /*!< System task manager sub-component shared memory */
  Dcm_TmrContextType         TimerMgr;        /*!< System timer manager sub-component shared memory */
  Dcm_StateContextType       StateMgr;        /*!< Diagnostic state manager sub-component shared memory */
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
  Dcm_ModeContextType        ModeMgr;         /*!< Mode manager sub-component shared memory */
#endif
#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
  Dcm_VarManagerContextType  VarMgr;          /*!< Variant manager sub-component shared memory */
#endif
};
typedef struct DCM_SINGLETONCONTEXTTYPE_TAG Dcm_SingletonContextType;
/*! Variant reference data type (derived from the execution precondition references since it is part of the pre-conditions and located in the same table) */
typedef Dcm_CfgStateRefMemPtrType  Dcm_VarRefMemPtrType;
typedef uint16 Dcm_VsgSizeType;
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2VAR(Dcm_Svc04RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc04RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2VAR(Dcm_Svc09RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc09RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
typedef P2VAR(Dcm_Svc10RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc10RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc11RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc11RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc14RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc14RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/*! DEM filter configuration selector type */
typedef uint8 Dcm_Svc19DemSetFilterClassType;
/*! Report DTC by status mask engine mask usage type */
typedef uint8 Dcm_Svc19DemSetFilterMaskUsageType;
/*! Abstract DTC record iterator result type */
typedef uint8 Dcm_Svc19UtiRecordIterResultType;

/*! Descriptor of a DEM filter configuration */
struct DCM_SVC19DEMDTCFILTERINFOTYPE_TAG
{
# if (DCM_DEM_API_430_ENABLED == STD_OFF)
  Dem_DTCKindType                Kind;             /*!< DTC kind */
# endif
  Dem_DTCOriginType              Origin;           /*!< DTC origin */
  Dcm_DemFilterWithSeverityType  ConsiderSeverity; /*!< DTC severity */
};
typedef struct DCM_SVC19DEMDTCFILTERINFOTYPE_TAG Dcm_Svc19DemDtcFilterInfoType;
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2VAR(Dcm_Svc22RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc22RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2VAR(Dcm_Svc23RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc23RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2VAR(Dcm_Svc24RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc24RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/*! Function pointer prototype for a Get-Seed handler with Security-Access-Data-Record */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_Svc27OpFuncSeedWAdr)(Dcm_MsgType
                                                                 ,Dcm_OpStatusType
                                                                 ,Dcm_MsgType
                                                                 ,Dcm_NegativeResponseCodePtrType);

/*! Function pointer prototype for a Get-Seed handler without Security-Access-Data-Record */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_Svc27OpFuncSeedWoAdr)(Dcm_OpStatusType
                                                                  ,Dcm_MsgType
                                                                  ,Dcm_NegativeResponseCodePtrType);
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc28RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc28RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2VAR(Dcm_Svc2ARepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc2ARepeaterProxyContextPtrType;
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2VAR(Dcm_Svc2CRepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc2CRepeaterProxyContextPtrType;
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2VAR(Dcm_Svc2ERepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc2ERepeaterProxyContextPtrType;
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2VAR(Dcm_Svc2FRepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc2FRepeaterProxyContextPtrType;
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2VAR(Dcm_Svc31RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc31RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2VAR(Dcm_Svc3DRepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc3DRepeaterProxyContextPtrType;
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
typedef P2VAR(Dcm_Svc85RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc85RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2VAR(Dcm_Svc86RepeaterProxyContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_Svc86RepeaterProxyContextPtrType;
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
/* ----------------------------------------------
 ~&&&   Module internal inlined function declarations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_MemMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Initialization of the direct memory access sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_MemMgrInit(void);

/**********************************************************************************************************************
 *  Dcm_MemMgrConvMemOpResult()
 *********************************************************************************************************************/
/*! \brief          Converts memory operation result to standard result type.
 *  \details        -
 *  \param[in]      memOpResult   Memory operation result
 *  \param[in]      opStatus      Current operation status
 *  \param[in,out]  ErrorCode     The NRC from application and result to diag core
 *  \param[in]      DefaultNrc    Default NRC in case application is not able to report any particular one
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrConvMemOpResult(Dcm_MemMgrOpResultType memOpResult
                                                                         ,Dcm_OpStatusType opStatus
                                                                         ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                         ,Dcm_NegativeResponseCodeType DefaultNrc);
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId()
 *********************************************************************************************************************/
/*! \brief          Read operation for a Supported OBD MID
 *  \details        -
 *  \param[in]      ObdMID         Supported OBD Monitor Id
 *  \param[out]     Data           Data buffer
 *  \param[out]     DataLength     Data length
 *  \param[out]     ErrorCode      Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK       Read operation was successful
 *  \return         DCM_E_NOT_OK   Read operation was not successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            Obd MID is a supported MID (0x00, 0x20, 0x40,..)
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId(uint8 ObdMID
                                                                                         ,Dcm_MsgType Data
                                                                                         ,Dcm_DidMgrDidLengthPtrType DataLength
                                                                                         ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_DataId()
 *********************************************************************************************************************/
/*! \brief          Read operation for a OBD MID
 *  \details        Reads test result for given OBD MID
 *  \param[in]      ObdMID         OBD Monitor Id
 *  \param[out]     Data           Data buffer
 *  \param[out]     DataLength     Data length
 *  \param[out]     ErrorCode      Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK       Read operation was successful
 *  \return         DCM_E_NOT_OK   Read operation was not successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            Obd MID is not a supported MID (0x00, 0x20, 0x40,..)
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_DataId(uint8 ObdMID
                                                                                    ,Dcm_MsgType Data
                                                                                    ,Dcm_DidMgrDidLengthPtrType DataLength
                                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
# if (DCM_UTI_NVM_READ_ENABLED  == STD_ON) || \
     (DCM_UTI_NVM_WRITE_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_UtiArEnvNvMGetErrorStatus()
 *********************************************************************************************************************/
/*! \brief          Adapter function for AR 3.XX NvM_GetErrorStatus().
 *  \details        -
 *  \param[in]      blockId    Id of the NvRam block
 *  \param[out]     nvmStatus  Delegates the result from the NvM_GetErrorStatus()
 *  \return         E_OK       This value is always returned.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiArEnvNvMGetErrorStatus(uint16 blockId
                                                        ,P2VAR(NvM_RequestResultType, AUTOMATIC, AUTOMATIC) nvmStatus);
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_UTI_LOOKUP_RANGE_U16_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_UtiLookUpRangeUint16()
 *********************************************************************************************************************/
/*! \brief          Searches a word in a table of ranges.
 *  \details        -
 *  \param[in]      lookUpTable    Pointer to the table to be scanned (first element is table-size!)
 *  \param[in]      value          Value to be found
 *  \return         -1             Look up failed (no match)
 *  \return         >=0            Success, index of the matched position
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            Total number of elements for look up shall be < 32768.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint16_least, DCM_CODE) Dcm_UtiLookUpRangeUint16(P2CONST(Dcm_UtiU16RangeType, AUTOMATIC, DCM_CONST) lookUpTable
                                                                      ,uint16 value);
#endif
#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
/**********************************************************************************************************************
 *  Dcm_NetIsRxPduIdValid()
 *********************************************************************************************************************/
/*! \brief          Checks the received rxPduId.
 *  \details        -
 *  \param[in]      rxPduId    The rxPduId of the request
 *  \return         TRUE       The rxPduId is valid
 *  \return         FALSE      The rxPduId is not valid
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsRxPduIdValid(PduIdType rxPduId);
#endif

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
/**********************************************************************************************************************
 *  Dcm_NetIsTxPduIdValid()
 *********************************************************************************************************************/
/*! \brief          Checks the received txPduId.
 *  \details        -
 *  \param[in]      txPduId    The txPduId of the request
 *  \return         TRUE       The txPduId is valid
 *  \return         FALSE      The txPduId is not valid
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsTxPduIdValid(PduIdType txPduId);
#endif

/**********************************************************************************************************************
 *  Dcm_NetGetComMContext()
 *********************************************************************************************************************/
/*! \brief          Returns a ComM context element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a ComM context
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetComMContextPtrType, DCM_CODE) Dcm_NetGetComMContext(Dcm_CfgNetNetIdRefOptType index);

/**********************************************************************************************************************
 *  Dcm_NetGetBufferContext()
 *********************************************************************************************************************/
/*! \brief          Returns a buffer context element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a buffer context
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetBufferContextPtrType, DCM_CODE) Dcm_NetGetBufferContext(Dcm_CfgNetBufferRefOptType index);

/**********************************************************************************************************************
 *  Dcm_NetGetTransportObject()
 *********************************************************************************************************************/
/*! \brief          Returns a transport object element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a transport object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetGetTransportObject(
                                                                                    Dcm_CfgNetTObjHandleOptType index);

#if (DCM_NET_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetSetComControlChannelState()
 *********************************************************************************************************************/
/*! \brief          Sets the state of a communication control channel of the given index.
 *  \details        -
 *  \param[in]      index    Index to the communication control channel
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetSetComControlChannelState(uint8_least index
                                                                      ,Dcm_CommunicationModeType value);
#endif

/**********************************************************************************************************************
 *  Dcm_NetPutToConn2TObjMap()
 *********************************************************************************************************************/
/*! \brief          Sets a transport object handle of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a transport object handle
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPutToConn2TObjMap(Dcm_NetConnRefOptType index
                                                              ,Dcm_CfgNetTObjHandleMemType value);

/**********************************************************************************************************************
 *  Dcm_NetWriteAddBufferU8At()
 *********************************************************************************************************************/
/*! \brief          Writes into the additional buffer of a transport object.
 *  \details        -
 *  \param[in]      pTranspObj    The transport object
 *  \param[in]      index         Index to the additional buffer
 *  \param[in]      value         New value of the transport object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetWriteAddBufferU8At(Dcm_NetTransportObjectPtrType pTranspObj
                                                               ,uint8 index
                                                               ,Dcm_MsgItemType value);

/**********************************************************************************************************************
 *  Dcm_NetGetBufferInfo()
 *********************************************************************************************************************/
/*! \brief          Returns a buffer information element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a buffer information element
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_PbCfgNetBufferInfoPtrType, DCM_CODE) Dcm_NetGetBufferInfo(Dcm_CfgNetBufferRefOptType index);

/**********************************************************************************************************************
 *  Dcm_NetCommonInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the common network related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetCommonInit(void);

/**********************************************************************************************************************
 *  Dcm_NetComMInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the ComM related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComMInit(void);

/**********************************************************************************************************************
 *  Dcm_NetBufferInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the buffer related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetBufferInit(void);

/**********************************************************************************************************************
 *  Dcm_NetConnectionInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the connection related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetConnectionInit(void);

/**********************************************************************************************************************
 *  Dcm_NetTranspObjInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the transport object related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTranspObjInit(void);

/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the periodic message related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgInit(void);

/**********************************************************************************************************************
 *  Dcm_NetInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the network sub-module.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetInit(void);

/**********************************************************************************************************************
 *  Dcm_NetRegisterActiveConnection()
 *********************************************************************************************************************/
/*! \brief          Registers an active connection.
 *  \details        Function will be called from Dcm_NetStartOfReception.
 *  \param[in]      pTranspObj    The transport object
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRegisterActiveConnection(Dcm_NetTransportObjectPtrType pTranspObj);

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetOnRequestDetection()
 *********************************************************************************************************************/
/*! \brief          Cancels any pending job if detected another ECU to be requested from the same client.
 *  \details        Function will be called from Dcm_NetStartOfReception.
 *  \param[in]      connId        The connection ID of the foreign ECU request
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetOnRequestDetection(Dcm_NetConnRefMemType connId);
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisation_FindWinner()
 *********************************************************************************************************************/
/*! \brief          Determination of request with highest priority
 *  \details        -
 *  \param[in]      ev                      The active event(s) of the task Dcm_NetTaskRx
 *  \param[out]     pBusyEvents             Bitfield for busy requests
 *  \return         ID of the winner
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetTObjHandleOptType, DCM_CODE) Dcm_NetRxPrioritisation_FindWinner(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pBusyEvents);
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessWinner()
 *********************************************************************************************************************/
/*! \brief          Processing of the request with the highest priority
 *  \details        -
 *  \param[in]      TranspObjWinnerId       ID of the winner
 *  \param[in]      pBusyEvents             Bitfield for busy requests
 *  \return         Updated bitfield for busy requests
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_NetRxPrioritisationProcessWinner(
                                                                          Dcm_CfgNetTObjHandleOptType TranspObjWinnerId
                                                                         ,Dcm_TskTaskEvOptType BusyEvents);
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessLoosers()
 *********************************************************************************************************************/
/*! \brief          Processing of requests that were preempted
 *  \details        -
 *  \param[in]      BusyEvents             Bitfield for busy requests
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisationProcessLoosers(Dcm_TskTaskEvOptType BusyEvents);
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisation()
 *********************************************************************************************************************/
/*! \brief          Prioritization of received requests.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task Dcm_NetTaskRx
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisation(Dcm_TskTaskEvOptType ev
                                                             ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if(DCM_NET_PROTOCOL_SWITCH_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetExecStartProtocolOp()
 *********************************************************************************************************************/
/*! \brief          Executes a protocol start up.
 *  \details        -
 *  \param[in]      newProtocol    The new protocol ID to be evaluated for starting
 *  \return         TRUE           Proceed with protocol starting
 *  \return         FALSE          Skip any further service processing after return
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetExecStartProtocolOp(Dcm_ProtocolType newProtocol);
#endif

/**********************************************************************************************************************
 *  Dcm_NetComposeAddNegResponse()
 *********************************************************************************************************************/
/*! \brief          Composes a negative response.
 *  \details        -
 *  \param[in]      pTranspObj    The transport object
 *  \param[in]      resType       The response type
 *  \param[in]      nrc           The negative response code
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComposeAddNegResponse(Dcm_NetTransportObjectPtrType pTranspObj
                                                                  ,Dcm_NetResponseType resType
                                                                  ,Dcm_NegativeResponseCodeType nrc);

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetProcessStartProtocol()
 *********************************************************************************************************************/
/*! \brief          Starts a new protocol.
 *  \details        Delegates a new request with a new protocol and terminates the old one.
 *  \param[in]      pTranspObj    The transport object
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetProcessStartProtocol(Dcm_NetTransportObjectPtrType pTranspObj);
#endif

/**********************************************************************************************************************
 *  Dcm_NetTransmitUsdtResponse()
 *********************************************************************************************************************/
/*! \brief          Start transmission on this connection.
 *  \details        Start an USDT transmission over a specific connection.
 *  \param[in]      pTranspObj            The transport object to be used during the transmission.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            All the items of the structure must be validly initialized:
 *                  hBuffer               Shall be the TxBuffer handle
 *                  pduInfo.SduDataPtr    Shall point to the TxBuffer
 *                  pduInfo.SduLength     Shall contain the length of the data to be sent
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTransmitUsdtResponse(Dcm_NetTransportObjectPtrType pTranspObj);

#if (DCM_NET_CONN_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetLockConnectionOrNull()
 *********************************************************************************************************************/
/*! \brief          Allocates a transport object for a concrete client connection.
 *  \details        -
 *  \param[in]      connId    The connection to be locked
 *  \return         Allocated transport object
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetLockConnectionOrNull(Dcm_NetConnRefMemType connId);
#endif

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationNotOk()
 *********************************************************************************************************************/
/*! \brief          Indication of finished reception with no success.
 *  \details        This function is called by Dcm_NetTpRxIndication.
 *  \param[in]      pTranspObj    The transport object
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationNotOk(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationOk()
 *********************************************************************************************************************/
/*! \brief          Indication of finished reception with success.
 *  \details        This function is called by Dcm_NetTpRxIndication.
 *  \param[in]      pTranspObj    The transport object
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationOk(Dcm_NetTransportObjectPtrType pTranspObj);

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgSetFastestRate()
 *********************************************************************************************************************/
/*! \brief          Sets a new fastest rate
 *  \details        -
 *  \param[in]      Rate    The periodic rate
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgSetFastestRate(Dcm_Svc2ASchedRateOptType Rate);
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPTxDelayTimerStart()
 *********************************************************************************************************************/
/*! \brief          Starts a delay timer for periodic message transmission.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxDelayTimerStart(void);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutTxObjectHandler()
 *********************************************************************************************************************/
/*! \brief          Executes jobs on timeout of a transport object timer.
 *  \details        -
 *  \return         Flag whether timer needs to be reloaded
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutTxObjectHandler(void);
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutDelayTimerHandler()
 *********************************************************************************************************************/
/*! \brief          Executes jobs on timeout of a delay timer.
 *  \details        -
 *  \return         Flag whether timer needs to be reloaded
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutDelayTimerHandler(void);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmitTxObj()
 *********************************************************************************************************************/
/*! \brief          Transmits a periodic message.
 *  \details        -
 *  \param[in]      perTxObjHandle    Handle of periodic transport object to be transmitted
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            The periodic message shall first be allocated via Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmitTxObj(Dcm_CfgNetPTxObjHandleOptType perTxObjHandle);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgResetConnection()
 *********************************************************************************************************************/
/*! \brief          Resets the periodic message connection.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgResetConnection(void);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgStopDid()
 *********************************************************************************************************************/
/*! \brief          Stops transmission of DID and also removes queued transport objects.
 *  \details        -
 *  \param[in]      Did      DID that is to be stopped
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgStopDid(uint16 Did);
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetTpTxConfirmation()
 *********************************************************************************************************************/
/*! \brief          Confirmation for a specific TxPduId TP channel.
 *  \details        This function is called by Dcm_TpTxConfirmation.
 *  \param[in]      txPduId    The confirmation TxPDUID of the response
 *  \param[in]      result     Request reception status
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpTxConfirmation(PduIdType txPduId
                                                             ,Dcm_NetArEnvNotifResultType result);
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
/**********************************************************************************************************************
 *  Dcm_NetIsPduInfoValid()
 *********************************************************************************************************************/
/*! \brief          Checks the received PduInfo
 *  \details        -
 *  \param[in]      info       Message context (data and length of the portion)
 *  \return         TRUE       The info element is valid
 *  \return         FALSE      The info element is not valid
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsPduInfoValid(P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info);
# endif

/**********************************************************************************************************************
 *  Dcm_NetCopyRxData()
 *********************************************************************************************************************/
/*! \brief          Copies request data from the lower layer.
 *  \details        This function is called by Dcm_CopyRxData.
 *  \param[in]      pTranspObj         The transport object
 *  \param[in]      info               Message context (data and length of the portion)
 *  \param[out]     bufferSizePtr      Available buffer size
 *  \return         BUFREQ_OK          A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK    No free buffer is available - ignore request
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyRxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                        ,P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info
                                                        ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr);

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndication()
 *********************************************************************************************************************/
/*! \brief          Indication of finished reception.
 *  \details        This function is called by Dcm_TpRxIndication.
 *  \param[in]      rxPduId    The RxPDUID of the request.
 *  \param[in]      result     Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndication(PduIdType rxPduId
                                                           ,Dcm_NetArEnvNotifResultType result);

/**********************************************************************************************************************
 *  Dcm_NetCopyLinearTxData()
 *********************************************************************************************************************/
/*! \brief          Copies transmit data in linear form to the lower layer.
 *  \details        This function is called by Dcm_NetCopyTxData for the linear response data case.
 *  \param[in]      pTranspObj          The transport object
 *  \param[in]      info                Pointer to a PduInfoType, which indicates the number of bytes to be copied
 *                                      (SduLength) and the location where the data have to be copied to (SduDataPtr).
 *                                      An SduLength of 0 is possible in order to poll the available transmit data
 *                                      count. In this case no data are to be copied and SduDataPtr might be invalid.
 *  \param[in]      availableDataPtr    Remaining Tx data after completion of this call
 *  \return         BUFREQ_OK           A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK     Some error occurred (i.e. internal error detected)
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyLinearTxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                      ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                             /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                      ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr);

/**********************************************************************************************************************
 *  Dcm_NetCopyTxData()
 *********************************************************************************************************************/
/*! \brief          Copies transmit data to the lower layer.
 *  \details        This function is called by Dcm_CopyTxData.
 *  \param[in]      pTranspObj          The transport object
 *  \param[in]      info                Pointer to a PduInfoType, which indicates the number of bytes to be copied
 *                                      (SduLength) and the location where the data have to be copied to (SduDataPtr).
 *                                      An SduLength of 0 is possible in order to poll the available transmit data
 *                                      count. In this case no data are to be copied and SduDataPtr might be invalid.
 *  \param[in]      availableDataPtr    Remaining Tx data after completion of this call.
 *  \return         BUFREQ_OK           Response data is available - all requested data are copied
 *  \return         BUFREQ_E_BUSY       The required amount of data is not available - try later again
 *  \return         BUFREQ_E_NOT_OK     Some error occurred (e.g. no more data, internal error detected etc.)
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyTxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                     ,P2VAR(PduInfoType,   AUTOMATIC, DCM_APPL_DATA) info                                            /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                     ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr);
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_PagedBufferInit()
 *********************************************************************************************************************/
/*! \brief          Initialize paged-buffer any time.
 *  \details        Initialization of the paged-buffer.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferInit(void);

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferDefragmentPage()
 *********************************************************************************************************************/
/*! \brief          Defragments the current paged-buffer page.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferDefragmentPage(void);
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferUpdatePage()
 *********************************************************************************************************************/
/*! \brief          Dispatches the UpdatePage call.
 *  \details        Dispatches the UpdatePage call regarding the paged-buffer.
 *  \param[out]     ErrorCode             The NRC
 *  \return         DCM_E_OK              All data has been copied - evaluate the out parameters
 *  \return         DCM_E_PENDING         No result yet, retry later
 *  \return         DCM_E_NOT_OK          Something went wrong, stop updating(only in DET situation)
 *  \return         DCM_E_BUFFERTOOLOW    Some data copied but no place, retry later on TP buffer under-run
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferUpdatePage(Dcm_NegativeResponseCodePtrType ErrorCode);
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*! \brief          Copy from paged-buffer to the TP layer.
 *  \details        -
 *  \param[in,out]  PduInfo             PduR message context
 *  \param[in]      Length              Remained data in the buffer
 *  \return         BUFREQ_OK           A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK     No free buffer is available - ignore request
 *  \return         BUFREQ_E_BUSY       No free buffer at this time - try later again
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
                                                                   P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) PduInfo
                                                                  ,PduLengthType Length);
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*! \brief          Copy from paged-buffer to the TP layer.
 *  \details        -
 *  \param[in]      info                Message context (data and length of the portion)
 *  \param[in]      availableDataPtr    Remaining Tx data after completion of this call
 *  \return         BUFREQ_OK           A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK     No free buffer is available - ignore request
 *  \return         BUFREQ_E_BUSY       No free buffer at this time - try later again
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
                                                      P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info
                                                     ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr);
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_RepeaterNextStep()
 *********************************************************************************************************************/
/*! \brief          Sets next step of repeater proxy
 *  \details        -
 *  \param[in]      nextStep    Next step to be processed
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_RepeaterNextStep(Dcm_RepeaterProgressType nextStep);

/**********************************************************************************************************************
 *  Dcm_CfgDiagServiceInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get Service info descriptor
 *  \details        -
 *  \param[in]      SidIndex      Index to a Service info descriptor
 *  \return         Service info descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgDiagServiceInfoPtrType, DCM_CODE) Dcm_CfgDiagServiceInfoGetEntryOrNull(uint8 SidIndex);
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgModeMgrRulesGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get module rule
 *  \details        -
 *  \param[in]      modeRuleRef    A reference to a mode rule
 *  \return         Module Rule function
 *  \return         NULL_PTR       On invalid mode rule reference (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_ModeRuleFuncType, DCM_CODE) Dcm_CfgModeMgrRulesGetEntryOrNull(Dcm_CfgModeMgrRuleRefOptType modeRuleRef);
# endif

# if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeCheck()
 *********************************************************************************************************************/
/*! \brief          Performs a mode rule check.
 *  \details        -
 *  \param[in]      modeRuleRef    A reference to a mode rule
 *  \param[out]     ErrorCode      The NRC
 *  \return         DCM_E_OK       Mode rule check was successful
 *  \return         DCM_E_NOT_OK   Mode rule check was not successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeCheck(Dcm_CfgModeMgrRuleRefOptType modeRuleRef
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif

# if (DCM_MODE_CTRLDTCSETTING_MONITOR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeMonitorControlDtcSetting()
 *********************************************************************************************************************/
/*! \brief          Verifies that the DTCsetting auto-recovery condition is not yet met.
 *  \details        -
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_ModeTaskMonitor task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeMonitorControlDtcSetting(Dcm_TskTaskEvPtrType pPostEv);
# endif

# if (DCM_MODE_COMMCTRL_MONITOR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeMonitorCommunicationControl()
 *********************************************************************************************************************/
/*! \brief          Verifies that the CommunicationControl auto-recovery condition is not yet met.
 *  \details        -
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_ModeTaskMonitor task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeMonitorCommunicationControl(Dcm_TskTaskEvPtrType pPostEv);
# endif

/**********************************************************************************************************************
 *  Dcm_ModeInit()
 *********************************************************************************************************************/
/*! \brief          Initializes DCM mode manager sub-module.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts must be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeInit(void);
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON) || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckEcuReset()
 *********************************************************************************************************************/
/*! \brief          Mode switch acknowledgment for an ECU Reset/RapidPowershutDown command.
 *  \details        -
 *  \return         DCM_E_OK - This value is always returned.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckEcuReset(void);
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON) || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchEcuReset()
 *********************************************************************************************************************/
/*! \brief          Mode switching for an ECU Reset/RapidPowershutDown command.
 *  \details        -
 *  \param[in]      mode    The mode
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchEcuReset(Dcm_ResetModeType mode);
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)   || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckResultInterpreter()
 *********************************************************************************************************************/
/*! \brief          Converts a ModeSwitchAck API return value to a DCM standard result.
 *  \details        -
 *  \param[in]      modeSwitchAckResult    The ModeSwitchAck API result
 *  \return         The DCM standard result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckResultInterpreter(Std_ReturnType modeSwitchAckResult);
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckEcuReset()
 *********************************************************************************************************************/
/*! \brief          Mode switch acknowledgment for an ECU reset command.
 *  \details        -
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckEcuReset(void);
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchEcuReset()
 *********************************************************************************************************************/
/*! \brief          Mode switching for an ECU reset command.
 *  \details        -
 *  \param[in]      mode    The mode
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchEcuReset(Rte_ModeType_DcmEcuReset mode);
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckRapidShutDown()
 *********************************************************************************************************************/
/*! \brief          Mode switch acknowledgment for a rapid power shutdown command.
 *  \details        -
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckRapidShutDown(void);
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchRapidShutDown()
 *********************************************************************************************************************/
/*! \brief          Mode switching for an ECU reset rapid shut down command.
 *  \details        -
 *  \param[in]      mode    The mode
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchRapidShutDown(Rte_ModeType_DcmModeRapidPowerShutDown mode);
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_StateInit()
 *********************************************************************************************************************/
/*! \brief          State initialization.
 *  \details        Initialization of the state manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateInit(void);

#if (DCM_STATE_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateExecOnStateChangeFunc()
 *********************************************************************************************************************/
/*! \brief          Executes all registered on state change functions if precondition no more fulfilled.
 *  \details        -
 *  \param[in]      notifList        The notification list
 *  \param[in]      formerStateId    The former state
 *  \param[in]      newStateId       The new state
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateNotificationInfoPtrType notifList
                                                                    ,uint8 formerStateId
                                                                    ,uint8 newStateId);
#endif

#if (DCM_STATE_SECURITY_LOOKUP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateFindStateIndexFromSecLevel()
 *********************************************************************************************************************/
/*! \brief          Map an external state identifier to an internal state index
 *  \details        -
 *  \param[in]      secLevel    The security level (incl. LOCKED)
 *  \return         -1          Not found
 *  \return         >= 0        Internal state index
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint8_least, DCM_CODE) Dcm_StateFindStateIndexFromSecLevel(Dcm_SecLevelType secLevel);
#endif

#if ((DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)  &&  (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON))                                     /* COV_DCM_UNSUPPORTED XF tf xf */
/**********************************************************************************************************************
*  Dcm_StateVsgGetSecurityFixedByteStateIdx()
*********************************************************************************************************************/
/*! \brief         Returns referencs to active security fixed byte
*  \details        Returns a reference to a security fixed byte that is assigned to a active VSG
*  \param[in,out]  pStateIndex      Index to security fixed byte VSG configuration in
*                                   Dcm_CfgStateVsgMaskSecurityFixedByte
*  \return         DCM_E_OK         Operation succeeded
*  \return         DCM_E_NOT_OK     No active security fixed byte available
*  \context        TASK
*  \reentrant      TRUE
*  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateVsgGetSecurityFixedByteStateIdx(
                                                            P2VAR(sint32_least, AUTOMATIC, DCM_APPL_DATA) pStateIndex);
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateGetSecurityLevelFixedBytes()
 *********************************************************************************************************************/
/*! \brief          Provides fixed bytes set up for a specific security level.
 *  \details        This function provides the fixed bytes for the requested security level.
 *                  A security level without configured fixed bytes will return E_OK and no bytes (bufferSize = 0)
 *  \param[in]      secLevel              The requested security level
 *  \param[out]     fixedBytes            Buffer to receive the fixed byte values
 *  \param[in,out]  bufferSize
 *                  IN                    The provided buffer size
 *                  OUT                   The number of fixed bytes for the requested level
 *  \return         E_OK                  The security bytes were copied to the provided buffer
 *  \return         DCM_E_NOT_OK          The security level is not configured
 *  \return         DCM_E_BUFFERTOOLOW    The buffer was too small, bufferSize will contain the number of bytes needed
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateGetSecurityLevelFixedBytes(Dcm_SecLevelType secLevel
                                                                   ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) fixedBytes
                                                                   ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) bufferSize);
#endif

/**********************************************************************************************************************
 *  Dcm_StateNotifyServiceProcessors()
 *********************************************************************************************************************/
/*! \brief          Notifies all related service processors for a state change (of any state group).
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateNotifyServiceProcessors(void);
/**********************************************************************************************************************
 *  Dcm_TskGetTaskInfoOrNull()
 *********************************************************************************************************************/
/*! \brief          Returns a task info element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a task info
 *  \return         Dcm task descriptor entry corresponding to the index
 *  \return         NULL_PTR      On invalid task index (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskInfoPtrType, DCM_CODE) Dcm_TskGetTaskInfoOrNull(Dcm_TskTaskIdOptType index);

/**********************************************************************************************************************
 *  Dcm_TskGetTaskContextOrNull()
 *********************************************************************************************************************/
/*! \brief          Returns a task context element of the given index.
 *  \details        -
 *  \param[in]      taskId    The task ID the context will be returned.
 *  \return         Dcm task context entry corresponding to the index
 *  \return         NULL_PTR      On invalid task index (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskContextPtrType, DCM_CODE) Dcm_TskGetTaskContextOrNull(Dcm_TskTaskIdOptType taskId);

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskRegisterActiveTask()
 *********************************************************************************************************************/
/*! \brief          Registers a task as an active one on top of the task stack.
 *  \details        -
 *  \param[in]      taskId    The task ID to be registered as active.
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE only in case split task is supported.
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskRegisterActiveTask(Dcm_TskTaskIdOptType taskId);
#else
# define Dcm_TskRegisterActiveTask(taskId)                           /* not used */
#endif

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskUnRegisterActiveTask()
 *********************************************************************************************************************/
/*! \brief          Removes an activated task from the task stack.
 *  \details        -
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE only in case split task is supported.
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskUnRegisterActiveTask(void);
#else
# define Dcm_TskUnRegisterActiveTask()                               /* not used */
#endif

/**********************************************************************************************************************
 *  Dcm_TskExecuteActiveTask()
 *********************************************************************************************************************/
/*! \brief          Executes a specific task until all its jobs are finished.
 *  \details        -
 *  \param[in]      taskId    The ID of the task to be executed.
 *  \param[in]      taskEv    A current snapshot of the task's events.
 *  \context        TASK
 *  \reentrant      TRUE only in case split task is supported.
 *  \pre            Must be called only from the Dcm_TskScheduler().
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskExecuteActiveTask(Dcm_TskTaskIdOptType taskId
                                                              ,Dcm_TskTaskEvOptType taskEv);

/**********************************************************************************************************************
 *  Dcm_TskGetSchedulerContextOrNull()
 *********************************************************************************************************************/
/*! \brief          Returns a scheduler context element of the given index.
 *  \details        -
 *  \param[in]      schedulerPrio    Scheduler priority matching to a specific scheduler context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskSchedulerContextPtrType, DCM_CODE) Dcm_TskGetSchedulerContextOrNull(
                                                                                 Dcm_TskTaskPrioOptType schedulerPrio);

/**********************************************************************************************************************
 *  Dcm_TskInit()
 *********************************************************************************************************************/
/*! \brief          Task initialization.
 *  \details        Initialization of the task manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskInit(void);

#if (DCM_TSK_TASK_KILL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskKillAllTasks()
 *********************************************************************************************************************/
/*! \brief          Kills all killable tasks.
 *  \details        Suspends all internal tasks according to their configuration in Dcm_TskTaskInfo[].
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskKillAllTasks(void);
#endif

#if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskReviveAllTasks()
 *********************************************************************************************************************/
/*! \brief          Revives all killed tasks.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            Must be called within a critical section.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskReviveAllTasks(void);
#else
# define Dcm_TskReviveAllTasks()                                     /* not used */
#endif
/**********************************************************************************************************************
 *  Dcm_TmrGetTimerInfoOrNull()
 *********************************************************************************************************************/
/*! \brief          Returns a timer info element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a timer info
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerInfoPtrType, DCM_CODE) Dcm_TmrGetTimerInfoOrNull(Dcm_TmrTimerIdOptType index);

/**********************************************************************************************************************
 *  Dcm_TmrSetTimer()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a timer of the given index.
 *  \details        -
 *  \param[in]      timerId       The ID of the timer to be updated
 *  \param[in]      value         New value of the timer
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TmrSetTimer(Dcm_TmrTimerIdOptType timerId, Dcm_TmrTimerCntrMemType value);

/**********************************************************************************************************************
 *  Dcm_TmrInit()
 *********************************************************************************************************************/
/*! \brief          Timer initialization.
 *  \details        Initialization of the timer manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TmrInit(void);
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DidMgrInitMainResources()
 *********************************************************************************************************************/
/*! \brief          Initializes the DID resource handles.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrInitMainResources(void);

/**********************************************************************************************************************
 *  Dcm_DidMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initializes the DID manager sub-component.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrInit(void);

# if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidRangeGap()
 *********************************************************************************************************************/
/*! \brief          Verifies whether the DID is supported within a range.
 *  \details        -
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pDidInfoContext    The DID configuration configuration context
 *  \return         DCM_E_OK                    Positive look up result
 *  \return         DCM_E_NOT_OK                Negative look up result
 *  \return         DCM_E_LOOKUP_MATCH_FOUND    DID range match, but found a gap
 *  \return         DCM_E_PENDING               Final result is pending, retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidRangeGap(Dcm_OpStatusType          opStatus
                                                                     ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext);
# endif

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDidRangeLookUp()
 *********************************************************************************************************************/
/*! \brief          Searches for the DID in a range to get its corresponding handle (up to 32768 items).
 *  \details        -
 *  \param[in]      opStatus           Current operation status
 *  \param[in,out]  pDidInfoContext    The DID to be found and its context
 *  \param[in]      didOp              The DID operation
 *  \return         DCM_E_OK                    Positive look up result
 *  \return         DCM_E_NOT_OK                Negative look up result
 *  \return         DCM_E_LOOKUP_MATCH_FOUND    DID range match, but found a gap
 *  \return         DCM_E_PENDING               Final result is pending, retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDidRangeLookUp(Dcm_OpStatusType              opStatus
                                                                      ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                      ,Dcm_DidMgrOpOptType             didOp);
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWriteSignal()
 *********************************************************************************************************************/
/*! \brief          Writes a single DID signal for service 0x2E.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode      The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWriteSignal(Dcm_OpStatusType               opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWrite()
 *********************************************************************************************************************/
/*! \brief          Executes the writes of a DID.
 *  \details        Iterates over all signals of a DID.
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode      The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWrite(Dcm_OpStatusType                  opStatus
                                                               ,Dcm_MsgContextPtrType             pMsgContext
                                                               ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                               ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                               ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfoSignal()
 *********************************************************************************************************************/
/*! \brief          Returns a scaling information item of a given DID.
 *  \details        -
 *  \param[in]      opStatus       The operation status
 *  \param[in,out]  pMsgContext    The current request context
 *  \param[in,out]  opFuncInfo     Function pointer info
 *  \param[in]      sigScalingSize The Signal Scaling Size
 *  \param[out]     errorCode      The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfoSignal(Dcm_OpStatusType         opStatus
                                                                    ,Dcm_MsgContextPtrType              pMsgContext
                                                                    ,Dcm_DidMgrSignalOpClassInfoPtrType opFuncInfo
                                                                    ,Dcm_CfgNetBufferSizeMemType        sigScalingSize
                                                                    ,Dcm_NegativeResponseCodePtrType    errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfo()
 *********************************************************************************************************************/
/*! \brief          Returns the scaling information of a given DID.
 *  \details        Iterates over all signals of a DID.
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode          The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfo(Dcm_OpStatusType             opStatus
                                                                  ,Dcm_MsgContextPtrType              pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType    pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType  pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType    errorCode);

# endif

# if (DCM_DIDMGR_OPTYPE_IO_ANY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlSignal()
 *********************************************************************************************************************/
/*! \brief          DID IO control operator
 *  \details        -
 *  \param[in]      opStatus            The operation status
 *  \param[in,out]  pMsgContext         The current request context
 *  \param[in,out]  pDidInfoContext     The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext   The context of the DID operation
 *  \param[out]     errorCode           The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlSignal(Dcm_OpStatusType           opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_IO_ANY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControl()
 *********************************************************************************************************************/
/*! \brief          DID IO control operator
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode          The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControl(Dcm_OpStatusType                  opStatus
                                                                   ,Dcm_MsgContextPtrType             pMsgContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif

# if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_INT_CEMR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlWithMask()
 *********************************************************************************************************************/
/*! \brief          DID IO control with control enable mask record support operator.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode          The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlWithMask(Dcm_OpStatusType         opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2EcuSignal()
 *********************************************************************************************************************/
/*! \brief          Optimized function for ReturnControlToEcu only!
 *  \details        -
 *  \param[in]      opInfoRef    Operation information
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2EcuSignal(
                                                                       Dcm_CfgDidMgrSignalOpClassRefOptType opInfoRef);
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2Ecu()
 *********************************************************************************************************************/
/*! \brief          Optimized function for ReturnControlToEcu only!
 *  \details        -
 *  \param[in]      opInfoRef    Operation information
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetOpFuncInfo()
 *********************************************************************************************************************/
/*! \brief          Returns the operation function information of a given signal.
 *  \details        -
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \return         The corresponding operation function information
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrSignalOpClassInfoPtrType, DCM_CODE) Dcm_DidMgrGetOpFuncInfo(
                                                                  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                 ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext);
# endif

# if (DCM_DIDMGR_OPCLS_READ_RANGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalRange()
 *********************************************************************************************************************/
/*! \brief          Reads a specific DID range.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode          The NRC
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalRange(Dcm_OpStatusType opStatus
                                                                   ,Dcm_DiagDataContextPtrType pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType errorCode);
# endif

# if (DCM_DIDMGR_OPCLS_READ_ASYNC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalAsync()
 *********************************************************************************************************************/
/*! \brief          Reads an asynchronous signal of a DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode          The NRC
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalAsync(Dcm_OpStatusType opStatus
                                                                   ,Dcm_DiagDataContextPtrType pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType errorCode);
# endif

# if (DCM_DIDMGR_OPCLS_READ_SYNC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalSync()
 *********************************************************************************************************************/
/*! \brief          Reads a synchronous signal of a DID.
 *  \details        -
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode          The NRC
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalSync(Dcm_DiagDataContextPtrType pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType errorCode);
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalPaged()
 *********************************************************************************************************************/
/*! \brief          Reads a paged signal of a DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode          The NRC
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalPaged(Dcm_OpStatusType opStatus
                                                                   ,Dcm_DiagDataContextPtrType pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType errorCode);
# endif

# if (DCM_DIDMGR_OPCLS_READ_VID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalVid()
 *********************************************************************************************************************/
/*! \brief          Reads a paged signal of a VID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode          The NRC
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalVid(Dcm_OpStatusType opStatus
                                                                   ,Dcm_DiagDataContextPtrType pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType errorCode);
# endif

# if (DCM_DIDMGR_OPCLS_READ_SR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalSR()
 *********************************************************************************************************************/
/*! \brief          Reads a signal of a DID with a SR interface.
 *  \details        -
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode          The NRC
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalSR(Dcm_DiagDataContextPtrType pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignal()
 *********************************************************************************************************************/
/*! \brief          Reads a signal of a DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode          The NRC
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignal(Dcm_OpStatusType opStatus
                                                                    ,Dcm_DiagDataContextPtrType pDataContext
                                                                    ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                    ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                    ,Dcm_NegativeResponseCodePtrType errorCode);
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) && \
     (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadGap()
 *********************************************************************************************************************/
/*! \brief          Reads a gap signal of a DID.
 *  \details        -
 *  \param[in,out]  pAvailLen          The remaining buffer space
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadGap(Dcm_DiagDataContextPtrType pDataContext
                                                                 ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                 ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadLengthSignal()
 *********************************************************************************************************************/
/*! \brief          Returns the length of a signal.
 *  \details        Reads the length of a specific signal of a DID.
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[out]     pResLength         The returned length
 *  \param[out]     errorCode          The error code
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLengthSignal(Dcm_OpStatusType                opStatus
                                                                       ,Dcm_DidMgrDidInfoContextPtrType    pDidInfoContext
                                                                       ,Dcm_DidMgrDidLengthPtrType         pResLength
                                                                       ,Dcm_NegativeResponseCodePtrType    errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadCheckCondSignal()
 *********************************************************************************************************************/
/*! \brief          Reads the check condition of a specific signal of a DID.
 *  \details        -
 *  \param[in]      opStatus      The operation status
 *  \param[in,out]  opFuncInfo    Function pointer info
 *  \param[out]     errorCode     The errorCode to be returned
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadCheckCondSignal(Dcm_OpStatusType              opStatus
                                                                        ,Dcm_DidMgrSignalOpClassInfoPtrType opFuncInfo
                                                                        ,Dcm_NegativeResponseCodePtrType    errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetSignalLength()
 *********************************************************************************************************************/
/*! \brief          Returns the length of the current signal.
 *  \details        -
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetSignalLength(
                                                                Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                               ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext);
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) && \
     (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetGapRemainingLen()
 *********************************************************************************************************************/
/*! \brief          Returns the length of the current gap signal.
 *  \details        -
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetGapRemainingLen(
                                                                      Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                     ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext);
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidLookUp()
 *********************************************************************************************************************/
/*! \brief          Verifies whether a supported DID is currently enabled for a specific DID operation.
 *  \details        -
 *  \param[in]      pDidInfoContext    The DID configuration information
 *  \param[in]      didOp          The lookup DID operation context
 *  \return         DCM_E_OK       Positive look up result
 *  \return         DCM_E_NOT_OK   Negative look up result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidLookUp(
                                                                        Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                       ,Dcm_DidMgrOpOptType             didOp);

/**********************************************************************************************************************
 *  Dcm_DidMgrConcreteDidLookUp()
 *********************************************************************************************************************/
/*! \brief          Look up for a concrete DID number (no range)
 *  \details        -
 *  \param[in]      pDidInfoContext    The DID configuration configuration context
 *  \param[in]      didOp              The lookup DID operation context
 *  \return         DCM_E_OK      Positive look up result
 *  \return         DCM_E_NOT_OK  Negative look up result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrConcreteDidLookUp(
                                                                        Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                       ,Dcm_DidMgrOpOptType             didOp);

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) && \
     (DCM_DIDMGR_MSIG_OPTYPE_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadPagedMultiSignal()
 *********************************************************************************************************************/
/*! \brief          Reads all signals for a specific DID using the paged-buffer.
 *  \details        -
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The DID configuration configuration context
 *  \param[in,out]  pDidOpTypeContext  The DID operation context
 *  \param[out]     errorCode          The NRC
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadPagedMultiSignal(Dcm_DiagDataContextPtrType pDataContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_CfgRidMgrOpInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get operation descriptor
 *  \details        -
 *  \param[in]      ridOpInfoIdx   Index to a operation descriptor of a RID operation
 *  \return         Operation descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RidMgrOpInfoPtrType, DCM_CODE) Dcm_CfgRidMgrOpInfoGetEntryOrNull(Dcm_CfgRidMgrOpHandleOptType ridOpInfoIdx);

/**********************************************************************************************************************
 *  Dcm_RidMgrExecuteRoutine()
 *********************************************************************************************************************/
/*! \brief          Executes a routine operation.
 *  \details        -
 *  \param[in]      opStatus       The operations status
 *  \param[in]      pMsgContext    Current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrExecuteRoutine(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc31RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_RidMgrGetOpInfo()
 *********************************************************************************************************************/
/*! \brief          Returns the operation descriptor of a RID operation.
 *  \details        -
 *  \param[in]      ridInfoIdx       Index to the RID info object
 *  \param[in]      ridOp            The requested operation
 *  \param[out]     pRidOpInfoIdx    Operation result
 *  \return         DCM_E_OK         Returning descriptor is successful
 *  \return         DCM_E_NOT_OK     Returning descriptor is not successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrGetOpInfo(Dcm_CfgRidMgrInfoHandleOptType ridInfoIdx
                                                                   ,Dcm_RidMgrOpType ridOp
                                                                   ,Dcm_CfgRidMgrOpHandlePtrType pRidOpInfoIdx);

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUp()
 *********************************************************************************************************************/
/*! \brief          Looks for the RID to get its corresponding RID information reference.
 *  \details        -
 *  \param[in]      opStatus        The operations status
 *  \param[in]      rid             The RID to be found
 *  \param[in,out]  pRidInfo        Index to the RID information in the configuration table
 *  \return         DCM_E_NOT_OK    No RID has been found
 *  \return         DCM_E_OK        Look up success
 *  \return         DCM_E_PENDING   Look up result is pending, try again
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUp(Dcm_OpStatusType opStatus
                                                                   ,uint16 rid
                                                                   ,Dcm_CfgRidMgrInfoHandlePtrType pRidInfoIdx);

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUpFilter()
 *********************************************************************************************************************/
/*! \brief          A RID look up result filter.
 *  \details        -
 *  \param[in]      rid             The RID to be found
 *  \param[in]      ridInfo         Index to the RID information
 *  \return         DCM_E_NOT_OK    No RID has been found
 *  \return         DCM_E_OK        Look up success
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUpFilter(uint16 rid
                                                                         , Dcm_CfgRidMgrInfoHandleOptType ridInfoIdx);
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrSetNextStep()
 *********************************************************************************************************************/
/*! \brief          Set next progress step
 *  \details        -
 *  \param[in]      NextStep         Next step to be processed by local Repeater
 *  \param[in,out]  pRepContext      Current repeater proxy context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ObdDtcMgrSetNextStep(Dcm_RepeaterProgressType NextStep
                                                              ,Dcm_ObdDtcManagerContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrGetNextStep()
 *********************************************************************************************************************/
/*! \brief          Get next progress step
 *  \details        -
 *  \return         Next step to be processed by local Repeater
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RepeaterProgressType, DCM_CODE) Dcm_ObdDtcMgrGetNextStep(
                                                                          Dcm_ObdDtcManagerContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Calls the GetNumberOfFilteredDTC function.
 *  \param[in]      opStatus                The operation status
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Stop Repeater Proxy
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrDemGetNumFltrdDtc(Dcm_OpStatusType opStatus
                                                                          ,Dcm_MsgContextPtrType pMsgContext                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                          ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                          ,Dcm_ObdDtcManagerContextPtrType pRepContext);

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCopyLinearData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Copies some linear data.
 *  \param[in]      opStatus                The operation status
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCopyLinearData(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_ObdDtcManagerContextPtrType pRepContext);
# endif
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_DiagSetNewReqBaseToCurProgress()
 *********************************************************************************************************************/
/*! \brief          Sets the request context base to the current progress.
 *  \details        Updates all request related members to an initial value, starting with buffer that skips the already
 *                  consumed request bytes.
 *  \param[in,out]  pMsgContext   Current message context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewReqBaseToCurProgress(Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_DiagSetQueuedTranspObj()
 *********************************************************************************************************************/
/*! \brief          Setter of the transport object carrying the diagnostic request to be processed at next
 *                  Dcm_DiagTaskWorker() activation
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM external/internal connection
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetQueuedTranspObj(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_DiagSetNewResBaseToCurProgress()
 *********************************************************************************************************************/
/*! \brief          Sets the response context base to the current progress.
 *  \details        Updates all response related members to an initial value, starting with buffer that skips the already
 *                  provided response bytes.
 *  \param[in,out]  pMsgContext   Current message context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewResBaseToCurProgress(Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessorFunc()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to a post-processor function of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a post-processor function
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcConfirmationFuncType, DCM_CODE) Dcm_DiagGetPostProcessorFunc(uint8 index);

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetUpdateFunc()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to an update function of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to an update function
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcUpdateFuncType, DCM_CODE) Dcm_DiagGetUpdateFunc(uint8 index);
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetCancelFunc()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to a cancellation function of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a cancellation function
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcCancelFuncType, DCM_CODE) Dcm_DiagGetCancelFunc(uint8 index);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagInit()
 *********************************************************************************************************************/
/*! \brief          Initializes DCM diagnostic sub-module.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts must be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInit(void);

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagPutStartUpFblResBuffer()
 *********************************************************************************************************************/
/*! \brief          Writes into the global start up FBL response buffer.
 *  \details        -
 *  \param[in]      index         Index to the start up FBL response buffer
 *  \param[in]      value         New value of the start up FBL response buffer
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagPutStartUpFblResBuffer(uint8 index, Dcm_MsgItemType value);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagAcceptNewRequest()
 *********************************************************************************************************************/
/*! \brief          Checks whether a new request will be accepted.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM USDT connection
 *  \return         TRUE          New request is accepted
 *  \return         FALSE         New request is not accepted
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DiagAcceptNewRequest(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_DiagOnTxFinished()
 *********************************************************************************************************************/
/*! \brief          Notifies the diagnostic sub-module that an ongoing transmission just finished.
 *  \details        Called by the TP once an ongoing transmission is finished.
 *  \param[in]      pTranspObj    Currently active DCM USDT connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagOnTxFinished(Dcm_NetTransportObjectPtrType pTranspObj
                                                          ,Dcm_NetTransmissionResultType txStatus);

#if(DCM_DIAG_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagExecConfirmationFunc()
 *********************************************************************************************************************/
/*! \brief          Executes a confirmation callback and evaluates its return values.
 *  \details        -
 *  \param[in]      notifList     The diagnostic request confirmation list to be executed
 *  \param[in]      confStatus    The post-processing status
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            The last element of the passed notifList must be marked by NULL_PTR.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagExecConfirmationFunc(Dcm_CfgDiagNotificationInfoPtrType notifList
                                                                  ,Dcm_ConfirmationStatusType confStatus);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessResult()
 *********************************************************************************************************************/
/*! \brief          Calculates the Dcm_ConfirmationType value for the post processors.
 *  \details        -
 *  \return         The confirmation status
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_ConfirmationStatusType, DCM_CODE) Dcm_DiagGetPostProcessResult(void);

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoverySignature()
 *********************************************************************************************************************/
/*! \brief          Composes the recovery information control check-sum signature.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_DiagGetRecoverySignature(void);
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagProvideRecoveryStates()
 *********************************************************************************************************************/
/*! \brief          Takes the restored DCM state over.
 *  \details        Takes the external stored and recovered DCM state over.
 *  \param[in,out]  RecoveryInfo    Reference to structure that stores recovery info
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagProvideRecoveryStates(
                                                   P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo);
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagProcessRecoveryInfo()
 *********************************************************************************************************************/
/*! \brief          Takes the restored DCM state over.
 *  \details        Takes the external stored and recovered DCM state over.
 *  \param[in,out]  RecoveryInfo    Reference to structure that stores recovery info
 *  \param[in]      opStatus        Current operation status
 *  \context        TASK
 *  \return         DCM_E_OK        Processing succeeded
 *  \return         DCM_E_PENDING   Disable DTC API call is pending
 *  \return         DCM_E_NOT_OK    Disable DTC API call failed
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagProcessRecoveryInfo(
                                                P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo
                                               ,Dcm_OpStatusType opStatus);
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagSafeProcessRecoveryInfo()
 *********************************************************************************************************************/
/*! \brief          Checks and takes the restored DCM state over.
 *  \details        Checks and takes the external stored and recovered DCM state over.
 *  \param[in,out]  RecoveryInfo    Reference to structure that stores recovery info
 *  \param[in]      opStatus        Current operation status
 *  \context        TASK
 *  \return         DCM_E_OK        Processing succeeded
 *  \return         DCM_E_PENDING   Disable DTC API call is pending
 *  \return         DCM_E_NOT_OK    Processing failed
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSafeProcessRecoveryInfo(
                                                 P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo
                                                ,Dcm_OpStatusType opStatus);
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcCancelOpenJobs()
 *********************************************************************************************************************/
/*! \brief          Cancel open diagnostic jobs
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcCancelOpenJobs(void);
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcReviveKilledTasks()
 *********************************************************************************************************************/
/*! \brief          Revive tasks that were killed during cancellation
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcReviveKilledTasks(void);
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcessing()
 *********************************************************************************************************************/
/*! \brief          Performs diagnostic job cancellation.
 *  \details        If a diagnostic job is ongoing the appropriate action will be taken to close it deterministically.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerDoCancelProcessing(Dcm_TskTaskEvOptType ev
                                                                                      ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoPostProcessing()
 *********************************************************************************************************************/
/*! \brief          Performs post processing of currently finished request.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoPostProcessing(void);

/**********************************************************************************************************************
 *  Dcm_DiagWorkerSetDefSessionExtern()
 *********************************************************************************************************************/
/*! \brief          Performs session transition to the default session on external request.
 *  \details        Synchronizes an external session change request with the internal DCM state. If a diagnostic job is
 *                  still in processing, the session change request will be postponed till the job is finished. This is
 *                  required in order to guarantee clean sequence flow on session change and active diagnostic jobs.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerSetDefSessionExtern(Dcm_TskTaskEvOptType ev
                                                                                       ,Dcm_TskTaskEvPtrType pPostEv);

/**********************************************************************************************************************
 *  Dcm_DiagSwitchProcessingContext()
 *********************************************************************************************************************/
/*! \brief          Performs a context switch of the current working serivice processing set
 *  \details        -
 *  \context        TASK
 *  \return         DCM_E_OK                Initialization succeeded, proceed with next step
 *  \return         DCM_E_NOT_OK            Initialization failed, repeat again next time
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSwitchProcessingContext(void);

/**********************************************************************************************************************
 *  Dcm_DiagInitiateServiceProcessing()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic kernel for new request processing.
 *  \details        -
 *  \param[in,out]  pMsgContext             Current request context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *  \note          The parameter pMsgContext is passed to this function for initialization.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInitiateServiceProcessing(Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_DiagHandleSuppressBit()
 *********************************************************************************************************************/
/*! \brief          Handles the SPRMIB if set and supported by the requested service.
 *  \details        -
 *  \param[in]      pTranspObj     The transport object
 *  \param[in,out]  pMsgContext    Current request context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagHandleSuppressBit(Dcm_NetTransportObjectPtrType pTranspObj
                                                               ,Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_DiagValidateAndDispatchService()
 *********************************************************************************************************************/
/*! \brief          Validates received SID and dispatches further processing.
 *  \details        -
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The error code to be returned
 *  \return         DCM_E_OK                Validation succeeded. Initiate recognized service processing
 *  \return         DCM_E_NOT_OK            Validation failed. Finish service processing with the ErrorCode result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Dcm_DiagInitiateServiceProcessing() shall be called first.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagValidateAndDispatchService(
                                                                           Dcm_MsgContextPtrType           pMsgContext
                                                                          ,Dcm_NegativeResponseCodePtrType ErrorCode);

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessNewRequest()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic service processing once a new request is received.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerProcessNewRequest(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pPostEv);

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessRcrRpTxEnd()
 *********************************************************************************************************************/
/*! \brief          Prepares for application notification after enforced RCR-RP transmission.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerProcessRcrRpTxEnd(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pPostEv);

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON) && \
    (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerCancelOperation()
 *********************************************************************************************************************/
/*! \brief          Cancels any ongoing diagnostic operation.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerCancelOperation(Dcm_TskTaskEvOptType ev
                                                                                   ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoRepeat()
 *********************************************************************************************************************/
/*! \brief          Triggers a scheduled diagnostic job activity.
 *  \details        Each registered diagnostic job activity will be called out from this point.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerDoRepeat(Dcm_TskTaskEvOptType ev
                                                                            ,Dcm_TskTaskEvPtrType pPostEv);

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoGetProgCond()
 *********************************************************************************************************************/
/*! \brief          Gets the programming conditions from FBL/Application.
 *  \details        Checks and takes the external stored and recovered DCM state over.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskFblRes task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskFblRes task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskFblRes task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoGetProgCond(Dcm_TskTaskEvOptType ev
                                                                                 ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoWaitTxComm()
 *********************************************************************************************************************/
/*! \brief          Waits until the ComM has processed the DCM communication request.
 *  \details        Waits for either P2Star timeout of ComM acknowledge of channel wake up.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskFblRes task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskFblRes task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskFblRes task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoWaitTxComm(Dcm_TskTaskEvOptType ev
                                                                                ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoResetFlags()
 *********************************************************************************************************************/
/*! \brief          Resets all FBL flags.
 *  \details        Resets all FBL related flags so at next power-on/reset no final response to be sent.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskFblRes task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskFblRes task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskFblRes task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoResetFlags(Dcm_TskTaskEvOptType ev
                                                                                ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoProcessTxConfirmation()
 *********************************************************************************************************************/
/*! \brief          Performs a session transition after a final positive response.
 *  \details        If the final response was for SID 0x10, the corresponding session transition is performed here.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskFblRes task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskFblRes task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskFblRes task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoProcessTxConfirmation(Dcm_TskTaskEvOptType ev
                                                                                           ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagTxPostponeFinalPagedResponse()
 *********************************************************************************************************************/
/*! \brief          Postpones the diagnostic service final response transmission if paged-buffer used
 *  \details        The postponing is required only if the SPRMIB was set. Since the SPMRIB=TRUE means
 *                  "execute job, but do not send a response", in the case of paged-buffer the response is sent during
 *                  the "job execution". So if the P2 time is exceeded while performing the job, the final response may
 *                  not be able to provide all of the response data (the previous data pages are already lost)
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskTx task.
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagTxPostponeFinalPagedResponse(
                                                                                   Dcm_TskTaskEvOptType ev
                                                                                  ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTxStartFinalResponse()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic service final response transmission
 *  \details        -
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskTx task.
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagTxStartFinalResponse(Dcm_TskTaskEvOptType ev
                                                                                  ,Dcm_TskTaskEvPtrType pPostEv);

/**********************************************************************************************************************
 *  Dcm_DiagTxStartRcrRpResponse()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic service RCR-RP response transmission
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxStartRcrRpResponse(void);
#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Initialization of variant manager sub-module.
 *  \param[in]      configPtr    Pointer to a concrete configuration root
 *  \return         TRUE         Configuration root pointer is valid
 *  \return         FALSE        Configuration root pointer is invalid
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_VarMgrInit(Dcm_ConfigPtrType configPtr);
#endif

#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON) && \
    (DCM_DEV_RAM_SHREDDER_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF tf xf */
/**********************************************************************************************************************
 *  Dcm_VarMgrRamShredder()
 *********************************************************************************************************************/
/*! \brief          Destroys default global memory content by a pattern for test purposes.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrRamShredder(void);
#else
# define Dcm_VarMgrRamShredder()                                     /* not used */
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VarMgrInitActiveCfgVariants()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Initialization of variant manager ActiveCfgVariants global variable.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrInitActiveCfgVariants(void);
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VarMgrVsgSetSingle()
 *********************************************************************************************************************/
/*! \brief          Sets the status of a single VSG
 *  \details        -
 *  \param[in]      VsgId         Unique handle of the VSG.
 *  \param[in]      State         DCM_VSG_ENABLED:  Set VSG to active
 *                                DCM_VSG_DISABLED: Set VSG to inactive
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrVsgSetSingle(Dcm_VsgIdentifierType VsgId, Dcm_VsgStateType State);
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VarMgrVsgIsActive()
 *********************************************************************************************************************/
/*! \brief          Returns status of a single VSG
 *  \details        -
 *  \param[in]      VsgId         Unique handle of the VSG.
 *  \param[out]     State         DCM_VSG_ENABLED:  VSG is active
 *                                DCM_VSG_DISABLED: VSG is inactive
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrVsgIsActive(Dcm_VsgIdentifierType VsgId
                                                           ,P2VAR(Dcm_VsgStateType, AUTOMATIC, DCM_APPL_DATA) State);
#endif
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc02ReadPidData()
 *********************************************************************************************************************/
/*! \brief          Reads a single valid PID data.
 *  \details        -
 *  \param[in]      pid          The PID which data shall be read.
 *  \param[in,out]  pMsgContext  The message context.
 *  \param[in]      maskValue    AID mask value
 *  \return         1            PID successfully read.
 *  \return         0            PID reading failed/skipped.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint8, DCM_CODE) Dcm_Svc02ReadPidData(uint8 pid, Dcm_MsgContextPtrType pMsgContext, uint32 maskValue);
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc04Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x04 Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04Handler(Dcm_OpStatusType                     opStatus
                                                                ,Dcm_MsgContextPtrType                pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                ,Dcm_Svc04RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc04_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x04 worker.
 *  \details        Calls the ClearDTC function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04_XX_RepeaterProxy(Dcm_OpStatusType                opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc04RepeaterProxyContextPtrType pRepContext);

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc04_XX_RepeaterProxy_SelectDTC()
 *********************************************************************************************************************/
/*! \brief          Service 0x04 worker.
 *  \details        Calls the ClearDTC function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04_XX_RepeaterProxy_SelectDTC(Dcm_OpStatusType      opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc04RepeaterProxyContextPtrType pRepContext);
# endif
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_Service06Process_SupportedMid()
 *********************************************************************************************************************/
/*! \brief          Process handling of Supported MIDs (0x00, 0x20, 0x40...)
 *  \details        -
 *  \param[in,out]  pMsgContext             The current request context
 *  \param[out]     errorCode               Negative response code
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service06Process_SupportedMid(Dcm_MsgContextPtrType pMsgContext
                                                                           ,Dcm_NegativeResponseCodePtrType errorCode);

/**********************************************************************************************************************
 *  Dcm_Service06Process_SingleMid()
 *********************************************************************************************************************/
/*! \brief          Process handling of single MID request
 *  \details        -
 *  \param[in,out]  pMsgContext             The current request context
 *  \param[out]     errorCode               Negative response code
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service06Process_SingleMid(Dcm_MsgContextPtrType pMsgContext
                                                                           ,Dcm_NegativeResponseCodePtrType errorCode);
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc09Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x09 Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc09RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc09_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x09 worker
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc09RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForResetAck()
 *********************************************************************************************************************/
/*! \brief          Wait for Ecu Reset acknowledgment
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_FORCE_RCRRP       Enforce a RCR-RP transmission
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_NOT_OK            Operation failed, send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForResetAck(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
#  if (DCM_DIAG_RCRRP_ON_BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForRcrRpAck()
 *********************************************************************************************************************/
/*! \brief          Wait for RCR-RP acknowledgment
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_NOT_OK            Operation failed, send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForRcrRpAck(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext);
#  endif
# endif

# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_SetProgConditions()
 *********************************************************************************************************************/
/*! \brief          Sets programming conditions
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Trigger to stop repeater (programming conditions set)
 *  \return         DCM_E_NOT_OK            Operation failed, send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_SetProgConditions(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc10Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x10 Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send final positive response
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_NOT_OK            Operation failed
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc11SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor
 *  \details        -
 *  \param[in]      SubSvcRef      Index to a subfunction descriptor
 *  \return         Subfunction descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc11SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc11SubFuncInfoGetEntryOrNull(
                                                                              Dcm_DiagSubServiceRefOptType SubSvcRef);

/**********************************************************************************************************************
 *  Dcm_Svc11Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc11SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 SubFunction Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11SubFuncHandler(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext);

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_EcuRst_WaitForAck()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 repeater.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_EcuRst_WaitForAck(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_RapPwrDwn_WaitForAck()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 repeater.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_RapPwrDwn_WaitForAck(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext);
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x14 Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14Handler(Dcm_OpStatusType                     opStatus
                                                                ,Dcm_MsgContextPtrType                pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x14 worker.
 *  \details        Calls the ClearDTC function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send positive response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxy(Dcm_OpStatusType               opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext);

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxySelectDTC()
 *********************************************************************************************************************/
/*! \brief          Service 0x14 worker.
 *  \details        Calls the SelectDTC function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxySelectDTC(
                                                                      Dcm_OpStatusType                     opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext);                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
# endif

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxyCheckSelectionResult()
 *********************************************************************************************************************/
/*! \brief          Service 0x14 worker.
 *  \details        Calls the GetDTCSelectionResult function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxyCheckSelectionResult(
                                                                      Dcm_OpStatusType                     opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext);                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
# endif
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc19SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Gets a subfunction descriptor for service 0x19
 *  \details        -
 *  \param[in]      SubSvcRef      Index to a subfunction descriptor
 *  \return         Subfunction descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc19SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc19SubFuncInfoGetEntryOrNull(
                                                                              Dcm_DiagSubServiceRefOptType SubSvcRef);

/**********************************************************************************************************************
 *  Dcm_Svc19Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x19 Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19Handler(Dcm_OpStatusType                     opStatus
                                                                ,Dcm_MsgContextPtrType                pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc19SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x19 SubFunction Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19SubFuncHandler(Dcm_OpStatusType                 opStatus
                                                                   ,Dcm_MsgContextPtrType                pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                   ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectDTC()
 *********************************************************************************************************************/
/*! \brief          Wrapper function for Dem_SelectDTC API.
 *  \details        Performs the DTC selection using the respective DEM API.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Selection API never fails
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectDTC(Dcm_OpStatusType                  opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_SETDTCFILTER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*! \brief          Wrapper function for Dem_SetDTCFilter API.
 *  \details        Sets the DTC filter using the respective DEM API.
 *  \param[out]     ErrorCode               The NRC
 *  \param[in]      DsfClass                DEM SetFilter class type
 *  \param[in]      DtcStatusMask           DTC status mask
 *  \param[in]      DtcSeverityMask         DTC severity mask
 *  \param[in]      FilterForFDC            Filter for fault detection counter
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Filter successully set
 *  \return         DCM_E_OK                Setting filter failed
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSetDTCFilter(
                                                                   Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                  ,Dcm_Svc19DemSetFilterClassType       DsfClass
                                                                  ,uint8                                DtcStatusMask
                                                                  ,Dem_DTCSeverityType                  DtcSeverityMask
                                                                  ,Dcm_DemFilterForFDCType              FilterForFDC
                                                                  ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);

# endif

# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Sv19UtiStartReporting()
 *********************************************************************************************************************/
/*! \brief          Dispatches the current update job to the corresponding sub-updater function.
 *  \details        This is shared utility function of the Repeater and PagedBuffer.
 *  \param[in]      subUpdater      The reporting engine to be invoked
 *  \param[in]      reportSize      Calculated report size (used only for paged buffer)
 *  \param[in,out]  pRepContext     Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Let the page-buffer do the job
 *  \return         DCM_E_OK                Send response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Sv19UtiStartReporting(uint8                           subUpdater
                                                                    ,Dcm_MsgLenType                       reportSize
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_ABSTRACT_RECORD_ITER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Sv19UtiRecordIterNext()
 *********************************************************************************************************************/
/*! \brief          Returns the next DTC record or end of iteration result
 *  \details        -
 *  \param[in,out]  pRepContext     Current repeater proxy context
 *  \return         DCM_SVC19_UTI_REC_ITER_RSLT_OK                Next record has been found
 *  \return         DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS   End of iteration (record ID shall not be evaluated from now on)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            A non-empty list of records has to be passed to this utility
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc19UtiRecordIterResultType, DCM_CODE) Dcm_Svc19UtiRecordIterNext(
                                                                     Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19UtiCopyData()
 *********************************************************************************************************************/
/*! \brief          Dispatches the current update job to the corresponding sub-updater function.
 *  \details        This is shared utility function of the Repeater and PagedBuffer.
 *  \param[in,out]  pDataContext    Pointer to the data context
 *  \param[out]     ErrorCode       The NRC
 *  \param[in,out]  pRepContext     Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available room any more
 *  \return         DCM_E_NOT_OK                Error occured
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service19UtiCopyData(Dcm_DiagDataContextPtrType       pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_COPY_LINEAR_DATA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyLinearData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Utility to copy linear data.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyLinearData(Dcm_OpStatusType                opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemDisableRecordUpdate()
 *********************************************************************************************************************/
/*! \brief          Disables the update of records of a particular DTC.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemDisableRecordUpdate(Dcm_OpStatusType       opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETSTATUSOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetStatusOfDtc()
 *********************************************************************************************************************/
/*! \brief          Reads the DTC status bits.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetStatusOfDtc(Dcm_OpStatusType            opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFFFRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfFFRecord()
 *********************************************************************************************************************/
/*! \brief          Calculates the size of one or multiple freeze-frame data record(s).
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Let the page-buffer do the job
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfFFRecord(Dcm_OpStatusType         opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEM_API_SELECT_EDR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectExtRecord()
 *********************************************************************************************************************/
/*! \brief          Selects the extended data record(s).
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Let the page-buffer do the job
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectExtRecord(Dcm_OpStatusType           opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFEXTRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfExtRecord()
 *********************************************************************************************************************/
/*! \brief          Calculates the size of one or multiple extended data record(s).
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Let the page-buffer do the job
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfExtRecord(Dcm_OpStatusType        opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETNUMFILTEREDDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          Retrieves the number of filtered DTCs.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNumFltrdDtc(Dcm_OpStatusType            opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          Initiates reading filtered DTCs severity.
 *  \details        Depending of enabled/disabled paged buffer, starts corresponding reporting process.
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER       Stop polling
 *  \return         DCM_E_LOOP                Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdSeverity(Dcm_OpStatusType       opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSeverityOfDtc()
 *********************************************************************************************************************/
/*! \brief          Reads the next filtered DTCs severity.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSeverityOfDtc(Dcm_OpStatusType          opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetFuncUnitOfDtc()
 *********************************************************************************************************************/
/*! \brief          Reads the functional unit of the requested DTC.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetFuncUnitOfDtc(Dcm_OpStatusType          opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);

# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          Read the next filtered DTC and its status mask.
 *  \details        -
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available room any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \return         DCM_E_NOT_OK                Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdDtc(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEM_API_SELECT_FFR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectFFData()
 *********************************************************************************************************************/
/*! \brief          Selects a freeze-frame data record.
 *  \details        -
 *  \param[in,out]  pRepContext           Current repeater proxy context
 *  \return         DCM_E_LOOP            Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectFFData(
                                                                      Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetFFRecord()
 *********************************************************************************************************************/
/*! \brief          Read the next DTCs freeze-frame data record.
 *  \details        -
 *  \param[in,out]  pDataContext          Pointer to the data context
 *  \param[out]     ErrorCode             The NRC
 *  \param[in,out]  pRepContext           Current repeater proxy context
 *  \return         DCM_E_OK              All data copied
 *  \return         DCM_E_PENDING         Retry later
 *  \return         DCM_E_BUFFERTOOLOW    Retry later, because of no available room any more
 *  \return         DCM_E_NOT_OK          Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetFFRecord(Dcm_DiagDataContextPtrType  pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*! \brief          Initiates reading filtered DTCs FDC.
 *  \details        Depending of enabled/disabled paged buffer, starts corresponding reporting process.
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER       Stop polling
 *  \return         DCM_E_LOOP                Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdFDC(Dcm_OpStatusType            opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          Initiates reading filtered DTCs status mask.
 *  \details        Depending of enabled/disabled paged buffer, starts corresponding reporting process.
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Stop polling
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          Initiates reading filtered DTCs status mask.
 *  \details        Depending of enabled/disabled paged buffer, starts corresponding reporting process.
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER       All data copied
 *  \return         DCM_E_LOOP                Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdDtc(Dcm_OpStatusType            opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiPutNumFilteredDtc()
 *********************************************************************************************************************/
/*! \brief          Write caclucalted by DEM number of filtered DTCs into the response buffer.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                This value is always returned
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiPutNumFilteredDtc(Dcm_OpStatusType           opStatus
                                                                   ,Dcm_MsgContextPtrType                pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                   ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Calls the GetNextFilteredDTCAndSeverity function.
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available room any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Calls the GetNextFilteredDTCAndSeverity function.
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available room any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \return         DCM_E_NOT_OK                Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdRecord()
 *********************************************************************************************************************/
/*! \brief          Read the next filtered DTC and its record number.
 *  \details        -
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available room any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \return         DCM_E_NOT_OK                Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdRecord(
                                                                    Dcm_DiagDataContextPtrType           pDataContext
                                                                   ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                   ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetExtRecord()
 *********************************************************************************************************************/
/*! \brief          Read the next DTCs extended data record.
 *  \details        -
 *  \param[in,out]  pDataContext          Pointer to the data context
 *  \param[out]     ErrorCode             The NRC
 *  \param[in,out]  pRepContext           Current repeater proxy context
 *  \return         DCM_E_OK              All data copied
 *  \return         DCM_E_PENDING         Retry later
 *  \return         DCM_E_BUFFERTOOLOW    Retry later, because of no available room any more
 *  \return         DCM_E_NOT_OK          Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetExtRecord(Dcm_DiagDataContextPtrType pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc22Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x22 Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext);

# if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *   Dcm_Svc22IsDidAccessible()
 *********************************************************************************************************************/
/*! \brief          Checks whether service 0x22 is accessible.
 *  \details        Checks whether the service 0x22 functionality is locked by service 0x2A or 0x2C.
 *  \param[in,out]  pDidInfoContext    The context of the DID
 *  \return         TRUE     Service 0x22 functionality is free
 *  \return         FALSE    Service 0x22 functionality is not free
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc22IsDidAccessible(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext);
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_Svc22CopyLinearData()
 *********************************************************************************************************************/
/*! \brief          Manages the data collection for service 0x22.
 *  \details        Collects the data related to service 0x22 from the application by using the linear buffer.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force NRC 0x78
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CopyLinearData(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CopyPagedDataInit()
 *********************************************************************************************************************/
/*! \brief          Initializes the data collection for service 0x22.
 *  \details        Initializes the data related to service 0x22 from the application by using the paged-buffer.
 *  \param[in,out]  pDataContext          Pointer to the data context
 *  \param[in,out]  pRepContext           Service 0x22 repeater context
 *  \return         DCM_E_OK              All data has been copied
 *  \return         DCM_E_PENDING         No result yet, retry later
 *  \return         DCM_E_BUFFERTOOLOW    Some data copied but no place, retry later on TP buffer under-run
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CopyPagedDataInit(Dcm_DiagDataContextPtrType     pDataContext
                                                                    ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22ReadDidPaged()
 *********************************************************************************************************************/
/*! \brief          Reads a single paged DID for service 0x22.
 *  \details        -
 *  \param[in,out]  pDataContext          Pointer to the data context
 *  \param[out]     ErrorCode             The NRC
 *  \param[in,out]  pRepContext           Service 0x22 repeater context
 *  \return         DCM_E_OK              All data has been copied
 *  \return         DCM_E_PENDING         No result yet, retry later
 *  \return         DCM_E_BUFFERTOOLOW    Some data copied but no place, retry later on TP buffer under-run
 *  \return         DCM_E_NOT_OK          The DID reading has failed for some reason. NRC is already set.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadDidPaged(Dcm_DiagDataContextPtrType           pDataContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc22DidLookUp()
 *********************************************************************************************************************/
/*! \brief          A generic DID look-up for SID 0x22.
 *  \details        Performs a lookup for a specific DID on any request.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22DidLookUp(Dcm_OpStatusType      opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext);

# if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Checks the service 0x22 access.
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CheckAccess(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CheckCondition()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Checks the conditions of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CheckCondition(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc22GetLength()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Reads the length of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22GetLength(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc22ReadData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Reads the data of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force RCR-RP
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadData(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc23Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x23 Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc23RepeaterProxyContextPtrType pRepContext);

# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc23CheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x23.
 *  \details        Checks the service 0x23 access.
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in,out]  pRepContext      Current repeater proxy context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23CheckAccess(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc23RepeaterProxyContextPtrType pRepContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc23ReadMemory()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x23.
 *  \details        Reads the data from the memory.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force RCR-RP
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23ReadMemory(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc23RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc24Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc24RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc24ExecuteOp()
 *********************************************************************************************************************/
/*! \brief          Service 0x24 operation execution unit.
 *  \details        Executes a specific service 0x24 operation.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24ExecuteOp(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc24RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc24DidLookUp()
 *********************************************************************************************************************/
/*! \brief          Service 0x24 DID look up client.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Stop polling
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24DidLookUp(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc24RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc27SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      SubSvcRef      Index to a subfunction descriptor
 *  \return         Subfunction descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc27SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc27SubFuncInfoGetEntryOrNull(
                                                                              Dcm_DiagSubServiceRefOptType SubSvcRef);

/**********************************************************************************************************************
 *  Dcm_CfgSvc27SecLevelInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get security level descriptor.
 *  \details        -
 *  \param[in]      secLev      Zero based security level index
 *  \return         Security level descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc27SecLevelInfoPtrType, DCM_CODE) Dcm_CfgSvc27SecLevelInfoGetEntryOrNull(
                                                                                                   uint8_least secLev);

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27CounterSet()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a specific security level attempt counter.
 *  \details        -
 *  \param[in]      secLev      Zero based security level index
 *  \param[in]      value       Attempt counter value
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterSet(uint8_least secLev, uint8 value);
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27CounterInc()
 *********************************************************************************************************************/
/*! \brief          Increments the value of a specific security level attempt counter.
 *  \details        -
 *  \param[in]      secLev      Zero based security level index
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterInc(uint8_least secLev);
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27TimerSet()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a specific security level timer.
 *  \details        -
 *  \param[in]      secLev      Zero based security level index
 *  \param[in]      value       Timer value
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27TimerSet(uint8_least secLev, Dcm_Svc27TimerType value);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc27Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc27Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc27SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 SubFunction Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc27SubFuncHandler(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext);

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiGetAttemptCntr()
 *********************************************************************************************************************/
/*! \brief          Restores the attempt counter values from the application.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  levelMask               Pointer to a security level mask.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27UtiGetAttemptCntr(Dcm_OpStatusType opStatus
                                                                ,P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask);
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27ReadAttemptCounter()
 *********************************************************************************************************************/
/*! \brief          Manages reading of an attempt counter value.
 *  \details        If a diagnostic job is ongoing the appropriate action will be taken to close it deterministically.
 *  \param[in]      ev         The active event(s) of the Dcm_Svc27Task task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_Svc27Task task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_Svc27Task task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_Svc27ReadAttemptCounter(Dcm_TskTaskEvOptType ev
                                                                                 ,Dcm_TskTaskEvPtrType pPostEv);
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27WriteAttemptCounter()
 *********************************************************************************************************************/
/*! \brief          Manages writing of an attempt counter value.
 *  \details        If a diagnostic job is ongoing the appropriate action will be taken to close it deterministically.
 *  \param[in]      ev         The active event(s) of the Dcm_Svc27Task task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_Svc27Task task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_Svc27Task task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_Svc27WriteAttemptCounter(Dcm_TskTaskEvOptType ev
                                                                                  ,Dcm_TskTaskEvPtrType pPostEv);
# endif

# if (DCM_SVC_27_SUBFUNC_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SeedRepeater()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 get seed service port accessor.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SeedRepeater(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_27_SUBFUNC_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27KeyRepeater()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 send key service port accessor.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send neagative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27KeyRepeater(Dcm_OpStatusType opStatus
                                                                 ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_27_SUBFUNC_SUPPORT_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27CheckAttemptsExceededRepeater()
 *********************************************************************************************************************/
/*! \brief          Checks whether the number of allowed attempts were reached.
 *  \details        Determines the final negative response code (0x35 or 0x36).
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27CheckAttemptsExceededRepeater(Dcm_OpStatusType opStatus
                                                                    ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_27_SUBFUNC_SUPPORT_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SetAttemptCntrRepeater()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 set attempt counter service port accessor.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SetAttemptCntrRepeater(Dcm_OpStatusType opStatus
                                                                    ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext);
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc28SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor
 *  \details        -
 *  \param[in]      SubSvcRef      Index to a subfunction descriptor
 *  \return         Subfunction descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc28SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc28SubFuncInfoGetEntryOrNull(
                                                                              Dcm_DiagSubServiceRefOptType SubSvcRef);

/**********************************************************************************************************************
 *  Dcm_Svc28Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x28 Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc28Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc28RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc28SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x28 SubFunction Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc28SubFuncHandler(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc28RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc28ApplyCommControl()
 *********************************************************************************************************************/
/*! \brief          Apply concrete operation on network channel(s).
 *  \details        -
 *  \param[in]      network    The network handle
 *  \param[in]      mode       The communication mode
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc28ApplyCommControl(Dcm_CfgNetNetIdRefMemType networkRef
                                                               ,Dcm_CommunicationModeType mode);
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/* --- public members ---------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Service2ASchedulerInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Initializes the periodic DID scheduler.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Service2ASchedulerInit(void);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdAddItemByDid()
 *********************************************************************************************************************/
/*! \brief          Inserts a new item to the scheduler without activating it.
 *  \details        -
 *  \param[in,out]  pDidInfoContext    The context of the DID
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdAddItemByDid(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCommit()
 *********************************************************************************************************************/
/*! \brief          Commits already inserted items to be scheduled with a given rate.
 *  \details        -
 *  \param[in]      rate    The scheduling rate
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdCommit(Dcm_Svc2ASchedRateMemType rate);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdDiscard()
 *********************************************************************************************************************/
/*! \brief          Discards all inserted items.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdDiscard(void);

/**********************************************************************************************************************
 *  Dcm_Svc2AOnStateChanged()
 *********************************************************************************************************************/
/*! \brief          Stops all scheduled DIDs no more allowed by the new states.
 *  \details        Stops all scheduled DIDs that are nor more allowed after the state has been changed.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2AOnStateChanged(void);

/* --- private members --------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFindFreeOrInUseItemByDid()
 *********************************************************************************************************************/
/*! \brief          Tries to find already used DID entry slot. If not, returns the last free found.
 *  \details        -
 *  \param[in]      did    The did
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint16_least, DCM_CODE) Dcm_Svc2ASchdFindFreeOrInUseItemByDid(uint16 did);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdUpdateTimers()
 *********************************************************************************************************************/
/*! \brief          Updates all active scheduled item timers.
 *  \details        -
 *  \return         TRUE     Activate processor task
 *  \return         FALSE    Don't activate processor task
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdUpdateTimers(void);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdNextEntryIdxInc()
 *********************************************************************************************************************/
/*! \brief          Scheduler item iterator increment.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdNextEntryIdxInc(void);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdProcessEntry()
 *********************************************************************************************************************/
/*! \brief          A single PDID processing step.
 *  \details        Performs PDID reading and sending on expired PDID slots.
 *  \param[in]      pSchedTableEntry    The scheduler entry to be processed
 *  \return         DCM_E_OK        Continue processing
 *  \return         DCM_E_PENDING   Processing was postponed
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdProcessEntry(Dcm_Svc2ASchdEntryPtrType pSchedTableEntry);
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2AScheduledDidLookUp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Performs a lookup for a specific DID on scheduling requests.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AScheduledDidLookUp(Dcm_OpStatusType opStatus
                                                                           ,Dcm_MsgContextPtrType pMsgContext
                                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                           ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext);
/**********************************************************************************************************************
 *  Dcm_Svc2AStoppedDidLookUp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Performs a lookup for a specific DID on stop DID requests.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStoppedDidLookUp(Dcm_OpStatusType      opStatus
                                                                         ,Dcm_MsgContextPtrType pMsgContext
                                                                         ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                         ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext);
# if (DCM_DIDMGR_PERIODICDID_CHK_COND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ADidCheckCondition()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Checks the conditions of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidCheckCondition(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ADidGetLength()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Returns the length of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Go on with next DID
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidGetLength(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2ADoScheduleDids()
 *********************************************************************************************************************/
/*! \brief          Updates the scheduler content.
 *  \details        -
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADoScheduleDids(Dcm_MsgContextPtrType pMsgContext
                                                                       ,Dcm_NegativeResponseCodePtrType ErrorCode);

/**********************************************************************************************************************
 *  Dcm_Svc2AStopScheduledDids()
 *********************************************************************************************************************/
/*! \brief          Stops requested DIDs.
 *  \details        -
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStopScheduledDids(Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_Svc2AHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2A Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Operation failed
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Service 0x2C DID definition manager initializer.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrInit(void);

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadSrcItems()
 *********************************************************************************************************************/
/*! \brief          Performs reading on a single DynDID source item (DID or memory area).
 *  \details        -
 *  \param[in]      opStatus   Current DynDID read operation status.
 *  \return         DCM_E_OK         Read of all source items finished with success.
 *  \return         DCM_E_PENDING    One of the source items needs more time to return final result, call again.
 *  \return         DCM_E_NOT_OK     One of the source items returned an error.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadSrcItems(Dcm_OpStatusType opStatus);

/**********************************************************************************************************************
 *  Dcm_Svc2COnStateChanged()
 *********************************************************************************************************************/
/*! \brief          Clears all no more allowed DynDIDs in the new states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2COnStateChanged(void);

# if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_STATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CStateCheckSrcItems()
 *********************************************************************************************************************/
/*! \brief          Check state and mode group preconditions of each source item.
 *  \details        -
 *  \param[in]      dynDidHandle    DynDID reference to be checked
 *  \param[out]     ErrorCode       The NRC
 *  \return         DCM_E_OK        Check was successful
 *  \return         DCM_E_OK        Check was not successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CStateCheckSrcItems(
                                                                        Dcm_CfgDidMgrDynDidHandleOptType dynDidHandle
                                                                       ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01DefMgrRead()
 *********************************************************************************************************************/
/*! \brief          Reads a single DID source item.
 *  \details        -
 *  \param[in]      opStatus        Current DID sourceItem operation status.
 *  \param[out]     pCopyOffset     Returns the start offset of read data into the service 0x2C temp buffer to copy from.
 *  \param[out]     pCopyLength     Returns the data count of read data into the service 0x2C temp buffer to copy from.
 *  \return         DCM_E_OK        Reading finished with success.
 *  \return         DCM_E_PENDING   Reading needs some additional time. Call again.
 *  \return         DCM_E_NOT_OK    Reading finished with failed.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01DefMgrRead(Dcm_OpStatusType opStatus
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyOffset
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyLength);
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C02DefMgrRead()
 *********************************************************************************************************************/
/*! \brief          Reads a single Memory source item.
 *  \details        -
 *  \param[in]      opStatus        Current Memory sourceItem operation status.
 *  \param[out]     pCopyOffset     Returns the start offset of read data into the service 0x2C temp buffer to copy from.
 *  \param[out]     pCopyLength     Returns the data count of read data into the service 0x2C temp buffer to copy from.
 *  \return         DCM_E_OK            Reading finished with success.
 *  \return         DCM_E_FORCE_RCRRP   Send RCR-RP response. Once sent, call again.
 *  \return         DCM_E_PENDING       Reading needs some additional time. Call again.
 *  \return         DCM_E_NOT_OK        Reading finished with failed.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C02DefMgrRead(Dcm_OpStatusType opStatus
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyOffset
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyLength);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadCheckAccessAndInit()
 *********************************************************************************************************************/
/*! \brief          Reads a single Memory source item.
 *  \details        -
 *  \param[in]      dynDidHandle    Current dynDid handle to be read.
 *  \param[in,out]  opStatus        Current and modified operation status.
 *  \return         DCM_E_OK            Check succeeded, proceed with read.
 *  \return         DCM_E_PENDING       The DynDID is still in usage, try later
 *  \return         DCM_E_NOT_OK        Check failed, leave the DynDID reading.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadCheckAccessAndInit(
                                                              Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
                                                             ,P2VAR(Dcm_OpStatusType, AUTOMATIC, AUTOMATIC) pOpStatus);
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_CfgSvc2CSubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor
 *  \details        -
 *  \param[in]      SubSvcRef      Index to a subfunction descriptor
 *  \return         Subfunction descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc2CSubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc2CSubFuncInfoGetEntryOrNull(
                                                                              Dcm_DiagSubServiceRefOptType SubSvcRef);

/**********************************************************************************************************************
 *  Dcm_Svc2CHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2CSubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C SubFunction Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CSubFuncHandler(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidLookUp()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x01.
 *  \details        Performs a lookup for a specific source DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidLookUp(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON) && \
     (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidCheckCondition()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x01.
 *  \details        Checks the condition of a specific source DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidCheckCondition(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidGetLength()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x01.
 *  \details        Returns the length of a specific source DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidGetLength(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_03DidLookUp()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C 0x03 dedicated DID look up client.
 *  \details        -
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[out]     pRepContext    Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_03DidLookUp(Dcm_OpStatusType      opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2EHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2E Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2ERepeaterProxyContextPtrType pRepContext);

# if (DCM_DIDMGR_2E_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ECheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2E.
 *  \details        Checks the service 0x2E access.
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[in]      pRepContext      Current repeater proxy context
 *  \param[out]     ErrorCode        The NRC
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ECheckAccess(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc2ERepeaterProxyContextPtrType pRepContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2EExecuteOp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2E.
 *  \details        Executes a specific service 0x2E operation.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EExecuteOp(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc2ERepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2FHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2F Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING           Final result is pending, retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2FReturnControlToEcu()
 *********************************************************************************************************************/
/*! \brief          Reset all active IO controls.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FReturnControlToEcu(void);

/**********************************************************************************************************************
 *  Dcm_Svc2FOnStateChanged()
 *********************************************************************************************************************/
/*! \brief          Reset all active IO controls no more supported in the active DCM state.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FOnStateChanged(void);

# if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_EXT_CEMR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FExtractCEMR()
 *********************************************************************************************************************/
/*! \brief          Extracts the CEMR from the request.
 *  \details        Extracts the CEMR from a byte stream into a 32bit variable. If CEMRsize > 4 -> value is 0.
 *  \param[in]      cemrStream   Points to the beginning of the CEMR in the request
 *  \param[in]      cemrSize     Specifies the CEMR total length
 *  \return         0            If the CEMR size > 4 or no bit has been set. This value is invalid and will only
 *                               be used as initialization of the CEMR, but not passed to the application for NBit CEMR.
 *  \return         >0           Extracted CEMR. Note: For 3Byte CEMR the result is MSB bound!

 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_Svc2FExtractCEMR(Dcm_ReadOnlyMsgType                 cemrStream
                                                            ,Dcm_CfgDidMgrIoDidCemrLengthMemType cemrSize);
# endif

# if (DCM_DIDMGR_IO_MASKRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FProcessCEMR()
 *********************************************************************************************************************/
/*! \brief          Processes CEMR of IO DID request if the IO DID supports CEMR.
 *  \details        On IO DIDs with CEMR the CEMR will be extracted and verified for non-zero value.
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pRepContext        Current repeater proxy context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FProcessCEMR(Dcm_MsgContextPtrType pMsgContext
                                                          ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FCalculateExpectedReqLength()
 *********************************************************************************************************************/
/*! \brief          Calculates the expected request length including DID data and CEMR.
 *  \details        -
 *  \param[out]     expLengthMin        Returns the expected request minimum length.
 *  \param[out]     expLengthMin        Returns the expected request maximum length.
 *  \param[in,out]  pRepContext         Current repeater proxy context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FCalculateExpectedReqLength(Dcm_DidMgrDidLengthPtrType expLengthMin
                                                                    ,Dcm_DidMgrDidLengthPtrType expLengthMax
                                                                    ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckReqLength()
 *********************************************************************************************************************/
/*! \brief          Verifies the request length.
 *  \details        Verifies that the request length is valid for the concrete DID and IO operation incl. CEMR.
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pRepContext        Current repeater proxy context
 *  \return         DCM_E_POSITIVERESPONSE            Request length is valid.
 *  \return         !=DCM_E_POSITIVERESPONSE          A validation error has occurred.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2FCheckReqLength(Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2FIoDidOperationProcessor()
 *********************************************************************************************************************/
/*! \brief          Process a concrete IODID and its requested operation.
 *  \details        -
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[out]     pRepContext      Current repeater proxy context
 *  \return         DCM_E_NOT_OK     Send negative response
 *  \return         DCM_E_LOOP       Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FIoDidOperationProcessor(Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);

# if (DCM_DIDMGR_2F_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FCheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        Checks the service 0x2F access.
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in]      pRepContext      Current repeater proxy context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FCheckAccess(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FExecuteOp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        Executes a specific service 0x2F operation.
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in,out]  pRepContext      Current repeater proxy context
 *  \return         Next action to perform
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FExecuteOp(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);

# if (DCM_SVC_2F_READ_RES_DATA_LEN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FGetLength()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        Reads the length of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FGetLength(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);
# endif

# if(DCM_DIDMGR_IODID_READ_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FReadData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        -
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[out]     pRepContext    Current repeater proxy context
 *  \return         DCM_E_OK       Send response
 *  \return         DCM_E_NOT_OK   Send negative response
 *  \return         DCM_E_PENDING  Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FReadData(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext);
# endif
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc31Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc31Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc31RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc3DHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc3DRepeaterProxyContextPtrType pRepContext);

# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc3DCheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x3D.
 *  \details        Checks the service 0x3D access.
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[out]     pRepContext      Current repeater proxy context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DCheckAccess(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc3DRepeaterProxyContextPtrType pRepContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc3DWriteMemory()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x3D.
 *  \details        Writes the data to the memory.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force RCR-RP
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DWriteMemory(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc3DRepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc85SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor
 *  \details        -
 *  \param[in]      SubSvcRef      Index to a subfunction descriptor
 *  \return         Subfunction descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc85SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc85SubFuncInfoGetEntryOrNull(
                                                                              Dcm_DiagSubServiceRefOptType SubSvcRef);

/**********************************************************************************************************************
 *  Dcm_Svc85Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc85RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_CfgSvc86SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor
 *  \details        -
 *  \param[in]      SubSvcRef      Index to a subfunction descriptor
 *  \return         Subfunction descriptor entry
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc86SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc86SubFuncInfoGetEntryOrNull(
                                                                              Dcm_DiagSubServiceRefOptType SubSvcRef);

/**********************************************************************************************************************
 *  Dcm_Svc86Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x86 Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc86RepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc86SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x86 SubFunction Handler
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86SubFuncHandler(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc86RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Module internal function declarations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_MemMgrValidateAlfid()
 *********************************************************************************************************************/
/*! \brief          Validates the request memory ALFID.
 *  \details        -
 *  \param[in]      pMsgContext               Requested memory data starting with the ALFID byte.
 *  \param[out]     pAlfid                    ALFID byte
 *  \param[out]     pBlockLength              Returns the left part of the stream (i.e. without protocol header)
 *  \return         DCM_E_POSITIVERESPONSE    If no error found
 *  \return         DCM_E_ANYX                Corresponding NRC to the error detected
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_MemMgrValidateAlfid(Dcm_MsgContextPtrType   pMsgContext
                                                                              ,Dcm_Uint8VarDataPtrType pAlfid
                                                                              ,Dcm_Uint8VarDataPtrType pBlockLength);

/**********************************************************************************************************************
 *  Dcm_MemMgrParseMemStream()
 *********************************************************************************************************************/
/*! \brief          Validates the request memory ALFID.
 *  \details        -
 *  \param[in]      alfid         Requested ALFID byte
 *  \param[in,out]  pMsgContext   Current message context with the memory address and size byte stream
 *  \param[out]     pMemBlock     Interpreted memory block information
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_MemMgrParseMemStream(uint8 alfid
                                                       ,Dcm_MsgContextPtrType   pMsgContext
                                                       ,Dcm_MemMgrMemBlockPtrType pMemBlock);

/**********************************************************************************************************************
 *  Dcm_MemMgrCheckMemBlock()
 *********************************************************************************************************************/
/*! \brief          Checks a specific memory block.
 *  \details        -
 *  \param[in]      pMemBlock    The memory block descriptor for validation
 *  \param[in]      memOp        The memory block operation type
 *  \param[out]     ErrorCode    The NRC
 *  \return         Result of analysis
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrCheckMemBlock(Dcm_MemMgrMemBlockPtrType pMemBlock
                                                                ,Dcm_MemMgrMemoryOpType memOp
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode);

# if (DCM_MEMMGR_MEMOP_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrReadMemory()
 *********************************************************************************************************************/
/*! \brief          Executes a read memory operation.
 *  \details        -
 *  \param[in]      opStatus      Current operation status
 *  \param[in]      pMemBlock     The memory block descriptor for validation
 *  \param[in]      data          data buffer
 *  \param[out]     ErrorCode     The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrReadMemory(Dcm_OpStatusType opStatus
                                                             ,Dcm_MemMgrMemBlockPtrType pMemBlock
                                                             ,Dcm_ConstMsgType data
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif

# if (DCM_MEMMGR_MEMOP_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrWriteMemory()
 *********************************************************************************************************************/
/*! \brief          Executes a read memory operation.
 *  \details        -
 *  \param[in]      opStatus      Current operation status
 *  \param[in]      pMemBlock     The memory block descriptor for validation
 *  \param[in]      data          data buffer
 *  \param[out]     ErrorCode     The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrWriteMemory(Dcm_OpStatusType opStatus
                                                              ,Dcm_MemMgrMemBlockPtrType pMemBlock
                                                              ,Dcm_MsgType data
                                                              ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_22_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_SVC_31_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED   == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrIsIdEnabled()
 *********************************************************************************************************************/
/*! \brief          Returns the calibrated state of an OBD ID.
 *  \details        -
 *  \param[in]      obdId              The OBD ID to be verified.
 *  \param[in]      pMaskData    A pointer to the OBD ID availability range mask list
 *  \return         TRUE               OBD ID is still enabled
 *  \return         FALSE              OBD ID was calibrated to be disabled
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_ObdIdMgrIsIdEnabled(uint8 obdId
                                             ,P2CONST(Dcm_ObdIdMgrMaskValueTableType, AUTOMATIC, DCM_CONST) pMaskData);
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetAvailabilityMask()
 *********************************************************************************************************************/
/*! \brief          A utility to provide a lookup result of an OBD ID and returning the corresponding AID mask value.
 *  \details        For a given OBD ID, returns the lookup result considering any variant handling/calibration. On
 *                  valid OBD ID value, the corresponding AID mask value will be returned too (also on non AID OBD IDs).
 *  \param[in]      id                  The OBD ID to look for
 *  \param[in]      lookUpTable         The look up table to search in
 *  \param[in]      lookUpFilterTable   The look up table filter (variant dependencies)
 *  \param[in]      pMaskData           The generated 32bit mask value (variant independent/calibratable)
 *  \return         >=0            Valid index of the look up table if OBD ID supported/enabled (in variant)
 *  \return         <0             Invalid look up table index for unsupported/disabled (in variant) OBD ID
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_ObdIdMgrGetAvailabilityMask(uint8 id
                                                                      ,Dcm_Uint8ConstDataPtrType lookUpTable
                                                                      ,Dcm_VarRefMemPtrType lookUpFilterTable
                                                                      ,Dcm_ObdMaskConstDataPtrType pMaskData
                                                                      ,P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue);
# if (DCM_OBDIDMGR_REQ_PARSER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrParseReqAndPrepRes()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Processes a list of IDs and in case of availability ID request writes the response data.
 *  \param[in,out]  idDescPtr
 *                  IN             idListSize
 *                  OUT            idDescList size
 *  \param[in,out]  pMsgContext    Current request context
 *  \return         TRUE           Mixed availability and data PIDs
 *  \return         FASLE          Only one kind of PIDs
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_ObdIdMgrParseReqAndPrepRes(Dcm_ObdIdMgrDescPtrType idDescPtr
                                                                                   ,Dcm_MsgContextPtrType pMsgContext);
# endif
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_UTI_LOOKUP_U16_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_UtiLookUpUint16()
 *********************************************************************************************************************/
/*! \brief          Searches a word table for an element.
 *  \details        -
 *  \param[in]      lookUpTable    Pointer to the table to be scanned (first element is table-size!)
 *  \param[in]      value          Value to be found
 *  \return         -1             Look up failed (no match)
 *  \return         >=0            Success, index of the matched position
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            Total number of elements for look up shall be < 32768.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_UtiLookUpUint16(P2CONST(uint16, AUTOMATIC, DCM_CONST) lookUpTable
                                                          ,uint16 value);
#endif

/**********************************************************************************************************************
 *  Dcm_UtiGetBitPosition()
 *********************************************************************************************************************/
/*! \brief          Returns the position of the most left set bit in a bit set.
 *  \details        -
 *  \param[in]      bitSet    A bit-set with only one bit set in it.
 *  \return         Returns the position of the set bit
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(uint8, DCM_CODE) Dcm_UtiGetBitPosition(uint32 bitSet);

#if (DCM_UTI_NVM_READ_ENABLED  == STD_ON) || \
    (DCM_UTI_NVM_WRITE_ENABLED == STD_ON)                                                                                                            /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_UtiNvMGetErrorStatus()
 *********************************************************************************************************************/
/*! \brief          Poll the error status from the NvM.
 *  \details        -
 *  \param[in]      blockId    Id of the NvRam block
 *  \return         DCM_E_OK       Operation finished with success.
 *  \return         DCM_E_NOT_OK   Operation finished with failure.
 *  \return         DCM_E_PENDING  Operation needs more time to be accomplished.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            Shall be called only after any NvM read/write operation of the given block is triggered.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiNvMGetErrorStatus(uint16 blockId);
#endif
/**********************************************************************************************************************
 *  Dcm_NetUnRegisterAllComMActivity()
 *********************************************************************************************************************/
/*! \brief          Tries to unregister all ComM channels activities.
 *  \details        -
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterAllComMActivity(void);

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterComMActivity()
 *********************************************************************************************************************/
/*! \brief          Tries to unregister a ComM channel activity.
 *  \details        -
 *  \param[in]      connId    The connection which has finished its job
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            Must be called only for external diagnostic requests
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterComMActivity(Dcm_NetConnRefMemType connId);

/**********************************************************************************************************************
 *  Dcm_NetRegisterComMActivity()
 *********************************************************************************************************************/
/*! \brief          Tries to register a ComM channel activity.
 *  \details        -
 *  \param[in]      pTranspObj    The transport object which starts diagnostic job
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetRegisterComMActivity(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_NetUsdtTxConfirmation()
 *********************************************************************************************************************/
/*! \brief          Transport object transmission finalization.
 *  \details        Finalization of a transmitted USDT message.
 *  \param[in]      pTranspObj    The transport object used during transmission
 *  \param[in]      result        The transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUsdtTxConfirmation(Dcm_NetTransportObjectPtrType pTranspObj
                                                        ,Dcm_NetTransmissionResultType result);

/**********************************************************************************************************************
 *  Dcm_NetAllocateOrGetTranspObjectOrNull()
 *********************************************************************************************************************/
/*! \brief          Transport object allocation.
 *  \details        Allocates a transport object for a concrete client connection.
 *  \param[in]      connId        The connection identifier
 *  \return         Allocated transport object
 *  \return         NULL_PTR      On invalid connection identifier (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Must be called within a critical section to guarantee unique result
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetAllocateOrGetTranspObjectOrNull(Dcm_NetConnRefMemType connId);

/**********************************************************************************************************************
 *  Dcm_NetGetTranspObjOfConnectionOrNull()
 *********************************************************************************************************************/
/*! \brief          Returns the transport object of the given connection.
 *  \details        -
 *  \param[in]      connId    The connection identifier
 *  \return         The transport object assigned to the given connection
 *  \return         NULL_PTR if no transport object is assigned to the given connection
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            Since only getter, can be called outside of a critical section, but for consistent results do call within critical section
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetConnRefMemType connId);

/**********************************************************************************************************************
 *  Dcm_NetTranspObjRelease()
 *********************************************************************************************************************/
/*! \brief          Release transport object resource.
 *  \details        Releases a given transport object.
 *  \param[in]      pTranspObj    The transport object to be released
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTranspObjRelease(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_NetGetConnIdByTesterAddress()
 *********************************************************************************************************************/
/*! \brief          Tries to find the corresponding connection of a diagnostic client.
 *  \details        -
 *  \param[in]      testerAddress    The diagnostic client address to look for
 *  \return         < DCM_NET_INVALID_CONNID    Valid connection id found.
 *  \return         DCM_NET_INVALID_CONNID      No connection found for the source address.
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_NetGetConnIdByTesterAddress(uint16 testerAddress);

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterActiveConnection()
 *********************************************************************************************************************/
/*! \brief          Unregister a connection.
 *  \details        Unregister an active connection referenced by the given transport object.
 *  \param[in]      pTranspObj    The transport object to be released
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterActiveConnection(Dcm_NetTransportObjectPtrType pTranspObj);

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
/*! \brief          Periodic message allocation.
 *  \details        Allocates a resource for a periodic message.
 *  \param[in]      Did     DID of the message that is allocated
 *  \return         DCM_NET_INVALID_PTXOBJ_HANDLE      No free resource found
 *  \return         < DCM_NET_INVALID_PTXOBJ_HANDLE    A concrete valid handle is returned
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_CfgNetPTxObjHandleMemType, DCM_CODE) Dcm_NetPeriodicMsgAllocate(uint16 Did);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgRelease()
 *********************************************************************************************************************/
/*! \brief          Releases a concrete periodic message resource.
 *  \details        -
 *  \param[in]      handle    The periodic response message resource handle to be released
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgRelease(Dcm_CfgNetPTxObjHandleOptType perTxObjHandle);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmit()
 *********************************************************************************************************************/
/*! \brief          Transmits a periodic message.
 *  \details        -
 *  \param[in]      handle    The periodic response message resource handle to be sent
 *  \param[in]      length    The periodic response message length
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmit(Dcm_CfgNetPTxObjHandleOptType perTxObjHandle
                                                         ,PduLengthType length);
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetProvideRxBuffer()
 *********************************************************************************************************************/
/*! \brief          Request reception data manager.
 *  \details        This function is called by Dcm_ProvideRxBuffer.
 *  \param[in]      DcmRxPduId      The RxPduId on the current request transmission
 *  \param[in]      TpSduLength     The required data length from the lower layer
 *  \param[out]     PduInfoPtr      Pointer to the request buffer pointer and buffer size
 *  \param[in]      addTObjFlags    Additional transport object flags from caller.
 *  \return         0               BUFREQ_OK
 *  \return         >0              Failed for some reason
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE for different PduIds
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetProvideRxBuffer(PduIdType DcmRxPduId
                                                              ,PduLengthType TpSduLength
                                                              ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) *PduInfoPtr
                                                              ,Dcm_NetTransportObjectFlagType addTObjFlags);
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetStartOfReception()
 *********************************************************************************************************************/
/*! \brief          Start of new request reception.
 *  \details        This function is called by Dcm_StartOfReception.
 *  \param[in]      rxPduId            The RxPDUID of the request
 *  \param[in]      tpSduLength        The total length of the TP message
 *  \param[out]     bufferSizePtr      Available buffer size
 *  \param[in]      addTObjFlags       Additional transport object flags from caller
 *  \return         BUFREQ_OK          A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK    No free buffer is available - ignore request
 *  \return         BUFREQ_E_OVFL      The request message is too long for the configured buffer
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetStartOfReception(PduIdType rxPduId
                                                          ,PduLengthType tpSduLength
                                                          ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr
                                                          ,Dcm_NetTransportObjectFlagType addTObjFlags);

/**********************************************************************************************************************
 *  Dcm_NetSetComModeEntered()
 *********************************************************************************************************************/
/*! \brief          Internal utility for updating the new communication state.
 *  \details        -
 *  \param[in]      networkId      The communication channel on which this state is now active
 *  \param[in]      newComState    The new state of the communication channel (e.g. DCM_NET_COMM_STATE_RX_DIS_TX_DIS)
 *  \context        ISR1|ISR2
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetSetComModeEntered(NetworkHandleType networkId
                                                       ,Dcm_NetComMStateType newComState);
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCancel()
 *********************************************************************************************************************/
/*! \brief          Dispatches the CancelPage call.
 *  \details        Dispatches the CancelPage call regarding the paged-buffer.
 *  \param[out]     ErrorCode   The NRC
 *  \return         DCM_E_OK        Operation finished with success
 *  \return         DCM_E_NOT_OK    Operation failed, ErrorCode cotnains the NRC
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferCancel(Dcm_NegativeResponseCodePtrType ErrorCode);
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferStart()
 *********************************************************************************************************************/
/*! \brief          Activate paged-buffer write process.
 *  \details        -
 *  \param[in]      resDataLen    Specifies how many bytes will be copied using the update page function.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferStart(Dcm_MsgLenType resDataLen);
#endif
/**********************************************************************************************************************
 *  Dcm_RepeaterExecute()
 *********************************************************************************************************************/
/*! \brief          Starts polling a repeater proxy.
 *  \details        -
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_RepeaterExecute(Dcm_NegativeResponseCodePtrType ErrorCode);

/**********************************************************************************************************************
 *  Dcm_RepeaterSetCallee()
 *********************************************************************************************************************/
/*! \brief          Starts polling a repeater proxy.
 *  \details        -
 *  \param[in]      pProxy    The proxy callee
 *  \context        TASK
 *  \reentrant      FALSE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_RepeaterSetCallee(uint8 serviceProcessorIdx);
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchDtcSetting()
 *********************************************************************************************************************/
/*! \brief          Mode management on control DTC setting.
 *  \details        -
 *  \param[in]      newMode       The mode
 *  \param[in]      DTCGroup      The affected DTC group of changed setting
 *  \param[in]      DemClientId   The DEM client id
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchDtcSetting(Rte_ModeType_DcmControlDtcSetting newMode
                                                       ,uint32                            DTCGroup
                                                       ,uint8                             DemClientId);
# endif

# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchCommControl()
 *********************************************************************************************************************/
/*! \brief          Mode management on communication control.
 *  \details        -
 *  \param[in]      network    The network handle
 *  \param[in]      newMode    The mode
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchCommControl(Dcm_CfgNetNetIdRefOptType networkRef
                                                        ,Dcm_CommunicationModeType newMode);
# endif
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_StateCheck()
 *********************************************************************************************************************/
/*! \brief          Performs a state rule check.
 *  \details        -
 *  \param[in]      stateRef                  Reference to the state precondition table
 *  \param[in]      chkLevel                  State level check
 *  \param[out]     ErrorCode                 The NRC
 *  \return         DCM_E_OK                  State rule check was sucessful
 *  \return         DCM_E_NOT_OK              State rule check was not sucessful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_StateCheck(Dcm_CfgStateRefOptType stateRef
                                                       ,Dcm_DiagCheckLvlType chkLevel
                                                       ,Dcm_NegativeResponseCodePtrType ErrorCode);

/**********************************************************************************************************************
 *  Dcm_StateSetSession()
 *********************************************************************************************************************/
/*! \brief          Performs a session state transition.
 *  \details        -
 *  \param[in]      stateRef    The state order number.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSession(Dcm_StateIndexOptType stateRef);

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateSetSecurity()
 *********************************************************************************************************************/
/*! \brief          Performs a security state transition.
 *  \details        -
 *  \param[in]      stateRef    The state order number.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSecurity(Dcm_StateIndexOptType stateRef);
#endif
/**********************************************************************************************************************
 *  Dcm_TskScheduler()
 *********************************************************************************************************************/
/*! \brief          Task scheduling.
 *  \details        Monitors for any tasks to be activated.
 *  \param[in]      tskPrio    The tasks priority to be monitored and activated
 *  \context        TASK
 *  \reentrant      TRUE only in case split task is supported.
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TskScheduler(Dcm_TskTaskPrioMemType tskPrio);
/* --- Timer Tasks ------------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_TmrTaskTimer()
 *********************************************************************************************************************/
/*! \brief          Timer task scheduling.
 *  \details        Scheduling of the timer manager sub-module.
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TmrTaskTimer(Dcm_TskTaskEvOptType ev
                                               ,Dcm_TskTaskEvPtrType pPostEv);

/* --- PagedBuffer Tasks ------------------------------------------------------------------------------------------- */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferTask()
 *********************************************************************************************************************/
/*! \brief          Lo priority Tx task of the paged-buffer sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferTask(Dcm_TskTaskEvOptType ev
                                                  ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/* --- Diagnostic Tasks -------------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_DiagTaskRx()
 *********************************************************************************************************************/
/*! \brief          Hi priority Rx task of the network sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRx(Dcm_TskTaskEvOptType ev
                                             ,Dcm_TskTaskEvPtrType pPostEv);

/**********************************************************************************************************************
 *  Dcm_DiagTaskWorker()
 *********************************************************************************************************************/
/*! \brief          Low priority task of the diagnostic sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskWorker(Dcm_TskTaskEvOptType ev
                                                 ,Dcm_TskTaskEvPtrType pPostEv);

#if (DCM_TSK_NUM_DIAG_GARB_COL > 0)
/**********************************************************************************************************************
 *  Dcm_DiagTaskGarbageCollector()
 *********************************************************************************************************************/
/*! \brief          High priority task of the diagnostic sub-module.
 *  \details        Releases all obsolete transport objects after prioritization.
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskGarbageCollector(Dcm_TskTaskEvOptType ev
                                                           ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagTaskFblRes()
 *********************************************************************************************************************/
/*! \brief          Low priority task of the diagnostic sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskFblRes(Dcm_TskTaskEvOptType ev
                                                 ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTaskTx()
 *********************************************************************************************************************/
/*! \brief          Hi priority Tx task of the diagnostic sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskTx(Dcm_TskTaskEvOptType ev
                                             ,Dcm_TskTaskEvPtrType pPostEv);

/* --- Net Tasks --------------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_NetTaskTx()
 *********************************************************************************************************************/
/*! \brief          Hi priority task of the network sub-module for transmissions.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTx(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv);

#if (DCM_NET_TASK_RX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetTaskRx()
 *********************************************************************************************************************/
/*! \brief          Hi priority task of the network sub-module for request prioritization.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskRx(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetTaskTaMonitor()
 *********************************************************************************************************************/
/*! \brief          Hi priority task of the network sub-module for request processing suppression.
 *  \details        This function is used to prevent a request processing or to cancel an ongoing request processing.
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTaMonitor(Dcm_TskTaskEvOptType ev
                                                   ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/* --- ModeManager monitoring task --------------------------------------------------------------------------------- */
#if (DCM_TSK_NUM_MODE_MONITOR > 0)
/**********************************************************************************************************************
 *  Dcm_ModeTaskMonitor()
 *********************************************************************************************************************/
/*! \brief          Lo priority monitoring task of the Mode manager sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeTaskMonitor(Dcm_TskTaskEvOptType ev
                                                  ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_SVC2A_SCHEDULER > 0)                                                                                                                /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2ATaskSchdProcess()
 *********************************************************************************************************************/
/*! \brief          Low priority task.
 *  \details        Task for service 0x2A scheduling.
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ATaskSchdProcess(Dcm_TskTaskEvOptType ev
                                                       ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_SVC27 > 0)
/**********************************************************************************************************************
 *  Dcm_Svc27Task()
 *********************************************************************************************************************/
/*! \brief          Low priority task.
 *  \details        Task for service 0x27.
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27Task(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_DIAG_RECOVERY > 0)                                                                                                                  /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagTaskRecovery()
 *********************************************************************************************************************/
/*! \brief          Low priority task of the diagnostic sub-module to recover an external stored DCM state.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRecovery(Dcm_TskTaskEvOptType ev
                                                   ,Dcm_TskTaskEvPtrType pPostEv);
#endif
/* --- Timer notification functions -------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutP2()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a P2 timeout occurs.
 *  \return         Returns always 0 -> no reload
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutP2(void);

/**********************************************************************************************************************
 *  Dcm_OnTimeoutS3()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a S3 timeout occurs.
 *  \return         Returns always 0 -> no reload
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutS3(void);

#if (DCM_TMR_NUM_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutFblRes()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when the P2* time expires after FBL-to-APPL transition
 *  \return         Returns always 0 -> no reload
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutFblRes(void);
#endif

#if (DCM_TMR_NUM_SECURITY_0 > 0)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSecurityAccess_0()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a security access timeout occurs.
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSecurityAccess_0(void);
#endif

#if (DCM_TMR_NUM_SECURITY_1 > 0)                                                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSecurityAccess_1()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a security access timeout occurs.
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSecurityAccess_1(void);
#endif

#if (DCM_TMR_NUM_PERIODIC_TX > 0)                                                                                                                    /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutPeriodicTx()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        The periodic transmission timeout is reached
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutPeriodicTx(void);
#endif

#if (DCM_TMR_NUM_SVC2A_SCHEDULER > 0)                                                                                                                /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSvc2AScheduler()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a service 0x2A scheduler timeout occurs.
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSvc2AScheduler(void);
#endif

#if (DCM_TMR_NUM_KEEP_ALIVE > 0)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutKeepAlive()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a keep alive timeout occurs.
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutKeepAlive(void);
#endif
#if (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_RETVAL_TO_NRC_MAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiGetNrcForDemRetValue()
 *********************************************************************************************************************/
/*! \brief          Converts a DEM API return value to a concrete NRC
 *  \details        -
 *  \param[in]      demResult           DEM API returned value
 *  \param[in]      demResult2NrcMap    Pointer to a DEM API specific map (serialized array of pair values)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DemApiGetNrcForDemRetValue(uint8 demResult, Dcm_Uint8ConstDataPtrType demResult2NrcMap);
# endif

# if (DCM_DEMAPI_GETNEXTFILTEREDITEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiConvDemRsltGetNextFilteredItem()
 *********************************************************************************************************************/
/*! \brief          Converts a DEM API return value to a concrete DCM return value
 *  \details        -
 *  \param[in]      demResult                 DEM API returned value
 *  \param[out]     ErrorCode                 The NRC
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DemApiConvDemRsltGetNextFilteredItem(
                                                                         Dcm_DemReturnGetNextFilteredItemType demResult
                                                                        ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif
#endif /* (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_CANCEL_OP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrCancelOperation()
 *********************************************************************************************************************/
/*! \brief          Cancels an ongoing DID operation.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrCancelOperation(void);
# endif

# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrOpTypeHandlerInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Prepare DID for multi signal processing for a specific operation type (i.e. Read, ReadCheckCond,
 *                  Write, etc.)
 *  \param[in]      pDidInfoContext    The DID configuration information
 *  \param[in]      pDidOpTypeContext  The DID operation context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrOpTypeHandlerInit(Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                          ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadLength()
 *********************************************************************************************************************/
/*! \brief          Returns the length of a specific DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in]      pDidInfoContext    The DID configuration information
 *  \param[out]     errorCode          The error code
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLength(Dcm_OpStatusType                opStatus
                                                             ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                             ,Dcm_NegativeResponseCodePtrType errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadCheckCond()
 *********************************************************************************************************************/
/*! \brief          Returns the check condition of a specific DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in]      pDidInfoContext    The DID configuration configuration context
 *  \param[in]      pDidOpTypeContext  The DID operation context
 *  \param[out]     errorCode          The errorCode to be returned
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadCheckCond(Dcm_OpStatusType                  opStatus
                                                                ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrGetDidInfo()
 *********************************************************************************************************************/
/*! \brief          Returns some information of a specific DID.
 *  \details        Looks for the DID to get its corresponding DidInfo and DidOpInfo (up to 32767 items).
 *  \param[in]      opStatus             The current operation status
 *  \param[in,out]  pDidInfoContext      Contains DID Information
 *  \param[in,out]  pDidOpTypeContext    Contains DID operation state
 *  \param[in]      didOp                The lookup DID operation context
 *  \return         DCM_E_OK                Positive look up result
 *  \return         DCM_E_NOT_OK            Negative look up result
 *  \return         DCM_E_PENDING           Final result is pending, retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            The DID number must be set by the caller (pDidInfoContext->Did is valid).
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetDidInfo(Dcm_OpStatusType                  opStatus
                                                             ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                             ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                             ,Dcm_DidMgrOpOptType               didOp);

/**********************************************************************************************************************
 *  Dcm_DidMgrGetDidOpInfo()
 *********************************************************************************************************************/
/*! \brief          Returns the operation handle of a DID.
 *  \details        -
 *  \param[in]      pDidInfoContext    The DID configuration configuration context
 *  \param[in]      didOp              The required DID operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrGetDidOpInfo(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                     ,Dcm_DidMgrOpOptType             didOp);

/**********************************************************************************************************************
 *  Dcm_DidMgrGetOpClassInfo()
 *********************************************************************************************************************/
/*! \brief          Returns the operation type of a DID.
 *  \details        -
 *  \param[in]      pDidInfoContext    The DID configuration information
 *  \param[in]      opType             Operation type
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrGetOpClassInfo(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                       ,Dcm_DidMgrOpCallOptType         opType);

# if (DCM_DIDMGR_DYNDID_DEEP_CHECK_ON_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDynDidStateCheck()
 *********************************************************************************************************************/
/*! \brief          Checks the state of a specific DID.
 *  \details        Checks a DID operation info considering DynDID content.
 *  \param[in]      pDidInfoContext    The DID configuration configuration context
 *  \param[out]     ErrorCode          The NRC
 *  \return         DCM_E_OK           State check was successful
 *  \return         DCM_E_NOT_OK       State check was not successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDynDidStateCheck(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode);
# else
/* a function like macro is used for optimal code size */
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadDidLinear()
 *********************************************************************************************************************/
/*! \brief          Reads a DID for service 0x22 using the linear buffer.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The DID configuration information context
 *  \param[in,out]  pDidOpTypeContext  The DID operation context
 *  \param[out]     errorCode          The NRC
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadDidLinear(Dcm_OpStatusType                  opStatus
                                                                ,Dcm_DiagDataContextPtrType        pDataContext
                                                                ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadDidPaged()
 *********************************************************************************************************************/
/*! \brief          Reads a DID for service 0x22 using the paged-buffer.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDataContext       The pointer to the data context
 *  \param[in,out]  pDidInfoContext    The DID configuration configuration context
 *  \param[in,out]  pDidOpTypeContext  The DID configuration operation context
 *  \param[out]     errorCode          The NRC
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadDidPaged(Dcm_OpStatusType opStatus
                                                               ,Dcm_DiagDataContextPtrType pDataContext
                                                               ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                               ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                               ,Dcm_NegativeResponseCodePtrType errorCode);
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrDemSetDTCFilter()
 *********************************************************************************************************************/
/*! \brief          Sets the DTC Filter in Dem
 *  \details        -
 *  \param[in]      StatusMask              DTC Statusmask
 *  \param[in]      Origin                  DTC Origin
 *  \param[in]      pReadDtcContext         The service specific context
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrDemSetDTCFilter(uint8 StatusMask
                                                                 ,Dem_DTCOriginType Origin
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_ObdDtcManagerContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrReadDtcByStatusMask()
 *********************************************************************************************************************/
/*! \brief          Processes a DTC read by status mask service for OBD.
 *  \details        -
 *  \param[in]      opStatus                The operation status
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_STOP_REPEATER     Stop Repeater Proxy
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            DTC Filter set in Dem (Dcm_ObdDtcMgrDemSetDTCFilter)
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrReadDtcByStatusMask(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_ObdDtcManagerContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          Data processor of service (0x03/0x07/0x0A).
 *  \details        Calls the GetNextFilteredDTC function.
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_NOT_OK                Error occured
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available room any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(Dcm_DiagDataContextPtrType pDataContext
                                                                          ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                          ,Dcm_ObdDtcManagerContextPtrType pRepContext);
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_DiagRcrRpTxFinished()
 *********************************************************************************************************************/
/*! \brief          Performs post processing of currently finished RCR-RP transmission.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRcrRpTxFinished(Dcm_NetTransportObjectPtrType pTranspObj
                                                      ,Dcm_NetTransmissionResultType txStatus);

/**********************************************************************************************************************
 *  Dcm_DiagSetP2Timings()
 *********************************************************************************************************************/
/*! \brief          Sets the adjusted P2 timings.
 *  \details        -
 *  \param[in]      sesStateIdx    The index of the current session.
 *  \param[in]      protocolIdx    The index of the current protocol.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagSetP2Timings(Dcm_StateIndexMemType sesStateIdx,
                                                    Dcm_NetProtRefMemType protocolIdx);

/**********************************************************************************************************************
 *  Dcm_DiagRxIndication()
 *********************************************************************************************************************/
/*! \brief          Called once an incoming reception is finished.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM external/internal connection
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRxIndication(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_SetNegResponse()
 *********************************************************************************************************************/
/*! \brief          Registers a NRC to the request in progress if no other NRC already set.
 *  \details        -
 *  \param[in]      nrc    The error code to be registered
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_SetNegResponse(Dcm_NegativeResponseCodeType nrc);

/**********************************************************************************************************************
 *  Dcm_ProcessingDone()
 *********************************************************************************************************************/
/*! \brief          Finalizes the service job processing.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ProcessingDone(void);

/**********************************************************************************************************************
 *  Dcm_DiagLookUpFilter()
 *********************************************************************************************************************/
/*! \brief          Performs a lookup result filtering.
 *  \details        -
 *  \param[in]      lookUpResult         The original result of the lookup
 *  \param[in]      lookUpFilterTable    List of filters
 *  \param[in]      stateRef             Reference to the state precondition table
 *  \param[out]     errorCode            The error code to be returned
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_DiagLookUpFilter(sint16_least lookUpResult
                                                           ,Dcm_VarRefMemPtrType lookUpFilterTable
                                                           ,Dcm_DiagCheckLvlType chkLevel
                                                           ,Dcm_NegativeResponseCodePtrType errorCode);
#if (DCM_DIAG_SF_ONLY_SERVICE_ENABLED == STD_ON)                                                                                                     /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagSvcWithOnlySubFuncReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Default sub-function length getter.
 *  \details        Always returns length of 1 byte (sub-function byte only expected)
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length (1 byte only)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_DiagSvcWithOnlySubFuncReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);
#endif

#if (DCM_DIAG_ANY_SERVICE_WITH_SF_ENABLED == STD_ON)                                                                                                 /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagVerifyServiceWithSubFunction()
 *********************************************************************************************************************/
/*! \brief          Verifies a service with sub-function.
 *  \details        Implements the ISO14229-1:2013 algorithm for sub-function validation
 *  \param[in,out]  pMsgContext          Current request context
 *  \param[in]      lookUpResult         The sub-service lookup table
 *  \param[in]      lookUpFilterTable    List of sub-service related filters
 *  \param[in]      svcLengthGetter      Functor for accessing a sub-service specific length
 *  \param[out]     pSubSvcRef           A zero-based sub-service index for further processing
 *  \param[out]     ErrorCode            The NRC
 *  \return         DCM_E_OK             Validation passed
 *  \return         DCM_E_NOT_OK         Validation failed with the returned ErrorCode
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagVerifyServiceWithSubFunction(
                                                                 Dcm_MsgContextPtrType                pMsgContext
                                                                ,Dcm_Uint8ConstDataPtrType            lookUpTable
                                                                ,Dcm_VarRefMemPtrType                 lookUpFilterTable
                                                                ,Dcm_DiagServiceLengthGetterFuncType  svcLengthGetter
                                                                ,Dcm_DiagSubServiceRefOptPtrType      pSubSvcRef
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode);
#endif

#if(DCM_DIAG_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagExecIndicationFunc()
 *********************************************************************************************************************/
/*! \brief          Executes an indication callback and evaluates its return values.
 *  \details        -
 *  \param[in]      sid                 The requested SID
 *  \param[in]      notificationType    The notification kind (OEM, SYS)
 *  \param[in]      notifList           The request indication list to be executed
 *  \param[out]     ErrorCode           The NRC
 *  \return         DCM_E_OK            Proceed with service validation after return
 *  \return         DCM_E_NOT_OK        At least one Xxx_Indication() has rejected further processing
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            The last element of the passed notifList must be marked by NULL_PTR.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagExecIndicationFunc(Dcm_MsgItemType sid
                                                                   ,Dcm_DiagApplNotificationType notificationType
                                                                   ,Dcm_CfgDiagNotificationInfoPtrType notifList
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTxFinalization()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTxFinalization(Dcm_NetTransportObjectPtrType pTranspObj
                                                     ,Dcm_NetTransmissionResultType txStatus);

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagOnFblResTxFinished()
 *********************************************************************************************************************/
/*! \brief          Called by the TP once an ongoing transmission is finished.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagOnFblResTxFinished(Dcm_NetTransportObjectPtrType pTranspObj
                                                         ,Dcm_NetTransmissionResultType txStatus);
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagCancelProcessing()
 *********************************************************************************************************************/
/*! \brief          Cancel any ongoing job.
 *  \details        This function cancels any ongoing service processing.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagCancelProcessing(void);
#endif
/**********************************************************************************************************************
 *  Dcm_VarMgrLookUpFilter()
 *********************************************************************************************************************/
/*! \brief          Performs a lookup result filtering.
 *  \details        Checks whether a diagnostic object is supported in the active variant.
 *  \param[in]      lookUpResult         The original result of the lookup (can also be "NOT_FOUND")
 *  \param[in]      lookUpFilterTable    List of filters
 *  \return         -1     Diagnostic entity not active in current variant
 *  \return         >=0    Success, index of the matched position
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_VarMgrLookUpFilter(sint16_least lookUpResult
                                                             ,Dcm_VarRefMemPtrType lookUpFilterTable);

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VarMgrIsEnabledInActiveVariants()
 *********************************************************************************************************************/
/*! \brief          Checks if a diagnostic object is active in at least one variant.
 *  \details        -
 *  \param[in]      cfgVariantRef    Reference to the variant configuration
 *  \return         TRUE             Diagnostic object is active in at least one variant
 *  \return         FALSE            Diagnostic object is not active
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgStateRefOptType cfgVariantRef);
#else
# define Dcm_VarMgrIsEnabledInActiveVariants(cfgVariantRef)          ((boolean)Dcm_VarMgrBitSetTestBit(Dcm_PbCfgVarMgrDiagVariantFilter[(cfgVariantRef)], Dcm_SingletonContext.VarMgr.ActiveCfgVariantId)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc01GetAvailabilityMask()
 *********************************************************************************************************************/
/*! \brief          Returns the calibrated state of an OBD PID.
 *  \details        -
 *  \param[in]      id                 The OBD PID to be verified.
 *  \param[out]     pMaskValue         A pointer to the OBD PID availability range mask list
 *  \return         >=0                Valid index from the lookup engine.
 *  \return         <0                 OBD PID is not supported (disabled | in variant)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc01GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue);
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_Svc06GetAvailabilityMask()
 *********************************************************************************************************************/
/*! \brief          Returns the calibrated state of an OBD MID.
 *  \details        -
 *  \param[in]      id                 The OBD MID to be verified.
 *  \param[out]     pMaskValue         A pointer to the OBD MID availability range mask list
 *  \return         >=0                Valid index from the lookup engine.
 *  \return         <0                 OBD MID is not supported (disabled | in variant)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc06GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue);
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc08GetAvailabilityMask()
 *********************************************************************************************************************/
/*! \brief          Returns the calibrated state of an OBD TID.
 *  \details        -
 *  \param[in]      id                 The OBD TID to be verified.
 *  \param[out]     pMaskValue         A pointer to the OBD TID availability range mask list
 *  \return         >=0                Valid index from the lookup engine.
 *  \return         <0                 OBD MID is not supported (disabled | in variant)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc08GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue);
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc09GetAvailabilityMask()
 *********************************************************************************************************************/
/*! \brief          Returns the calibrated state of an OBD VID.
 *  \details        -
 *  \param[in]      id                 The OBD VID to be verified.
 *  \param[out]     pMaskValue         A pointer to the OBD VID availability range mask list
 *  \return         >=0                Valid index from the lookup engine.
 *  \return         <0                 OBD VID is not supported (disabled | in variant)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc09GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue);
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessEcuReset()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 EcuReset mode switching management
 *  \details        Manages the mode switches for service 0x11. If something goes wrong, an appropriate NRC will be sent.
 *  \param[in]      mode                The ECU reset mode to be switched into
 *  \param[out]     ErrorCode           The NRC
 *  \return         DCM_E_NOT_OK        Send response (negative)
 *  \return         DCM_E_LOOP          Process immediately with next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessEcuReset(Dcm_ModeMgrArEnvModeEcuResetType mode
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessRapPwrDwn()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 RapidPowerShutDown mode switching management
 *  \details        Manages the mode switches for service 0x11. If something goes wrong, an appropriate NRC will be sent.
 *  \param[in]      mode                The ECU reset mode to be switched into
 *  \return         DCM_E_NOT_OK        Send response (negative)
 *  \return         DCM_E_LOOP          Process immediately with next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessRapPwrDwn(Dcm_ModeMgrArEnvModeRapidPowerShutDownType mode
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x19 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc19ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByStatusMaskData()
 *********************************************************************************************************************/
/*! \brief          Compose response for any service 0x19 sub-function reporting number of DTC by status mask.
 *  \details        -
 *  \param[in]      dsfClass                DEM SetFilter class type
 *  \param[in]      dtcStatusMask           DTC status mask
 *  \param[in]      dtcSeverity             If severity specific search - define the severity level
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByStatusMaskData(
                                                                     Dcm_Svc19DemSetFilterClassType       dsfClass
                                                                    ,uint8                                dtcStatusMask
                                                                    ,Dem_DTCSeverityType                  dtcSeverity
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcByStatusMaskData()
 *********************************************************************************************************************/
/*! \brief          Compose response for any service 0x19 sub-function reporting DTC and status mask.
 *  \details        -
 *  \param[in]      dsfClass                DEM SetFilter class type
 *  \param[in]      maskUsage               Specifies how to treat the requested status mask (if any)
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcByStatusMaskData(
                                                                     Dcm_Svc19DemSetFilterClassType       dsfClass
                                                                    ,Dcm_Svc19DemSetFilterMaskUsageType   maskUsage
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportExtDataRecordByDtcNum()
 *********************************************************************************************************************/
/*! \brief          Compose response for any service 0x19 sub-function reporting DTC and its extended data record(s).
 *  \details        -
 *  \param[in]      dtcOrigin               The DTC origin to process
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportExtDataRecordByDtcNum(Dem_DTCOriginType        dtcOrigin
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*! \brief          Read the next filtered DTC and its FDC.
 *  \details        -
 *  \param[in,out]  pDataContext                Pointer to the data context
 *  \param[out]     ErrorCode                   The NRC
 *  \param[in,out]  pRepContext                 Current repeater proxy context
 *  \return         DCM_E_OK                    All data copied
 *  \return         DCM_E_PENDING               Retry later
 *  \return         DCM_E_BUFFERTOOLOW          Retry later, because of no available room any more
 *  \return         DCM_E_DATA_READY_PADDING    Force padding of remaining bytes
 *  \return         DCM_E_NOT_OK                Error occured
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdFDC(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainStart()
 *********************************************************************************************************************/
/*! \brief          Initiates a service processing chain of activities.
 *  \details        -
 *  \param[in]      funcChain     The function chain
 *  \param[in,out]  pRepContext   Current repeater proxy context
 *  \return         DCM_E_LOOP    Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainStart(
                                                   P2CONST(Dcm_RepeaterProgressType, AUTOMATIC, DCM_CONST) funcChain
                                                  ,Dcm_Svc19RepeaterProxyContextPtrType                    pRepContext);
# endif

# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainNext()
 *********************************************************************************************************************/
/*! \brief          Switches to the next processing activity in the chain specified by Dcm_Svc19UtiChainStart.
 *  \details        -
 *  \param[in,out]  pRepContext   Current repeater proxy context
 *  \return         DCM_E_LOOP    Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainNext(Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByOccurenceTime()
 *********************************************************************************************************************/
/*! \brief          Compose response for any service 0x19 sub-function reporting number DTC by occurence time.
 *  \details        -
 *  \param[in]      dtcOrigin               The DTC origin to process
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByOccurenceTime(Dem_DTCRequestType       dtcReqType
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcFFRByDtc()
 *********************************************************************************************************************/
/*! \brief          Compose response for any service 0x19 sub-function reporting DTC and its freze-frame data record(s).
 *  \details        -
 *  \param[in]      dtcOrigin      The DTC origin to process
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         DCM_E_LOOP     Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcFFRByDtc(Dem_DTCOriginType                   dtcOrigin
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext);
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiSetAttemptCntr()
 *********************************************************************************************************************/
/*! \brief          Notifies the application about changed attempt counter values.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  levelMask               Pointer to a security level mask.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27UtiSetAttemptCntr(Dcm_OpStatusType opStatus
                                                         ,P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc27ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 sub-function length getter
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc27ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc28EnableCommunication()
 *********************************************************************************************************************/
/*! \brief          Enable communication on all affected channels.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc28EnableCommunication(void);

/**********************************************************************************************************************
 *  Dcm_Svc28ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x28 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc28ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/* --- public members ---------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopAll()
 *********************************************************************************************************************/
/*! \brief          Stops all scheduled DIDs.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopAll(void);

# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByHandle()
 *********************************************************************************************************************/
/*! \brief          Stops a single scheduled item.
 *  \details        -
 *  \param[in]      schdHandle    The handle
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByHandle(Dcm_Svc2ASchdItemHandleOptType schdHandle);
# endif

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON) && \
     (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByDid()
 *********************************************************************************************************************/
/*! \brief          Cancels the reading of a single scheduled item.
 *  \details        -
 *  \param[in]      did    The did
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByDid(uint16 did);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByHandle()
 *********************************************************************************************************************/
/*! \brief          Stops a single scheduled item.
 *  \details        -
 *  \param[in]      schdHandle    The handle
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByHandle(Dcm_Svc2ASchdItemHandleOptType schdHandle);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByDid()
 *********************************************************************************************************************/
/*! \brief          Cancels the reading of a single scheduled item.
 *  \details        -
 *  \param[in]      did    The did
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByDid(uint16 did);

/* --- private members --------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetItemByDid()
 *********************************************************************************************************************/
/*! \brief          Look up for a scheduled DID.
 *  \details        -
 *  \param[in]      did    The did
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc2ASchdGetItemByDid(uint16 did);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFinishEntryProcessing()
 *********************************************************************************************************************/
/*! \brief          Finalizes scheduler entry processing (with or without response).
 *  \details        Resets all global states after a scheduler entry was processed. Initiates response transmission
 *                  or releases UUDT message.
 *  \param[in]      doSendResponse    Specifies whether a response shall be sent or not
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdFinishEntryProcessing(boolean doSendResponse);
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2ADidLookUp()
 *********************************************************************************************************************/
/*! \brief          A generic DID look-up for SID 0x2A.
 *  \details        Performs a lookup for a specific DID on any request.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \return         DCM_E_OK                Found a DID, make next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidLookUp(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext
                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                           ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_2C_CLEAR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrClear()
 *********************************************************************************************************************/
/*! \brief          Clear all DDID definitions.
 *  \details        Clears all previously defined DDIDs.
 *  \param[in]      dynDidHandle    DynDID reference to be cleared
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrClear(Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle);
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2CReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C sub-function length getter.
 *  \details        Always returns length of 0 byte to show that the requests have dynamic length and the concrete length
 *                  will be checked later.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc2CReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);

/**********************************************************************************************************************
 *  Dcm_Svc2CParseAndCheckDynDid()
 *********************************************************************************************************************/
/*! \brief          Parses and validates the DynDID to be defined.
 *  \details        -
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[out]     pRepContext    Current repeater proxy context
 *  \return         DCM_E_OK       Send response
 *  \return         DCM_E_NOT_OK   Send neagative response
 *  \return         DCM_E_PENDING  Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CParseAndCheckDynDid(Dcm_OpStatusType      opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);

/**********************************************************************************************************************
 *  Dcm_Svc2CCheckNumOfItems()
 *********************************************************************************************************************/
/*! \brief          Check DynDID has enough room to keep all requested definitions.
 *  \details        -
 *  \param[in]      numRequestedItems  Number of requested Items
 *  \param[in,out]  pRepContext        Current repeater proxy context
 *  \return         The NRC
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2CCheckNumOfItems(uint8 numRequestedItems
                                                                    ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc85EnableDtcSetting()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 enabler.
 *  \details        Calls the EnableDtcSetting function.
 *  \param[in]      DemClientId                The DEM ClientId
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85EnableDtcSetting(uint8 DemClientId);

# if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc85DisableDtcSetting()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 disabler.
 *  \details        Calls the DisableDtcSetting function.
 *  \param[in]      DTCGroup                   The DTC Group to be disabled
 *  \param[in]      DemClientId                The DEM ClientId
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85DisableDtcSetting(uint32 DTCGroup
                                                                   ,uint8  DemClientId);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc85ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 sub-function length getter.
 *  \details        Always returns length of 1 or 4 byte depending on whether the optional DTC group is supported.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc85ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);

/**********************************************************************************************************************
 *  Dcm_Svc85_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 worker.
 *  \details        Calls the Enable/DisableDTCSetting function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85_XX_RepeaterProxy(Dcm_OpStatusType      opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc85RepeaterProxyContextPtrType pRepContext);
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc86ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x86 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc86ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Uninitialized RAM of unspecified size
---------------------------------------------- */
#define DCM_START_SEC_VAR_NO_INIT_UNSPECIFIED
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/*! Sub-components per-instance memory */
DCM_LOCAL VAR(Dcm_InstanceContextType, DCM_VAR_NOINIT)  Dcm_InstanceContext;
/*! Sub-components shared memory */
DCM_LOCAL VAR(Dcm_SingletonContextType, DCM_VAR_NOINIT) Dcm_SingletonContext;
#define DCM_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Initialized RAM 8-Bit
---------------------------------------------- */
#define DCM_START_SEC_VAR_INIT_8
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/*! Dedicated RAM allocation for modules initialization state */
DCM_LOCAL VAR(Dcm_DebugInitStateType, DCM_VAR_INIT) Dcm_DebugInitState = DCM_DEBUG_INITSTATE_UNINIT;
#define DCM_STOP_SEC_VAR_INIT_8
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   ROM 8-Bit
---------------------------------------------- */
#define DCM_START_SEC_CONST_8
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/*! Converts DCMs implementation type definition values into the RTE Mode symbolic name values */
DCM_LOCAL CONST(Dcm_CommunicationModeType, DCM_CONST) Dcm_ModeComCtrlModeMap[12]=                                                                    /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
   RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_TX_NORM
  ,RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_DISABLE_TX_NORM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_ENABLE_TX_NORM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_TX_NORMAL
  ,RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_TX_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_DISABLE_TX_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_ENABLE_TX_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_TX_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_TX_NORM_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_ENABLE_RX_DISABLE_TX_NORM_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_ENABLE_TX_NORM_NM
  ,RTE_MODE_DcmCommunicationControl_DCM_DISABLE_RX_TX_NORM_NM
};
#endif /* (DCM_MODE_COMMCTRL_ENABLED == STD_ON) */
/*! A map to get the negative response code corresponding to a specific diagnostic entity (i.e. service, sub-service or parameter identifier */
DCM_LOCAL CONST(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_StateSessionNrcs[DCM_DIAG_NUM_CHK_LVLS]=                                                 /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_E_SERVICENOTSUPPORTEDINACTIVESESSION /* on SID level */
 ,DCM_E_REQUESTOUTOFRANGE /* on Parameter (DID, RID, etc.) level */
 ,DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION /* on SubFunction level */
};
#if (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_SVC_19_SETDTCFILTER_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_SETFFRECORDFILTER_ENABLED == STD_ON) || \
     (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_PARTIALLY TF tf tf xf */

#  if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/*! Dem SelectDTC API return value to NRC mapping */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_DemApiNrcMapSelectDTC[1]=                                                                                      /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
#  endif

/*! Dem SetDTCFilter API return value to NRC mapping */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_DemApiNrcMapSetDTCFilter[3]=                                                                                   /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_WRONG_FILTER, DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETNUMFILTEREDDTC_ENABLED == STD_ON) || \
     (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_PARTIALLY TF tf xf */
/*! Dem GetNumberOfFilteredDTC API return value to NRC mapping */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_DemApiNrcMapGetNumberOfFilteredDTC[3]=                                                                         /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_DEM_API_430_ENABLED == STD_OFF)
  DEM_NUMBER_FAILED, DCM_E_CONDITIONSNOTCORRECT,
#  endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif
#endif /* (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
DCM_LOCAL CONST(Dcm_RidMgrOpType, DCM_CONST) Dcm_RidMgrSubFunc2OpMap[4] =                                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  0x00u /* no operation */
  , DCM_RIDMGR_OP_START
  , DCM_RIDMGR_OP_STOP
  , DCM_RIDMGR_OP_REQRSLTS
};
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
/*! Diagnostic service verification level to NRC map */
DCM_LOCAL CONST(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DiagObjNotFoundNrcs[DCM_DIAG_NUM_CHK_LVLS]=                                              /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_E_SERVICENOTSUPPORTED     /*!< on SID level */
 ,DCM_E_REQUESTOUTOFRANGE       /*!< on Parameter (DID, RID, etc.) level */
 ,DCM_E_SUBFUNCTIONNOTSUPPORTED /*!< on SubFunction level */
};
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc04NrcMapClearDTC[]=                                                                                         /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_CLEAR_W_DTC,        DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_CLEAR_FAILED,       DCM_E_CONDITIONSNOTCORRECT,
# if defined(DCM_DEM_RET_CLEAR_BUSY)
  DCM_DEM_RET_CLEAR_BUSY,         DCM_E_CONDITIONSNOTCORRECT,
# endif
# if defined (DCM_DEM_RET_CLEAR_MEMORY_ERROR)
  DCM_DEM_RET_CLEAR_MEMORY_ERROR, DCM_E_CONDITIONSNOTCORRECT,
# endif
# if (DCM_DEM_API_430_ENABLED == STD_ON)
  DCM_DEM_RET_CLEAR_W_ORIGIN,     DCM_E_REQUESTOUTOFRANGE,
# else
  /* DCM_DEM_RET_CLEAR_W_ORIGIN,  DCM_E_PANIC_NRC  - shall not occur since DCM sets the origin -> enforce DET */
# endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/*! Mapping of DEM Clear operation results to DCM NRCs */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc14NrcMapClearDTC[]=                                                                                         /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_CLEAR_W_DTC,        DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_CLEAR_FAILED,       DCM_E_CONDITIONSNOTCORRECT,
# if defined(DCM_DEM_RET_CLEAR_BUSY)                                                                                                                 /* COV_DCM_SUPPORT_ALWAYS TX */
  DCM_DEM_RET_CLEAR_BUSY,         DCM_E_CONDITIONSNOTCORRECT,
# endif
# if defined (DCM_DEM_RET_CLEAR_MEMORY_ERROR)
  DCM_DEM_RET_CLEAR_MEMORY_ERROR, DCM_E_GENERALPROGRAMMINGFAILURE,
# endif
# if (DCM_DEM_API_430_ENABLED == STD_ON)
  DCM_DEM_RET_CLEAR_W_ORIGIN,     DCM_E_REQUESTOUTOFRANGE,
# else
  /* DCM_DEM_RET_CLEAR_W_ORIGIN,  DCM_E_PANIC_NRC  - shall not occur since DCM sets the origin -> enforce DET */
# endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
/*! List of all (UDS and OBD) extended data records DEM supports */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19ExtDataRecords[DCM_SVC_19_EXTDATA_RECID_SIZE]=                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_SVC_19_NUM_EXTDATA_RECID > 0)                                                                                                             /* COV_DCM_SUPPORT_ALWAYS TX */
 DCM_SVC_19_LST_EXTDATA_RECID,
#  endif
 DCM_SVC_19_RECLIST_END /* end marker */
};
# endif

# if (DCM_SVC_19_OBD_EXT_RECORD_ENABLED == STD_ON)                                                                                                   /* COV_DCM_UNSUPPORTED XF */
/*! List of all OBD extended data records DEM supports */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19ExtDataRecordsObd[DCM_SVC_19_OBD_EXTDATA_RECID_SIZE]=                                                     /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_SVC_19_NUM_OBD_EXTDATA_RECID > 0)
 DCM_SVC_19_LST_OBD_EXTDATA_RECID,
#  endif
 DCM_SVC_19_RECLIST_END /* end marker */
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
/*! List of all freeze frame data records DEM supports */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19FFDataRecords[DCM_SVC_19_FRZFRAME_RECID_SIZE]=                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_SVC_19_NUM_FRZFRAME_RECID > 0)                                                                                                            /* COV_DCM_SUPPORT_ALWAYS TX */
 DCM_SVC_19_LST_FRZFRAME_RECID,
#  endif
 DCM_SVC_19_RECLIST_END /* end marker */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETDTCSAM_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_GETDTCSEVAM_ENABLED == STD_ON)
/*! DEM API with Std_ReturnType result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapStdReturnType[3]=                                                                                   /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  E_NOT_OK, DCM_E_CONDITIONSNOTCORRECT,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETDTCOCCURTIME_ENABLED == STD_ON)
/*! DEM API "GetDTCByOccurrenceTime" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetDTCByOccurrenceTime[] =                                                                          /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if defined (DCM_DEM_RET_OCCURR_N_OK)
  DCM_DEM_RET_OCCURR_N_OK, DCM_E_GENERALREJECT,
#  endif
#  if defined (DCM_DEM_RET_OCCURR_NO_SUCH_ELEMENT)
  DCM_DEM_RET_OCCURR_NO_SUCH_ELEMENT, DCM_E_POSITIVERESPONSE,
#  endif
#  if defined (DCM_DEM_RET_OCCURR_NOT_AVAILABLE)
  DCM_DEM_RET_OCCURR_NOT_AVAILABLE, DCM_E_POSITIVERESPONSE,
#  endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_SVC_19_05_SUPPORT_ENABLED == STD_ON)
/*! DEM API "GetOBDFreezeFrameData" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetOBDFreezeFrameData[1]=                                                                           /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
/*! DEM API "DisableDTCRecordUpdate", "EnableDTCRecordUpdate" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapAnyAbleRecordUpdate[]=                                                                              /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_DISABLE_DTC_REC_UP_WRONG_DTCORIGIN, DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_DISABLE_DTC_REC_UP_WRONG_DTC,       DCM_E_REQUESTOUTOFRANGE,
#  if defined (DCM_DEM_RET_DISABLE_DTC_REC_UP_WRONG_CONDITION)
  /* Let it be handled in default case (PANIC NRC + DET error) since this means wrong DCM implementation */
  /* DCM_DEM_RET_DISABLE_DTC_REC_UP_WRONG_CONDITION, DCM_E_PANIC, */
#  endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSTATUSOFDTC_ENABLED == STD_ON)
/*! DEM API "GetStatusOfDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetStatusOfDTC[] =                                                                                  /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_STATUS_WRONG_DTC,       DCM_E_REQUESTOUTOFRANGE,
#  if defined (DCM_DEM_RET_STATUS_FAILED)
  DCM_DEM_RET_STATUS_FAILED,          DCM_E_CONDITIONSNOTCORRECT,
#  endif
  DCM_DEM_RET_STATUS_WRONG_DTCORIGIN, DCM_E_CONDITIONSNOTCORRECT,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/*! DEM API "GetSeverityOfDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetSeverityOfDTC[] =                                                                                /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_GET_SEVERITY_OF_DTC_WRONG_DTC, DCM_E_REQUESTOUTOFRANGE,
#  if defined (DCM_DEM_RET_GET_SEVERITY_OF_DTC_WRONG_DTCORIGIN)
  DCM_DEM_RET_GET_SEVERITY_OF_DTC_WRONG_DTCORIGIN, DCM_E_REQUESTOUTOFRANGE,
#  endif
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/*! DEM API "GetFunctionalUnitOfDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetFunctionalUnitOfDTC[] =                                                                          /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if defined (DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_WRONG_DTCORIGIN)
  DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_WRONG_DTCORIGIN,  DCM_E_REQUESTOUTOFRANGE,
#  endif
  DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_WRONG_DTC,        DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFEXTRECORD_ENABLED == STD_ON)
/*! DEM API "GetSizeOfExtendedDataRecordByDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetSizeOfExtendedDataRecordByDTC[] =                                                                /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if defined (DCM_DEM_RET_SIZEOFEDR_N_OK)
  /* Let it be handled in default case (PANIC NRC + DET error) since this means wrong DCM implementation */
  /* DCM_DEM_RET_SIZEOFEDR_N_OK,     DCM_E_PANIC, */
#  endif
  DCM_DEM_RET_SIZEOFEDR_W_DTC,    DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFEDR_W_RNUM,   DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFEDR_W_ORIGIN, DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFFFRECORD_ENABLED == STD_ON)
/*! DEM API "GetSizeOfFreezeFrameByDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetSizeOfFreezeFrameByDTC[] =                                                                       /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if defined (DCM_DEM_RET_SIZEOFFFR_N_OK)
  /* Let it be handled in default case (PANIC NRC + DET error) since this means wrong DCM implementation */
  /* DCM_DEM_RET_SIZEOFFFR_N_OK,     DCM_E_PANIC, */
#  endif
  DCM_DEM_RET_SIZEOFFFR_W_DTC,    DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFFFR_W_RNUM,   DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFFFR_W_ORIGIN, DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED == STD_ON)
/*! DEM API "GetFreezeFrameDataByDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetFreezeFrameDataByDTC[7]=                                                                         /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_FFDATABYDTC_W_DTC,    DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_FFDATABYDTC_W_ORIGIN, DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_FFDATABYDTC_W_RNUM,   DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
/*! DEM API "GetExtendedDataRecordByDTC" result to NRC map */
DCM_LOCAL CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetExtendedDataRecordByDTC[7]=                                                                      /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_DTC,       DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_DTCORIGIN, DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_NUMBER,    DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
DCM_LOCAL CONST(Dcm_DidMgrOpMemType, DCM_CONST) Dcm_Svc2FCtrlOp2DidOpTypeMap[4]=                                                                     /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU
 ,DCM_DIDMGR_OPTYPE_IO_RST2DEF
 ,DCM_DIDMGR_OPTYPE_IO_FRZCURSTATE
 ,DCM_DIDMGR_OPTYPE_IO_SHRTTRMADJ
};
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CONST_8
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   ROM of unspecified size
---------------------------------------------- */
#define DCM_START_SEC_CONST_UNSPECIFIED
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/*! Configuration of all DCM internal tasks */
DCM_LOCAL CONST(Dcm_TskTaskInfoType, DCM_CONST) Dcm_TskTaskInfo[DCM_TSK_NUM_TASKS]=                                                                  /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  /* first to be processed */
#if (DCM_TSK_NUM_DIAG_RECOVERY > 0)                                                                                                                  /* COV_DCM_UNSUPPORTED XF */
  {Dcm_DiagTaskRecovery,     (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE}, /* Task to recover an external stored DCM state */
#endif
#if (DCM_TSK_NUM_NET_TA_MONITOR > 0)
  {Dcm_NetTaskTaMonitor,     (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_NONE}, /* Requests with a foreign N_TA will be handled here */
#endif
#if (DCM_TSK_NUM_NET_RX > 0)
  {Dcm_NetTaskRx,            (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_NONE}, /* The P2 timer will be started here - put this task prior timer task. NetRx task must always work */
#endif
  {Dcm_TmrTaskTimer,         (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_NONE}, /* process timers first, the tasks will do their job according to the event priorities. Never kill timer task! */
  {Dcm_DiagTaskRx,           (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_ALWAYS), DCM_TSK_PRIO_HIGH, (DCM_TSK_EV_DIAG_RX_TMR_P2_TO | DCM_TSK_EV_DIAG_RX_NEW_REQ)},
#if (DCM_TSK_NUM_MODE_MONITOR > 0)
  {Dcm_ModeTaskMonitor,      (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE}, /* let monitors work in the background */
#endif
#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
  {Dcm_DiagTaskFblRes,       (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE},/* let FBL work in the background till end */
#endif
#if (DCM_TSK_NUM_SVC27 > 0)
  {Dcm_Svc27Task,            (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE}, /* Collects the attempt counter values */
#endif
  {Dcm_DiagTaskWorker,       (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_ALWAYS), DCM_TSK_PRIO_LOW,  (DCM_TSK_EV_DIAG_WORK_KILL_JOBS|DCM_TSK_EV_DIAG_WORK_INT_SET2DEF|DCM_TSK_EV_DIAG_WORK_NEW_REQ|DCM_TSK_EV_DIAG_WORK_TX_END_FINAL)},
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  {Dcm_PagedBufferTask,      (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_ALWAYS), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE},
#endif
#if (DCM_TSK_NUM_ROE > 0)                                                                                                                            /* COV_DCM_UNSUPPORTED XF */
  {Dcm_ExtSvc86Task,         (DCM_TSK_ATR_ROE_EXEC   | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE}, /* let RoE work in the background - if RoE triggered the client prioritization will take place */
#endif
#if (DCM_TSK_NUM_DIAG_GARB_COL > 0)
  {Dcm_DiagTaskGarbageCollector, (DCM_TSK_ATR_EXEC_ONCE | DCM_TSK_ATR_KILL_NEVER),  DCM_TSK_PRIO_HIGH, 0},
#endif
  {Dcm_DiagTaskTx,           (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_ALWAYS), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_DIAG_TX_SEND_RCRRP},
#if (DCM_TSK_NUM_SVC2A_SCHEDULER > 0)                                                                                                                /* COV_DCM_UNSUPPORTED XF */
  {Dcm_Svc2ATaskSchdProcess, (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW,  DCM_TSK_EV_NONE},/* let 0x2A work in the background if needed to be stopped -> the stop all API shall be used */
#endif
  {Dcm_NetTaskTx,            (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_NONE}
  /* last to be processed */
};
DCM_LOCAL CONST(Dcm_TmrTimerInfoType, DCM_CONST) Dcm_TmrTimerInfo[DCM_TMR_NUM_TIMERS] =                                                              /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  {Dcm_OnTimeoutP2}
 ,{Dcm_OnTimeoutS3}
#if (DCM_TMR_NUM_FBLRES > 0)
 ,{Dcm_OnTimeoutFblRes}
#endif
#if (DCM_TMR_NUM_SECURITY_0 > 0)
 ,{Dcm_OnTimeoutSecurityAccess_0}
#endif
#if (DCM_TMR_NUM_SECURITY_1 > 0)                                                                                                                     /* COV_DCM_UNSUPPORTED XF */
 ,{Dcm_OnTimeoutSecurityAccess_1}
#endif
#if (DCM_TMR_NUM_PERIODIC_TX > 0)                                                                                                                    /* COV_DCM_UNSUPPORTED XF */
 ,{Dcm_OnTimeoutPeriodicTx}
#endif
#if (DCM_TMR_NUM_SVC2A_SCHEDULER > 0)                                                                                                                /* COV_DCM_UNSUPPORTED XF */
 ,{Dcm_OnTimeoutSvc2AScheduler}
#endif
#if (DCM_TMR_NUM_SVC86_INTERMESSAGETIME > 0)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
 ,{Dcm_ExtOnTimeoutSvc86InterMessageTime}
#endif
#if (DCM_TMR_NUM_KEEP_ALIVE > 0)
 ,{Dcm_OnTimeoutKeepAlive}
#endif
};
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_19_SETDTCFILTER_INFO_CLASS_ENABLED == STD_ON)
/*! A set of all required DEM filter configurations */
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
DCM_LOCAL CONST(Dcm_Svc19DemDtcFilterInfoType, DCM_CONST) Dcm_Svc19DemDtcFilterInfo[DCM_SVC_19_DEM_SETFILTER_NUM_CLASSES]=                           /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  {DEM_DTC_ORIGIN_PRIMARY_MEMORY,      FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_01: SF 0x01, 0x02, 0x14, 0x0A */
 ,{DEM_DTC_ORIGIN_PRIMARY_MEMORY,      TRUE}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_02: SF 0x07, 0x08 */
 ,{DEM_DTC_ORIGIN_MIRROR_MEMORY,       FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_03: SF 0x11, 0x0F */
 ,{DEM_DTC_ORIGIN_OBD_RELEVANT_MEMORY, FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_04: SF 0x12, 0x13 */
 ,{DEM_DTC_ORIGIN_PERMANENT_MEMORY,    FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_05: SF 0x15 */
 ,{DEM_DTC_ORIGIN_SECONDARY_MEMORY,    FALSE} /* DCM_SVC_19_DEM_SETFILTER_CLASS_06: SF 0x17 */ /* 0x17: mem selection from request */
 ,{DEM_DTC_ORIGIN_OBD_RELEVANT_MEMORY, TRUE}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_07: SF 0x42 */
};
#  else
DCM_LOCAL CONST(Dcm_Svc19DemDtcFilterInfoType, DCM_CONST) Dcm_Svc19DemDtcFilterInfo[DCM_SVC_19_DEM_SETFILTER_NUM_CLASSES]=                           /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  {DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_PRIMARY_MEMORY,   DCM_DEM_FILTER_WITH_SEVERITY_NO}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_01: SF 0x01, 0x02, 0x14, 0x0A */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_PRIMARY_MEMORY,   DCM_DEM_FILTER_WITH_SEVERITY_YES} /* DCM_SVC_19_DEM_SETFILTER_CLASS_02: SF 0x07, 0x08 */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_MIRROR_MEMORY,    DCM_DEM_FILTER_WITH_SEVERITY_NO}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_03: SF 0x11, 0x0F */
 ,{DEM_DTC_KIND_EMISSION_REL_DTCS,  DEM_DTC_ORIGIN_PRIMARY_MEMORY,   DCM_DEM_FILTER_WITH_SEVERITY_NO}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_04: SF 0x12, 0x13 */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_PERMANENT_MEMORY, DCM_DEM_FILTER_WITH_SEVERITY_NO}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_05: SF 0x15 */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_SECONDARY_MEMORY, DCM_DEM_FILTER_WITH_SEVERITY_NO}  /* DCM_SVC_19_DEM_SETFILTER_CLASS_06: SF 0x17 */
 ,{DEM_DTC_KIND_EMISSION_REL_DTCS,  DEM_DTC_ORIGIN_PRIMARY_MEMORY,   DCM_DEM_FILTER_WITH_SEVERITY_YES} /* DCM_SVC_19_DEM_SETFILTER_CLASS_07: SF 0x42 */
};
#  endif
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON) || \
     (DCM_SVC_19_05_SUPPORT_ENABLED             == STD_ON)
/*! List of actions for acquiring DTC status and reporting it together with the DTC itself. This is also a termination activity chain triggering the final positive response */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19DemChainGetDtcStatusEnd[] =                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC,
#  endif
  DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC
 ,DCM_SVC19_PROGRESS_CHAIN_END
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
/*! List of actions for freeze-frame data reporting prolog */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19DemChainReadFFRByDtc[] =                                                               /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC,
#  endif
  DCM_SVC19_PROGRESS_DEMCHAIN_DISABLERECORDUPDATE
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC
#  if (DCM_DEM_API_SELECT_FFR_ENABLED == STD_ON)
 ,DCM_SVC19_PROGRESS_DEMCHAIN_SELECTFFREC
#  endif
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFFFREC
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
/*! List of actions for extended data reporting prolog */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19DemChainReadExtRecords[] =                                                             /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC,
#  endif
  DCM_SVC19_PROGRESS_DEMCHAIN_DISABLERECORDUPDATE
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC
#  if (DCM_DEM_API_SELECT_EDR_ENABLED == STD_ON)
 ,DCM_SVC19_PROGRESS_DEMCHAIN_SELECTEXTDATAREC
#  endif
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFEXTDATAREC
};
# endif

# if (DCM_SVC_19_09_SUPPORT_ENABLED == STD_ON)
/*! List of actions for complete processing of SF 0x09 */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19_09DemChain[] =                                                                        /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC,
#  endif
  DCM_SVC19_PROGRESS_DEMCHAIN_GETSEVERITYOFDTC
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETFUNCUNITOFDTC
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC
 ,DCM_SVC19_PROGRESS_CHAIN_END
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/*! List of actions for complete processing of a SF reporting the number of filtered DTCs */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19DemChainDtcCount[2] =                                                                  /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC
 ,DCM_SVC19_PROGRESS_DEMCHAIN_PUTNUMFLTRDDTC
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/*! List of actions for complete processing of a SF reporting DTCs filtered by status mask */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19DemChainReadDtcByStatus[2] =                                                           /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
 DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC /* let this API to be called also in linear-buffer case in order to check for the last time if any DEM state error has occurred */
,DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDDTC
};
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/*! List of actions for complete processing of SF 0x08 */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19_08DemChain[2] =                                                                       /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDSEVERITY
};
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/*! List of actions for complete processing of SF 0x14 */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19_14DemChain[2] =                                                                       /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC
 ,DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDFDC
};
# endif
# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/*! List of actions for complete processing of SF 0x42 */
DCM_LOCAL CONST(Dcm_RepeaterProgressType, DCM_CONST) Dcm_Svc19_42DemChain[2] =                                                                       /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC /* let this API to be called also in linear-buffer case in order to check for the last time if any DEM state error has occurred */
 ,DCM_SVC19_PROGRESS_DEMCHAIN_WWHOBD_GETNEXTFLTRDSEVERITY
};
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CONST_UNSPECIFIED
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Inlined function implementations (Top Level)
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_UTI_LOOKUP_RANGE_U16_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_UtiLookUpRangeUint16()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint16_least, DCM_CODE) Dcm_UtiLookUpRangeUint16(P2CONST(Dcm_UtiU16RangeType, AUTOMATIC, DCM_CONST) lookUpTable
                                                                      ,uint16 value)
{
  sint16_least  lResult;
  uint16_least  loIdx;
  uint16_least  hiIdx;
  uint16_least  lPosition;

  /* #10 Initialize look-up: assume nothing will be found */
  lResult = -1;
  loIdx= 1;
  hiIdx= lookUpTable[0].First;/* Take one of the borders since both have the same value */

  /* #20 If any sub-array exists: */
  while (loIdx <= hiIdx)
  {
    /*  #30 Calculate entry position for comparison */
    lPosition = (uint16_least)(loIdx + ((hiIdx - loIdx) / 2)); /* avoids overflows on value addition */

    /* #40 If valid range found:  */
    if( (lookUpTable[lPosition].First <= value)
      &&(lookUpTable[lPosition].Second >= value) )
    {
      /* #50 Return valid entry position (compensate offset) */
      lResult = (sint16_least)(lPosition - 1);
      break;
    }
    /* #60 Otherwise - continue searching */

    /* #70 Determine which sub-array shall be taken as a next */
    if (value < lookUpTable[lPosition].First)
    {
      /* not needed lPosition zero value check, since loIdx >=1 */
      hiIdx = (uint16_least)(lPosition - 1);
    }
    else
    {
      /* Use upper half of interval */
      loIdx = (uint16_least)(lPosition + 1);
    }
  }
  /* #80 Otherwise - report nothing found  */

  return lResult;
}
#endif
/**********************************************************************************************************************
 *  Dcm_PagedBufferInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferInit(void)
{
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_InstanceContext.PagedBuffer.State = DCM_PAGEDBUFFER_STATE_INACTIVE;
#endif
}

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferDefragmentPage()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferDefragmentPage(void)
{
  Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;
  Dcm_CfgNetBufferSizeOptType   lPageSize;

  lBufferInfo = Dcm_NetGetBufferInfo(Dcm_InstanceContext.PagedBuffer.BufferHdl);
  lPageSize = (Dcm_CfgNetBufferSizeOptType)( Dcm_InstanceContext.PagedBuffer.WriteIndex
                                           - Dcm_InstanceContext.PagedBuffer.ReadIndex);

  Dcm_UtiMemCopySafe(&(lBufferInfo->BufferPtr[Dcm_InstanceContext.PagedBuffer.ReadIndex])
                    ,lBufferInfo->BufferPtr
                    ,0u
                    ,lBufferInfo->Size
                    ,lPageSize);                                                                                                                     /* SBSW_DCM_POINTER_WRITE_BUFFERINFO */

  /* Enter critical section (Reason: Protect against hi-priority task /ISR CopyTxData) */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /* Update Read- and Write-Index */
  Dcm_InstanceContext.PagedBuffer.ReadIndex  = 0u;
  Dcm_InstanceContext.PagedBuffer.WriteIndex = (Dcm_CfgNetBufferSizeMemType)lPageSize;
  /* Leave critical section */
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferUpdatePage()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferUpdatePage(Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lStdResult;
  Dcm_DiagDataContextType       lDataContext;
  Dcm_DiagSvcUpdateFuncType     lUpdateFunc;
  Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;
  uint8 lUpdaterDataProvisionState;

  lUpdateFunc = Dcm_DiagGetUpdateFunc(Dcm_InstanceContext.PagedBuffer.UpdateFuncRef);
  lBufferInfo = Dcm_NetGetBufferInfo(Dcm_InstanceContext.PagedBuffer.BufferHdl);

  Dcm_DebugAssert((Dcm_InstanceContext.PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                  /* COV_DCM_RTM_DEV_DEBUG XF */

  /* If defragmentation needed: */
  if ((Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState == DCM_PAGEDBUFFER_WAIT_FOR_DATA)
    &&(Dcm_InstanceContext.PagedBuffer.ReadIndex != 0) )
  {
    Dcm_PagedBufferDefragmentPage();
  }

  /* Derive new data context for the remaining data to be read */
  Dcm_DiagInitDataContext(&lDataContext, lBufferInfo->BufferPtr, lBufferInfo->Size);                                                                 /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */
  Dcm_DiagCommitData(&lDataContext, Dcm_InstanceContext.PagedBuffer.WriteIndex);                                                                     /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */

  /* Stronger limitation of the available buffer size - cut to the response length */
  if(lDataContext.AvailLen > Dcm_InstanceContext.PagedBuffer.RemainingLen)
  {
    lDataContext.AvailLen = Dcm_InstanceContext.PagedBuffer.RemainingLen;
  }

  /* Delegate to the page writer */
  lStdResult = lUpdateFunc(&lDataContext, ErrorCode);                                                                                                /* SBSW_DCM_CALL_FUNCPTR_SVCUPDATERS */

  switch(lStdResult)
  {
    case DCM_E_OK:
    case DCM_E_NOT_OK:
      Dcm_InstanceContext.PagedBuffer.UpdateFinished = TRUE;
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_ALL_DATA_PROVIDED;
      break;
    case DCM_E_DATA_READY_PADDING:
      /* Delegate to the padding writer */
      Dcm_InstanceContext.PagedBuffer.UpdateFuncRef = DCM_PAGEDBUFFER_PADDING_FUNC_REF;
      /* Application is done, now call the padding-bytes provider */
      Dcm_InstanceContext.PagedBuffer.UpdateFinished = TRUE;
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED;
      break;
    case DCM_E_PENDING:
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_WAIT_FOR_DATA;
        break;
    case DCM_E_BUFFERTOOLOW:
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED;
      break;
    default:/* Unexpected return value */                                                                                                            /* COV_DCM_RTM_UNREACHABLE X */
      lStdResult = DCM_E_NOT_OK; /* Assure only valid values from here on */
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_InstanceContext.PagedBuffer.UpdateFinished = TRUE;
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_ALL_DATA_PROVIDED;
      break;
  }

  if(lStdResult == DCM_E_NOT_OK)
  {
    if(Dcm_InstanceContext.PagedBuffer.State == DCM_PAGEDBUFFER_STATE_ACTIVATED)
    {
      /* Reset paged-buffer usage and delegate to the linear buffer processor */
      Dcm_InstanceContext.PagedBuffer.State = DCM_PAGEDBUFFER_STATE_CANCELED;
    }
    else
    {
      /* Wait for under-run transmission interruption (simulate successful update with zero data size) */
      lStdResult = DCM_E_OK;
    }
    Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState = lUpdaterDataProvisionState;
  }
  else
  {
    /* Enter critical section (Reason: Protect against hi-priority task /ISR CopyTxData) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /* Update statistic */
    Dcm_InstanceContext.PagedBuffer.RemainingLen -= (Dcm_MsgLenType)(lDataContext.Usage - Dcm_InstanceContext.PagedBuffer.WriteIndex);
    Dcm_InstanceContext.PagedBuffer.WriteIndex = (Dcm_CfgNetBufferSizeMemType)lDataContext.Usage;

    /* Unlock CopyTx Data if more data is expected to be provided by a paged-buffer updater */
    Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState = lUpdaterDataProvisionState;

    /* Leave critical section */
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

  /* If transmission not yet started and some data is already available for transmission: */
  if ((Dcm_InstanceContext.PagedBuffer.State == DCM_PAGEDBUFFER_STATE_ACTIVATED)
    && (lStdResult != DCM_E_PENDING))
  {
    /* Activate transmission */
    Dcm_InstanceContext.PagedBuffer.State = DCM_PAGEDBUFFER_STATE_ONTX;
    Dcm_InstanceContext.Diag.State |= DCM_DIAG_STATE_ON_TX; /* update diagnostic state (PROCESS && ON_TX) */
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_PAGED);
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
                                                                   P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) PduInfo                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,PduLengthType Length)                                                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  BufReq_ReturnType              lResult = BUFREQ_OK;
  PduLengthType                  lPageSize;

  Dcm_DebugAssert((Dcm_InstanceContext.PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE)
                 ,DCM_SID_PROVIDETXBUFFER, DCM_E_ILLEGAL_STATE)                                                                                      /* COV_DCM_RTM_DEV_DEBUG XF */

  /*
   lPageSize |    Length    | PagedBufferState  | lResult |  BufferSize
  -----------+--------------+-------------------+---------+-------------
      0      |     any      | no data available |  BUSY   |  n/a
     != 0    |      0       | data available    |   OK    |  lPageSize
     != 0    | <= lPageSize | data available    |   OK    |  Length
     != 0    | > lPageSize  | too few data      |  BUSY   |  n/a
  */

  /* Calculate and return page size */
  lPageSize = (PduLengthType)(Dcm_InstanceContext.PagedBuffer.WriteIndex - Dcm_InstanceContext.PagedBuffer.ReadIndex);

  if ((Length <= lPageSize) && (lPageSize != 0))
  {
    Dcm_PbCfgNetBufferInfoPtrType lBufferInfo = Dcm_NetGetBufferInfo(Dcm_InstanceContext.PagedBuffer.BufferHdl);

    /* Point sdu data pointer to page buffer read index */
    PduInfo->SduDataPtr = &(lBufferInfo->BufferPtr[Dcm_InstanceContext.PagedBuffer.ReadIndex]);                                                      /* SBSW_DCM_PARAM_PTR_WRITE */

    if (Length == 0)
    {
      /* set sdu length to amount of data available in the page */
      PduInfo->SduLength = lPageSize;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      /* Set sdu length to the requested length */
      PduInfo->SduLength = Length;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    Dcm_InstanceContext.PagedBuffer.ReadIndex += (Dcm_CfgNetBufferSizeMemType)(PduInfo->SduLength);
  }
  else
  {
    lResult = BUFREQ_E_BUSY; /* avoid coping data during defragmenting of the paged-buffer */

    /* check if paged-buffer update is possible */
    if (Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState == DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED)
    {
      Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState = DCM_PAGEDBUFFER_WAIT_FOR_DATA;
      Dcm_TskSetEvent(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_PGDBUF_UPDATE_PAGE); /* re-activate page updater */
    } /* else - still waiting for the data or all data provided */
  }

  return lResult;
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
                                                       P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                      ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  BufReq_ReturnType  lResult = BUFREQ_OK;

  Dcm_DebugAssert((Dcm_InstanceContext.PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_COPYTXDATA
                 ,DCM_E_ILLEGAL_STATE)                                                                                                               /* COV_DCM_RTM_DEV_DEBUG XF */

  *availableDataPtr = (PduLengthType)(Dcm_InstanceContext.PagedBuffer.WriteIndex
                                      - Dcm_InstanceContext.PagedBuffer.ReadIndex); /* Calculate and return page size */                             /* SBSW_DCM_PARAM_PTR_WRITE */

  if( (*availableDataPtr == 0u) /* no data at all */
    ||(*availableDataPtr < info->SduLength) ) /* real under-run */
  {
    if(info->SduLength != 0)
    {
      lResult = BUFREQ_E_BUSY;
    }/* else - just buffer size check */

    if ((Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState == DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED)
      &&(Dcm_InstanceContext.PagedBuffer.RemainingLen != 0) )
    {
      Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState = DCM_PAGEDBUFFER_WAIT_FOR_DATA;
      Dcm_TskSetEvent(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_PGDBUF_UPDATE_PAGE);/* re-activate page updater */
    }/* else - still waiting for the data or all data provided */
  }
  else /* (lPageSize != 0) && (lPageSize >= info->SduLength) => <check buffer availability> */
  {
    if ((Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState == DCM_PAGEDBUFFER_WAIT_FOR_DATA) /* still waiting for data OR data is currently being written */
      &&(Dcm_InstanceContext.PagedBuffer.ReadIndex != 0) /* with needed defragmentation */
      &&(info->SduLength != 0) )/* no buffer availability check request */
    {
      lResult = BUFREQ_E_BUSY;/* avoid coping data during defragmentation of the paged-buffer (i.e. in case of adaptive CopyTxData call with reducing SduLength each time, or when SduLength == 0, and immediately called again with SduLength != 0 */
    }
    else
    {
      Dcm_PbCfgNetBufferInfoPtrType lBufferInfo = Dcm_NetGetBufferInfo(Dcm_InstanceContext.PagedBuffer.BufferHdl);

      *availableDataPtr -= info->SduLength; /* Update remained data part */                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Take the linear case always */
      Dcm_UtiMemCopySafe(&(lBufferInfo->BufferPtr[Dcm_InstanceContext.PagedBuffer.ReadIndex])
                        ,info->SduDataPtr
                        ,0u
                        ,info->SduLength
                        ,info->SduLength);                                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_InstanceContext.PagedBuffer.ReadIndex += (Dcm_CfgNetBufferSizeMemType)(info->SduLength);
    }
  }
  return lResult;
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DidMgrInitMainResources()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrInitMainResources(void)
{
# if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce = 0u;
# endif
# if (DCM_DIDMGR_2E_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.DidMgr.DidRsrcContext.Write = 0u;
# endif
# if (DCM_DIDMGR_2F_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.DidMgr.DidRsrcContext.Io = 0;
# endif
  /* readPeriodic and readDynamic have own cancellation mechanisms */
}

/**********************************************************************************************************************
 *  Dcm_DidMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrInit(void)
{
# if (DCM_DIDMGR_2A_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadPeriodic = 0u;
# endif
# if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic  = 0u;
# endif
  Dcm_DidMgrInitMainResources();

# if (DCM_DIDMGR_IODID_NBYTE_EXT_CEMR_ENABLED == STD_ON)
  /* Set default ReturnControlToEcu values to 0xFF...FF */
  Dcm_UtiMemSetUintX(Dcm_InstanceContext.DidMgr.IoControlCemrSessionMask, Dcm_MsgItemType, 0xFFu, DCM_DIDMGR_IODID_MAX_EXT_CEMR_SIZE_CONST);         /* PRQA S 3109 */ /* MD_MSR_14.3 */
# endif
}

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) && \
     (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetGapRemainingLen()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetGapRemainingLen(
                                                                      Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext)                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_CfgNetBufferSizeOptType lGapLength;

  /* #10 If the gap is a the end of the DID: */
  if(pDidOpTypeContext->Base.NumSignals == 0u)
  {
    /* #20 Calculate the gap length by using the DID length information */
    lGapLength = pDidInfoContext->DidLength
               - pDidOpTypeContext->OpType.Read.Progress;
  }
  else
  {
    /* #30 Otherwise calculate the gap length by using the signal offset */
    lGapLength = pDidOpTypeContext->OpType.Read.Offset
               - pDidOpTypeContext->OpType.Read.Progress;
  }

  return lGapLength;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetSignalLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetSignalLength(
                                                                Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                               ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext)                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_CfgNetBufferSizeOptType lSignalLength;

#  if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
  /* #20 If the signal has a variable length: */
  if(pDidOpTypeContext->Base.SignalInfoList->Length == 0)
  {
    /* #30 Calculate the length of the signal. A signal with variable length is always the last signal of the DID */
    lSignalLength = pDidInfoContext->DidLength - pDidOpTypeContext->OpType.Read.Offset;
  }
  else
  {
    /* #40 Otherwise return the signal length */
    lSignalLength = pDidOpTypeContext->Base.SignalInfoList->Length;
  }
#  else
  DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Check for non-paged caller. If paged -> return length 1 (minimum length) */
  Dcm_DebugAssert((pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr->FuncClass != DCM_DIDMGR_OPCLS_READ_PAGED), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE) /* COV_DCM_RTM_DEV_DEBUG XF */

  /* #50 Otherwise return the DID length */
  /*
   * In multi signal case this code is not used.
   * In single signal -> linear DID will always fit Dcm_CfgNetBufferSizeOptType, paged DIDs MUST not use this function
   * at all.
   */
  lSignalLength = (Dcm_CfgNetBufferSizeOptType)pDidInfoContext->DidLength;
#  endif
  return lSignalLength;
}
# endif

# if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidRangeGap()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidRangeGap(Dcm_OpStatusType            opStatus
                                                                      ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext)
{
  Std_ReturnType lStdResult = DCM_E_OK;

  /* #10 If the DID range supports gaps: */
  if(Dcm_DidMgrIsOpTypeSupported(pDidInfoContext->Descriptor.DidOpInfoPtr, DCM_DIDMGR_OPTYPE_RANGEISDIDAVAILABLE)) /* check for gaps */
  {
    Dcm_DidSupportedType isAvailable = DCM_DID_NOT_SUPPORTED;

    /* #20 Execute operation for evaluation gap match */
    Dcm_DidMgrGetOpClassInfo(pDidInfoContext, DCM_DIDMGR_OPTYPE_RANGEISDIDAVAILABLE);
    Dcm_DebugAssert((pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr->FuncClass == DCM_DIDMGR_OPCLS_ISDIDAVAILABLE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)

    lStdResult = ((Dcm_DidMgrOpFuncRangeIsAvailDidType)pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr->OpFunc)(pDidInfoContext->Did             /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                                                   ,opStatus
                                                                                                                   ,&isAvailable);
    /* #30 If operation needs more time (DCM_E_PENDING) or acknowledges that the DID is still valid: */
    if( ( (lStdResult == DCM_E_OK) && (isAvailable == DCM_DID_SUPPORTED) )
      ||(lStdResult == DCM_E_PENDING) )
    {
      /* #40 Return the current/final result: DCM_E_PENDING, DCM_E_OK */
    }
    else
    {
      /* #50 Otherwise: notify caller for range DID match but still DID invalid since in a gap */
      lStdResult = DCM_E_LOOKUP_MATCH_FOUND;
    }
  }
  /* #60 Otherwise: all DIDs within that range are valid: return DCM_E_OK */
  return lStdResult;
}
# endif

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDidRangeLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDidRangeLookUp(Dcm_OpStatusType            opStatus
                                                                    ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                    ,Dcm_DidMgrOpOptType             didOp)
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
  lStdReturn = DCM_E_OK;

  /* #10 On the very first call: */
  if(opStatus == DCM_INITIAL)
#  endif
  {
    sint16_least lResult;

    lStdReturn = DCM_E_NOT_OK;

    /* #20 Try finding a range that encloses this DID */
    lResult = Dcm_UtiLookUpRangeUint16(Dcm_CfgDidMgrDidRanges, pDidInfoContext->Did);
    /* #30 If a match found:  */
    if(lResult >= 0)
    {
      Dcm_DidMgrDidInfoPtrType lDidInfoPtr = &(Dcm_CfgDidMgrDidInfo[Dcm_CfgDidMgrRangeDidInfoRefs[lResult]]);

      /* #40 If the matched range supports the requested DID operation: */
      if(Dcm_DidMgrIsOpSupported(lDidInfoPtr, didOp))
      {
        /* #50 Prepare for positive final result; initialize DID context */
        pDidInfoContext->Descriptor.DidInfoPtr = lDidInfoPtr;
        /* Set DID length. Later the concrete length will be stored here. Take the maximum length! */
        pDidInfoContext->DidLength = pDidInfoContext->Descriptor.DidInfoPtr->Length;
        /* Store DID operation information */
        Dcm_DidMgrGetDidOpInfo(pDidInfoContext, didOp);

        lStdReturn = DCM_E_OK;
      }
      /* #60 Otherwise: Operation not supported -> DID not supported in context of the requested operation */
    }
  }
  /* #65 Otherwise: keep current result: DCM_E_OK */

#  if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
  /* #70 If DID match found: */
  if(lStdReturn == DCM_E_OK)
  {
    /* #80 Process potentially available DID range gaps, resp. re-call any pending operation */
    lStdReturn = Dcm_DidMgrFilterDidRangeGap(opStatus, pDidInfoContext);
  }
  /* #90 Otherwise: return final result: DCM_E_NOT_OK, DCM_E_PENDING */
#  endif

  return lStdReturn;
}
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfoSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfoSignal(Dcm_OpStatusType         opStatus
                                                                    ,Dcm_MsgContextPtrType              pMsgContext                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_DidMgrSignalOpClassInfoPtrType opFuncInfo
                                                                    ,Dcm_CfgNetBufferSizeMemType        sigScalingSize
                                                                    ,Dcm_NegativeResponseCodePtrType    errorCode)
{
  Std_ReturnType lStdResult;

  switch(opFuncInfo->FuncClass)
  {
#  if (DCM_DIDMGR_OPCLS_GETSCALINGINFO_SYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_GETSCALING_SYNC:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
    lStdResult = ((Dcm_DidMgrOpFuncGetScalingInfoSyncType)opFuncInfo->OpFunc)(Dcm_DiagGetResData(pMsgContext)                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */ /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                             ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_GETSCALINGINFO_ASYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_GETSCALING_ASYNC:
    lStdResult = ((Dcm_DidMgrOpFuncGetScalingInfoAsyncType)opFuncInfo->OpFunc)(opStatus                                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                              ,Dcm_DiagGetResData(pMsgContext)                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                              ,errorCode);
    break;
#  endif
  default:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(opFuncInfo);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */

    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  if(opStatus == DCM_CANCEL)
  {
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
#  endif

  if (lStdResult == DCM_E_OK)
  {
    Dcm_DiagProvideResData(pMsgContext, sigScalingSize);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  } /* Catch any RTE or unexpected specific errors */
  else if( (lStdResult != DCM_E_NOT_OK)
#  if (DCM_DIDMGR_ASYNC_SCALINGDID_SUPPORT_ENABLED == STD_ON)
         &&(lStdResult != DCM_E_PENDING)
#  endif
    )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
  {
    /* Do nothing */
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfo(Dcm_OpStatusType            opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_NegativeResponseCodePtrType   errorCode)
{
#  if (DCM_DIDMGR_MSIG_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrOpTypeHandlerInit(pDidInfoContext, pDidOpTypeContext);
    pDidOpTypeContext->OpType.ReadScaling.LayoutList = &Dcm_DidMgrGetSignalScalingSize(pDidInfoContext->Descriptor.DidInfoPtr);
  }

  DCM_UTI_LOOP_FOR_EVER
  {
    lStdResult = Dcm_DidMgrGetScalingInfoSignal(opStatus
                                               ,pMsgContext
                                               ,pDidOpTypeContext->Base.SignalOpList
                                               ,*(pDidOpTypeContext->OpType.ReadScaling.LayoutList)
                                               ,errorCode);
    if(lStdResult != DCM_E_OK)
    {
      /* on pending or not OK -> just leave */
      break;/* try later */
    }

    pDidOpTypeContext->Base.NumSignals--;
    if(pDidOpTypeContext->Base.NumSignals == 0u)
    {
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }

    /* next signal */
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->OpType.ReadScaling.LayoutList, 1u);
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalOpList, 1u);

    opStatus = DCM_INITIAL;/* reset op status */
  }

  return lStdResult;
#  else
  DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_DidMgrGetScalingInfoSignal(opStatus
                                       ,pMsgContext
                                       ,pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr
                                       ,Dcm_DidMgrGetSignalScalingSize(pDidInfoContext->Descriptor.DidInfoPtr)
                                       ,errorCode);

#  endif
}
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWriteSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWriteSignal(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Dcm_DidMgrSignalOpClassInfoPtrType   opFuncInfo;
  Std_ReturnType lStdResult;

#  if (DCM_DIDMGR_MSIG_OPTYPE_WRITE_ENABLED == STD_ON)
  opFuncInfo = pDidOpTypeContext->Base.SignalOpList;
#  else
  opFuncInfo = pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr;
#  endif

  switch(opFuncInfo->FuncClass)
  {
#  if (DCM_DIDMGR_OPCLS_WRITE_RANGE_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_WRITE_RANGE:
    lStdResult = ((Dcm_DidMgrOpFuncWriteDidRangeType)opFuncInfo->OpFunc)(pDidInfoContext->Did                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                        ,Dcm_DiagGetReqData(pMsgContext)
                                                                        ,opStatus
                                                                        ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                        ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_NRES_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_NRES_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncWriteLenSyncNResErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_WRITE_LEN_ASYNC_NRES_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_WRITE_LEN_ASYNC_NRES_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncWriteLenAsyncNResErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                 ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                 ,opStatus
                                                                                 ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncWriteNLenSyncNResErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                 ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_WRITE_NLEN_ASYNC_NRES_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_WRITE_NLEN_ASYNC_NRES_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncWriteNLenAsyncNResErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                   /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,opStatus
                                                                                  ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_RES_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_RES_ERROR:
    {
      Dcm_DidMgrDidLengthType lDataLength = (Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen;
      lStdResult = ((Dcm_DidMgrOpFuncWriteLenSyncResErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                 ,&lDataLength
                                                                                 ,Dcm_DiagGetResData(pMsgContext)                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                                 ,errorCode);
      if(lStdResult == DCM_E_OK)
      {
        Dcm_DiagProvideResData(pMsgContext, lDataLength);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_NERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_NERROR:
    lStdResult = ((Dcm_DidMgrOpFuncWriteNLenSyncNResNErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext));                                 /* PRQA S 0313 */ /* MD_Dcm_0313 */

    if(lStdResult != DCM_E_OK)
    {
      *errorCode = DCM_E_GENERALPROGRAMMINGFAILURE; /* set write operation failed */
      lStdResult = DCM_E_NOT_OK;
    }
    break;
#  endif
  default:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                       /* PRQA S 3112 */ /* MD_Dcm_3112 */

    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  if(opStatus == DCM_CANCEL)
  {
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
#  endif

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_PENDING)
#  endif
    &&(lStdResult != DCM_E_NOT_OK)
    )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWrite()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWrite(Dcm_OpStatusType opStatus
                                                               ,Dcm_MsgContextPtrType pMsgContext
                                                               ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                               ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                               ,Dcm_NegativeResponseCodePtrType errorCode)                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
#  if (DCM_DIDMGR_MSIG_OPTYPE_WRITE_ENABLED == STD_ON)
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrOpTypeHandlerInit(pDidInfoContext, pDidOpTypeContext);

    Dcm_DiagConsumeReqData(pMsgContext, pDidOpTypeContext->Base.SignalInfoList->Offset);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  DCM_UTI_LOOP_FOR_EVER
  {
    lStdResult = Dcm_DidMgrWriteSignal(opStatus
                                     ,pMsgContext
                                     ,pDidInfoContext
                                     ,pDidOpTypeContext
                                     ,errorCode);
    if(lStdResult != DCM_E_OK)
    {
      /* on pending or not OK -> just leave */
      break;/* try later */
    }

    pDidOpTypeContext->Base.NumSignals--;
    if(pDidOpTypeContext->Base.NumSignals == 0u)
    {
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }
    /* next signal */
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalOpList, 1u);
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalInfoList,1u);
    Dcm_DiagConsumeReqData(pMsgContext, pDidOpTypeContext->Base.SignalInfoList->Offset);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
    opStatus = DCM_INITIAL;/* reset op status */
  }

  return lStdResult;
#  else
  return Dcm_DidMgrWriteSignal(opStatus
                              ,pMsgContext
                              ,pDidInfoContext
                              ,pDidOpTypeContext
                              ,errorCode);
#  endif
}
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2Ecu()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2EcuSignal(
                                                                        Dcm_CfgDidMgrSignalOpClassRefOptType opInfoRef)
{
  Std_ReturnType                     lStdResult;
  Dcm_NegativeResponseCodeType       lNrc;
  Dcm_DidMgrSignalOpClassInfoPtrType opFuncInfo;

  Dcm_DebugAssert((Dcm_UtiGetNumElementsOfTable(Dcm_CfgDidMgrSignalOpClassInfo, Dcm_CfgDidMgrSignalOpClassInfoType) > opInfoRef), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE) /* COV_DCM_RTM_DEV_DEBUG XF */

  opFuncInfo = &Dcm_CfgDidMgrSignalOpClassInfo[opInfoRef];

  switch(opFuncInfo->FuncClass)
  {
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR  :
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncNCemrErrorType)opFuncInfo->OpFunc)(                                                                 /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    &lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr8ErrorType)opFuncInfo->OpFunc)(0xFFu                                                            /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr16ErrorType)opFuncInfo->OpFunc)(0xFFFFu                                                         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr32ErrorType)opFuncInfo->OpFunc)(0xFFFFFFFFUL                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemrNErrorType)opFuncInfo->OpFunc)(Dcm_InstanceContext.DidMgr.IoControlCemrSessionMask              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncNCemrErrorType)opFuncInfo->OpFunc)(DCM_INITIAL                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr8ErrorType)opFuncInfo->OpFunc)(DCM_INITIAL                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,0xFFu
                                                                                    ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr16ErrorType)opFuncInfo->OpFunc)(DCM_INITIAL                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                     ,0xFFFFu
                                                                                     ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr32ErrorType)opFuncInfo->OpFunc)(DCM_INITIAL                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                     ,0xFFFFFFFFUL
                                                                                     ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemrNErrorType)opFuncInfo->OpFunc)(DCM_INITIAL                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,Dcm_InstanceContext.DidMgr.IoControlCemrSessionMask
                                                                                    ,&lNrc);
    break;
#  endif
  default:
    DCM_IGNORE_UNREF_PARAM(opInfoRef);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }
  DCM_IGNORE_UNREF_PARAM(lStdResult);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
  Dcm_DebugApiCheckRte(lStdResult != DCM_E_PENDING, DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

  /*
  No need to handle application NRC since not used!
  Dcm_DiagHandleApplNrc(lStdResult, &lNrc, DCM_E_CONDITIONSNOTCORRECT);
  */
}                                                                                                                                                    /* PRQA S 6030 */ /* MD_MSR_STCYC */
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2Ecu()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef)
{
#  if (DCM_DIDMGR_MSIG_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  Dcm_DebugAssert((Dcm_UtiGetNumElementsOfTable(Dcm_CfgDidMgrDidOpClassInfo, Dcm_CfgDidMgrDidOpClassInfoType) > (opInfoRef + 1)), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE) /* COV_DCM_RTM_DEV_DEBUG XF */
  {
    Dcm_CfgDidMgrSignalOpClassRefOptType lSignalIter;

    for(lSignalIter = Dcm_CfgDidMgrDidOpClassInfo[opInfoRef+ 0].OpClassRef; lSignalIter < Dcm_CfgDidMgrDidOpClassInfo[opInfoRef+ 1].OpClassRef; ++lSignalIter)
    {
      Dcm_DidMgrIoControlRtrnCtrl2EcuSignal(lSignalIter);
    }
  }
#  else
  Dcm_DidMgrIoControlRtrnCtrl2EcuSignal(Dcm_DidMgrGetOpClassRef(opInfoRef));
#  endif
}
# endif

# if (DCM_DIDMGR_OPTYPE_IO_ANY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlSignal(Dcm_OpStatusType           opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_NegativeResponseCodePtrType   errorCode)
{
  Std_ReturnType lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType  opFuncInfo;

#  if (DCM_DIDMGR_MSIG_OPTYPE_IO_ANY_ENABLED == STD_ON)
  opFuncInfo = pDidOpTypeContext->Base.SignalOpList;
#  else
  opFuncInfo = pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr;
#  endif

  switch(opFuncInfo->FuncClass)
  {
/* No CEMR */
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR  :

    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncNCemrErrorType)opFuncInfo->OpFunc)(                                                                 /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncNCemrErrorType)opFuncInfo->OpFunc)(opStatus                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_NCEMR_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncNCemrErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                   /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_NCEMR_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncNCemrErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                 ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                 ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_NCEMR_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncNCemrErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,opStatus
                                                                                   ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_NCEMR_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncNCemrErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                   /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                  ,opStatus
                                                                                  ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR:
    {
      Dcm_DidMgrDidLengthType lDataLength = (Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen;
      lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncResNCemrErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                      ,&lDataLength
                                                                                      ,Dcm_DiagGetResData(pMsgContext)                               /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                                      ,errorCode);
      if (lStdResult == DCM_E_OK)
      {
        Dcm_DiagProvideResData(pMsgContext, lDataLength);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }
    break;
#  endif
/* CEMR 8Bit */
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr8ErrorType)opFuncInfo->OpFunc)((uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr8ErrorType)opFuncInfo->OpFunc)(opStatus                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                    ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemr8ErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                   /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                  ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemr8ErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                 ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                 ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                 ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemr8ErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,opStatus
                                                                                   ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                   ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemr8ErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                   /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                  ,opStatus
                                                                                  ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                  ,errorCode);
    break;
#  endif

/* CEMR 16Bit */
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr16ErrorType)opFuncInfo->OpFunc)((uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr16ErrorType)opFuncInfo->OpFunc)(opStatus                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                     ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                     ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemr16ErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                   ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemr16ErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                   /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                  ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                  ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemr16ErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                 /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,opStatus
                                                                                    ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                    ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemr16ErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                   ,opStatus
                                                                                   ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                   ,errorCode);
    break;
#  endif

/* CEMR 32Bit */
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr32ErrorType)opFuncInfo->OpFunc)(pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord            /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr32ErrorType)opFuncInfo->OpFunc)(opStatus                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                     ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                     ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemr32ErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                   ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemr32ErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                   /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                  ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                  ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemr32ErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                 /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,opStatus
                                                                                    ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                    ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemr32ErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                   ,opStatus
                                                                                   ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                   ,errorCode);
    break;
#  endif
/* CEMR NBit */
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemrNErrorType)opFuncInfo->OpFunc)(pDidOpTypeContext->OpType.Io.EnableMaskPtr                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemrNErrorType)opFuncInfo->OpFunc)(opStatus                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                                    ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMRN_ERROR:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemrNErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                   /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                                  ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMRN_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemrNErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                 ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                 ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                                 ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMRN_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemrNErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,opStatus
                                                                                   ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                                   ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMRN_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemrNErrorType)opFuncInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                   /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                  ,opStatus
                                                                                  ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                                  ,errorCode);
    break;
#  endif

  default:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                       /* PRQA S 3112 */ /* MD_Dcm_3112 */

    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  if(opStatus == DCM_CANCEL)
  {
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
#  endif

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
#  if (DCM_DIDMGR_ASYNC_IODID_SUPPORT_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_PENDING)
#  endif
    &&(lStdResult != DCM_E_NOT_OK)
    )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  Dcm_DiagHandleApplNrc(lStdResult, errorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
# endif

# if (DCM_DIDMGR_OPTYPE_IO_ANY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControl(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_NegativeResponseCodePtrType errorCode)
{
#  if (DCM_DIDMGR_MSIG_OPTYPE_IO_ANY_ENABLED == STD_ON)
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrOpTypeHandlerInit(pDidInfoContext, pDidOpTypeContext);

    Dcm_DiagConsumeReqData(pMsgContext, pDidOpTypeContext->Base.SignalInfoList->Offset);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  DCM_UTI_LOOP_FOR_EVER
  {
    lStdResult = Dcm_DidMgrIoControlSignal(opStatus
                                         ,pMsgContext
                                         ,pDidInfoContext
                                         ,pDidOpTypeContext
                                         ,errorCode);
    if(lStdResult != DCM_E_OK)
    {
      /* on pending or not OK -> just leave */
      break;
    }

    pDidOpTypeContext->Base.NumSignals--;
    if(pDidOpTypeContext->Base.NumSignals == 0u)
    {
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }
    /* next signal */
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalOpList, 1u);
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalInfoList,1u);
    Dcm_DiagConsumeReqData(pMsgContext, pDidOpTypeContext->Base.SignalInfoList->Offset);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

    opStatus = DCM_INITIAL;/* reset op status */
  }

  return lStdResult;
#  else
  DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_DidMgrIoControlSignal(opStatus
                                  ,pMsgContext
                                  ,pDidInfoContext
                                  ,pDidOpTypeContext
                                  ,errorCode);
#  endif
}
# endif

# if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_INT_CEMR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlWithMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlWithMask(Dcm_OpStatusType         opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   errorCode)

{
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrOpTypeHandlerInit(pDidInfoContext, pDidOpTypeContext);

    pDidOpTypeContext->OpType.Io.OperExecuted= FALSE;
    pDidOpTypeContext->OpType.Io.SignalIter  = 0u;
    pDidOpTypeContext->OpType.Io.BitScanner  = 0x80u;

    Dcm_DiagConsumeReqData(pMsgContext, pDidOpTypeContext->Base.SignalInfoList->Offset);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  DCM_UTI_LOOP_FOR_EVER
  {
    if((pDidOpTypeContext->OpType.Io.EnableMaskPtr[0] & pDidOpTypeContext->OpType.Io.BitScanner) != 0)
    {
      pDidOpTypeContext->OpType.Io.OperExecuted = TRUE;

      lStdResult = Dcm_DidMgrIoControlSignal(opStatus
                                            ,pMsgContext
                                            ,pDidInfoContext
                                            ,pDidOpTypeContext
                                            ,errorCode);
    }
    else
    {
      /* else - signal not allowed -> skip with ok */
      lStdResult = DCM_E_OK;
    }

    if(lStdResult != DCM_E_OK)
    {
      break;
    }

    pDidOpTypeContext->OpType.Io.SignalIter++;
    if(pDidOpTypeContext->OpType.Io.SignalIter >= pDidOpTypeContext->Base.NumSignals)
    {
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }

    /* next signal */
    pDidOpTypeContext->OpType.Io.BitScanner >>= 1;
    if(pDidOpTypeContext->OpType.Io.BitScanner == 0)
    {
      pDidOpTypeContext->OpType.Io.BitScanner = 0x80u;
      Dcm_UtiNextItemByPtr(pDidOpTypeContext->OpType.Io.EnableMaskPtr,1);
    }
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalOpList, 1u);
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalInfoList,1u);
    Dcm_DiagConsumeReqData(pMsgContext, pDidOpTypeContext->Base.SignalInfoList->Offset);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
    opStatus = DCM_INITIAL;/* reset op status */
  }

  if(pDidOpTypeContext->OpType.Io.OperExecuted == FALSE)
  {
    /* the enable mask record did not enable any signal */
    *errorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetOpFuncInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrSignalOpClassInfoPtrType, DCM_CODE) Dcm_DidMgrGetOpFuncInfo(
                                                                    Dcm_DidMgrDidInfoContextPtrType pDidInfoContext                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext)                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_DidMgrSignalOpClassInfoPtrType lOpFuncInfo;

  DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                           /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_ENABLED == STD_ON)
  lOpFuncInfo = pDidOpTypeContext->Base.SignalOpList;
#  else
  lOpFuncInfo = pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr;
#  endif

  return lOpFuncInfo;
}
# endif

# if (DCM_DIDMGR_OPCLS_READ_RANGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalRange()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalRange(Dcm_OpStatusType opStatus
                                                                   ,Dcm_DiagDataContextPtrType pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType lOpFuncInfo;
  Dcm_DidMgrDidLengthType            lResLength = 0u; /* Set just in case not set by application */

  lOpFuncInfo = Dcm_DidMgrGetOpFuncInfo(pDidInfoContext, pDidOpTypeContext);

  /* Call the appropriate application callback for that DID range signal */
  lStdResult = ((Dcm_DidMgrOpFuncReadDidRangeType)lOpFuncInfo->OpFunc)(pDidInfoContext->Did                                                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                      ,Dcm_DiagGetDataContextBuffer(pDataContext)
                                                                      ,opStatus
                                                                      ,&lResLength
                                                                      ,errorCode);

  if(lStdResult == DCM_E_OK)
  {
    /* Update final response length only in positive/final case */
#  if(DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    if(lResLength > pDidInfoContext->DidLength)
    {
      lStdResult = DCM_E_NOT_OK;
      *errorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_DebugReportError(DCM_SID_SVCPORT_DATASVCS_OP_READDIDRANGE, DCM_E_INTERFACE_BUFFER_OVERFLOW);
    }
    else
#  endif
    {
      pDidInfoContext->DidLength = lResLength;/* update current DID length */

      Dcm_DiagCommitData(pDataContext, lResLength);
    }
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPCLS_READ_ASYNC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalAsync()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalAsync(Dcm_OpStatusType opStatus
                                                                   ,Dcm_DiagDataContextPtrType pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType lOpFuncInfo;

  lOpFuncInfo = Dcm_DidMgrGetOpFuncInfo(pDidInfoContext, pDidOpTypeContext);

  /* Call the appropriate application callback for that asynchronous signal */
  lStdResult = ((Dcm_DidMgrOpFuncReadAsyncType)lOpFuncInfo->OpFunc)(opStatus                                                                         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                   ,Dcm_DiagGetDataContextBuffer(pDataContext));                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */

  if(lStdResult == DCM_E_OK)
  {
    Dcm_CfgNetBufferSizeOptType lSignalLen;

    /* Update the remaining available length */
    lSignalLen = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);
    Dcm_DiagCommitData(pDataContext, lSignalLen);
  }
  else if(lStdResult == DCM_E_NOT_OK)
  {
    /* Handle NRC here since no NRC can be passed by the application on this interface */
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* Nothing to do */
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPCLS_READ_SYNC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalSync()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalSync(Dcm_DiagDataContextPtrType pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType lOpFuncInfo;

  lOpFuncInfo = Dcm_DidMgrGetOpFuncInfo(pDidInfoContext, pDidOpTypeContext);

  /* Call the appropriate application callback for that synchronous signal */
  lStdResult = ((Dcm_DidMgrOpFuncReadSyncType)lOpFuncInfo->OpFunc)(Dcm_DiagGetDataContextBuffer(pDataContext));                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */

  if(lStdResult == DCM_E_OK)
  {
    Dcm_CfgNetBufferSizeOptType lSignalLen;

    /* Update the remaining available length */
    lSignalLen = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);
    Dcm_DiagCommitData(pDataContext, lSignalLen);
  }
  else if(lStdResult == DCM_E_NOT_OK)
  {
    /* Handle NRC here since no NRC can be passed by the application on this interface */
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* Nothing to do */
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalPaged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalPaged(Dcm_OpStatusType opStatus
                                                                   ,Dcm_DiagDataContextPtrType pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrDidLengthType            lTmpAvailLen;
  Dcm_DidMgrSignalOpClassInfoPtrType lOpFuncInfo;

  lTmpAvailLen = (Dcm_DidMgrDidLengthType)pDataContext->AvailLen; /* Needed in case pAvailLen is not derived from U16 type */
  lOpFuncInfo = Dcm_DidMgrGetOpFuncInfo(pDidInfoContext, pDidOpTypeContext);

  /* Call the appropriate application callback for that paged signal */
  lStdResult = ((Dcm_DidMgrOpFuncReadPagedDidType)lOpFuncInfo->OpFunc)(opStatus                                                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                      ,Dcm_DiagGetDataContextBuffer(pDataContext)
                                                                      ,&lTmpAvailLen);

  if( (lStdResult == DCM_E_OK)
    ||(lStdResult == DCM_E_BUFFERTOOLOW) )
  {
    Dcm_DiagCommitData(pDataContext, lTmpAvailLen);
  }
  else if(lStdResult == DCM_E_NOT_OK)
  {
    /* Handle NRC here since no NRC can be passed by the application on this interface */
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* Nothing to do */
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPCLS_READ_VID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalVid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalVid(Dcm_OpStatusType opStatus
                                                                   ,Dcm_DiagDataContextPtrType pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType lOpFuncInfo;
  uint8                              lResLength;
  Dcm_ConstMsgType                   pResData = Dcm_DiagGetDataContextBuffer(pDataContext);

  lResLength = (uint8)pDidInfoContext->DidLength;
#  if (DCM_DIDMGR_REPORT_NODIBYTE_ENABLED == STD_OFF)
  /* Did length does not contain NODI byte; application will provide NODI byte always so length must be incremented */
  lResLength++;
#  endif

  lOpFuncInfo = Dcm_DidMgrGetOpFuncInfo(pDidInfoContext, pDidOpTypeContext);

  /* #120 Call the appropriate application callback for that VID signal */
  lStdResult = ((Dcm_DidMgrOpFuncReadVidType)lOpFuncInfo->OpFunc)(opStatus                                                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                 ,pResData
#  if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
                                                                 ,&lResLength
#  endif
                                                                 );
  /* #125 Handle NRC here since no NRC can be passed by the application on this interface */
  if(lStdResult == DCM_E_OK)
  {
    /* #121 Decrement length of signal if NODI byte reporting disabled */
#  if (DCM_DIDMGR_REPORT_NODIBYTE_ENABLED == STD_OFF)
    /*  in case lResLength is 0, length will be decremented to 255 -> this will invoke a DET */
    lResLength--;
#  endif
    /* #130 If VID signal with dynamic length supported (Autosar Version >= 4.2.2) */
#  if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
    /* Update final response length only in positive/final case */
#   if(DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    if(lResLength > pDidInfoContext->DidLength)
    {
      lStdResult = DCM_E_NOT_OK;
      *errorCode = DCM_E_PANIC_NRC;
      Dcm_DebugReportError(DCM_SID_SVCPORT_DATASVCS_OP_READVID, DCM_E_INTERFACE_BUFFER_OVERFLOW);
    }
    else
#   endif
#  endif
    {
#  if (DCM_DIDMGR_REPORT_NODIBYTE_ENABLED == STD_OFF)
      uint16_least lIter;

      /* #140 Remove NODI byte from VID signal if NODI byte reporting disabled */
      for(lIter = 0; lIter < lResLength; ++lIter)
      {
        pResData[lIter] = pResData[lIter+1];
      }
#  endif
      pDidInfoContext->DidLength = lResLength;/* update current DID length */
      Dcm_DiagCommitData(pDataContext, lResLength);
    }
  }
  else if (lStdResult == DCM_E_NOT_OK)
  {
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;
  }
  else
  {
    /* delegate */
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPCLS_READ_SR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignalSR()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignalSR(Dcm_DiagDataContextPtrType pDataContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType lOpFuncInfo;

  lOpFuncInfo = Dcm_DidMgrGetOpFuncInfo(pDidInfoContext, pDidOpTypeContext);

  /* #100 Call the appropriate application callback for that SR signal */
  lStdResult = ((Dcm_DidMgrOpFuncReadSRType)lOpFuncInfo->OpFunc)(Dcm_DiagGetDataContextBuffer(pDataContext));                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */

  /* #120 If the return value of the callback indicates successful operation: */
  if(lStdResult == DCM_E_OK)
  {
    Dcm_CfgNetBufferSizeOptType lSignalLen;

    /* Update the remaining available length */
    lSignalLen = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);
    Dcm_DiagCommitData(pDataContext, lSignalLen);
  }
  /* #140 Otherwise: */
  else
  {
    /* Handle NRC here since no NRC can be passed by the application through this interface */
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignal(Dcm_OpStatusType                  opStatus
                                                                    ,Dcm_DiagDataContextPtrType        pDataContext
                                                                    ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType   errorCode)
{
  Std_ReturnType                     lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType lOpFuncInfo;

  lOpFuncInfo = Dcm_DidMgrGetOpFuncInfo(pDidInfoContext, pDidOpTypeContext);

  switch(lOpFuncInfo->FuncClass)
  {
#  if (DCM_DIDMGR_OPCLS_READ_RANGE_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READ_RANGE:
    lStdResult = Dcm_DidMgrReadSignalRange(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, errorCode);
    break;
#  endif

#  if (DCM_DIDMGR_OPCLS_READ_ASYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READ_ASYNC:
    lStdResult = Dcm_DidMgrReadSignalAsync(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, errorCode);
    break;
#  endif

#  if (DCM_DIDMGR_OPCLS_READ_SYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READ_SYNC:
    lStdResult = Dcm_DidMgrReadSignalSync(pDataContext, pDidInfoContext, pDidOpTypeContext, errorCode);
    break;
#  endif

#  if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READ_PAGED:
    lStdResult = Dcm_DidMgrReadSignalPaged(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_VID_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READ_VID:
    lStdResult = Dcm_DidMgrReadSignalVid(opStatus, pDataContext, pDidInfoContext, pDidOpTypeContext, errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_SR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READ_SR:
    lStdResult = Dcm_DidMgrReadSignalSR(pDataContext, pDidInfoContext, pDidOpTypeContext, errorCode);
    break;
#  endif
  default:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

#  if (DCM_DIDMGR_CANCEL_OP_READ_ENABLED == STD_ON)
  if(opStatus == DCM_CANCEL)
  {
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
#  endif

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
    &&(lStdResult != DCM_E_NOT_OK)
#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_PENDING)
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_BUFFERTOOLOW)
#  endif
#  if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_FORCE_RCRRP)
#  endif
    )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  Dcm_DiagHandleApplNrc(lStdResult, errorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6060 */ /* MD_MSR_STPTH,  MD_MSR_STCYC,  MD_Dcm_Design_6060 */
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) && \
     (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadGap()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadGap(Dcm_DiagDataContextPtrType pDataContext
                                                                 ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                 ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext)
{
  Std_ReturnType lStdResult;
  Dcm_CfgNetBufferSizeOptType lGapLength;

  lGapLength = Dcm_DidMgrGetGapRemainingLen(pDidInfoContext, pDidOpTypeContext);

  /* #10 If the gap doesn't fit into the available buffer space: */
  if(pDataContext->AvailLen < lGapLength)
  {
    /* #20 Use the full available length for writing the gap */
    Dcm_DiagCommitData(pDataContext, pDataContext->AvailLen);
    lStdResult = DCM_E_BUFFERTOOLOW;
  }
  else
  {
    /* #30 Otherwise commit the whole gap */
    Dcm_DiagCommitData(pDataContext, lGapLength);
    lStdResult = DCM_E_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadLengthSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLengthSignal(Dcm_OpStatusType                opStatus
                                                                       ,Dcm_DidMgrDidInfoContextPtrType    pDidInfoContext                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                       ,Dcm_DidMgrDidLengthPtrType         pResLength
                                                                       ,Dcm_NegativeResponseCodePtrType    errorCode)
{
  Std_ReturnType lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType lOpFuncInfo;

  /* Only one signal may have dynamic length - the last DID signal */
  lOpFuncInfo = pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr;

  switch(lOpFuncInfo->FuncClass)
  {
#  if (DCM_DIDMGR_OPCLS_READ_LENGTH_SYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READLENGTH_SYNC:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

    lStdResult = ((Dcm_DidMgrOpFuncReadLengthSyncType)lOpFuncInfo->OpFunc)(pResLength);                                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_LENGTH_ASYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READLENGTH_ASYNC:
    lStdResult = ((Dcm_DidMgrOpFuncReadLengthAsyncType)lOpFuncInfo->OpFunc)(opStatus                                                                 /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                           ,pResLength);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_LENGTH_RANGE_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READLENGTH_RANGE:
    lStdResult = ((Dcm_DidMgrOpFuncReadDidRangeLengthType)lOpFuncInfo->OpFunc)(pDidInfoContext->Did                                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                              ,opStatus
                                                                              ,pResLength);
    break;
#  endif
  default:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pResLength);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(lOpFuncInfo);                                                                                                             /* PRQA S 3112 */ /* MD_Dcm_3112 */

    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  if(opStatus == DCM_CANCEL)
  {
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
#  endif

  if(lStdResult == DCM_E_NOT_OK)
  {
    *errorCode = DCM_E_CONDITIONSNOTCORRECT; /* return NRC CNC since no error code supported by the application API */                               /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_PENDING)
#  endif
    &&(lStdResult != DCM_E_NOT_OK)
    )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  /* No need of handling E_NOT_OK since the only setter is the DCM itself (no appl NRC).
  Dcm_DiagHandleApplNrc(lStdResult, errorCode, DCM_E_CONDITIONSNOTCORRECT);
  */
  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadCheckCondSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadCheckCondSignal(Dcm_OpStatusType              opStatus
                                                                        ,Dcm_DidMgrSignalOpClassInfoPtrType opFuncInfo                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                        ,Dcm_NegativeResponseCodePtrType    errorCode)
{
  Std_ReturnType lStdResult;

  switch(opFuncInfo->FuncClass)
  {
#  if (DCM_DIDMGR_OPCLS_READ_CHECKCOND_SYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READCHK_COND_SYNC:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

    lStdResult = ((Dcm_DidMgrOpFuncReadCheckCondSyncType)opFuncInfo->OpFunc)(                                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                             errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_CHECKCOND_ASYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READCHK_COND_ASYNC:
    lStdResult = ((Dcm_DidMgrOpFuncReadCheckCondAsyncType)opFuncInfo->OpFunc)(opStatus                                                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                             ,errorCode);
    break;
#  endif
  default:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(opFuncInfo);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */

    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  if(opStatus == DCM_CANCEL)
  {
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
#  endif

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_PENDING)
#  endif
    &&(lStdResult != DCM_E_NOT_OK)
    )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *errorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  Dcm_DiagHandleApplNrc(lStdResult, errorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidLookUp(
                                                                       Dcm_DidMgrDidInfoContextPtrType pDidInfoContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                      ,Dcm_DidMgrOpOptType             didOp)
{
  Std_ReturnType lStdReturn = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                           /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(didOp);                                                                                                                     /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
  if(Dcm_VarMgrIsEnabledInActiveVariants(pDidInfoContext->Descriptor.DidOpInfoPtr->ExecCondRef) == FALSE)
  {
    /* Not supported in current variant */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  /* check session state */
  if(!Dcm_StateIsSupportedInSession(Dcm_StateGetPreconditionStates(pDidInfoContext->Descriptor.DidOpInfoPtr->ExecCondRef)))
  {
    /* Not supported in current session */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  {
# if (DCM_SVC_22_OBD_CALIBRATION_ENABLED == STD_ON) && (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
    /* perform this check only on supported DIDs ! */
    if( (pDidInfoContext->Did >= (uint16)0xF400u)
      &&(pDidInfoContext->Did <= (uint16)0xF8FFu)
#  if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
      /* Already filtered in the IsDidAvailable operation of the 0xF6xx DID range.
       * Note: Dcm_CfgSvc22SupportedIdMask does not contain any information for this DID range -> exclude from indexing.
       */
      && ((pDidInfoContext->Did & 0xF600u) != 0xF600u)
#  endif
      )
    {
      if(!Dcm_ObdIdMgrIsIdEnabled(Dcm_UtiGetLoByte(pDidInfoContext->Did), &Dcm_CfgSvc22SupportedIdMask[Dcm_CfgSvc22SupportedIdMaskOffset[Dcm_UtiGetHiByte(pDidInfoContext->Did)-(uint8)0xF4u]]))
      {
        /* OBD DID not enabled */
        lStdReturn = DCM_E_NOT_OK;
      }/* else - still enabled */
    }
    else/* not an (WWH-)OBD DID */
# endif
    {
# if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
      if(didOp != DCM_DIDMGR_OP_DEFINE) /* isolate SID 0x2C - Define or Clear on not defined DDDID is always allowed! */
      {
        if(!Dcm_Svc2CIsDidDefined(pDidInfoContext->Descriptor.DidInfoPtr))
        {
          /* not yet defined for other operations than DEFINE */
          lStdReturn = DCM_E_NOT_OK;
        }/* else - defined for other operations */
      }
# endif
    }
  }

  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_DidMgrConcreteDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrConcreteDidLookUp(
                                                                        Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                       ,Dcm_DidMgrOpOptType didOp)
{
  Std_ReturnType lStdReturn = DCM_E_NOT_OK;
  /* Search for the DID in the database */
  sint16_least  lResult = Dcm_UtiLookUpUint16(Dcm_CfgDidMgrDidLookUpTable, pDidInfoContext->Did);

  /* Check DID lookup result: */
  if(lResult >= 0)
  {
    /* If found, check if the DID supports the required operation: */
    if(Dcm_DidMgrIsOpSupported(&Dcm_CfgDidMgrDidInfo[lResult], didOp))
    {
      /* If operation supported, initialize DID information (set DID as supported) */
      pDidInfoContext->Descriptor.DidInfoPtr = &Dcm_CfgDidMgrDidInfo[lResult];
      /* Set DID length. Later the concrete length will be stored here. Take the maximum/concrete length! */
      pDidInfoContext->DidLength = pDidInfoContext->Descriptor.DidInfoPtr->Length;
      /* Initialize DID operation information  */
      Dcm_DidMgrGetDidOpInfo(pDidInfoContext, didOp);
      lStdReturn = DCM_E_OK;
    }/* else - not a supported DID in the operation context! */
  }/* else - not a supported DID at all! */

  return lStdReturn;
}

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) && \
     (DCM_DIDMGR_MSIG_OPTYPE_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadPagedMultiSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadPagedMultiSignal(Dcm_DiagDataContextPtrType pDataContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType               lResult;
  Dcm_CfgNetBufferSizeOptType  lAvailLen;
  Dcm_CfgNetBufferSizeOptType  lSignalLen;
  boolean                      lHasNext;
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
  boolean                      lIsGap;
#  endif

  lHasNext = TRUE;

  /* #10 For each signal of the DID: */
  do
  {
    /* #20 Calculate the remaining available length */
    lAvailLen = (Dcm_CfgNetBufferSizeOptType)(pDataContext->AvailLen);

#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
    lIsGap = (boolean)
              ( (pDidOpTypeContext->OpType.Read.Progress < pDidOpTypeContext->OpType.Read.Offset) /* A leading or intermediate gap? */
              ||(pDidOpTypeContext->Base.NumSignals == 0u) /* A trailing gap? */);

    /* #30 Calculate the length of the signal */
    if(lIsGap == TRUE)
    {
      lSignalLen = 1u; /* A gap signal is treated as a paged signal -> minimum one byte is required */
    }
    else
#  endif
    {
      lSignalLen = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);
    }

    /* #40 If there is not enough buffer space available for the signal: */
    if(pDataContext->AvailLen < lSignalLen)
    {
      /* #50 Try it the next task cycle */
      lResult = DCM_E_BUFFERTOOLOW;
      lHasNext = FALSE;
    }
    else
    {
      /* #60 Read the signal data considering gaps */
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
      if(lIsGap == TRUE)
      {
        lResult = Dcm_DidMgrReadGap(pDataContext, pDidInfoContext, pDidOpTypeContext);
      }
      else
#  endif
      {
        lResult = Dcm_DidMgrReadSignal(pDidOpTypeContext->OpType.Read.OpStatus
                                      ,pDataContext
                                      ,pDidInfoContext
                                      ,pDidOpTypeContext
                                      ,errorCode);
      }

      switch(lResult)
      {
      case DCM_E_OK:
        pDidOpTypeContext->OpType.Read.OpStatus = DCM_INITIAL;
        pDidOpTypeContext->OpType.Read.Progress += (Dcm_CfgDidMgrOptimizedDidLengthType)(lAvailLen - pDataContext->AvailLen);

        /* #80 If this was the last signal: */
        if(pDidOpTypeContext->OpType.Read.Progress == pDidInfoContext->DidLength)
        {
          /* #90 All signals read without any errors. Finalize reading */
          lHasNext = FALSE;
        }
        else
        {
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
          /* #100 Otherwise, if there is no gap till next signal: */
          if(lIsGap == FALSE)
#  endif
          {
            --pDidOpTypeContext->Base.NumSignals;

#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_OFF)
            /*
             * Each signal handler shall always return the correct number of bytes, configured/registered by ReadDataLength.
             * This includes also the paged signals that shall always return DCM_E_OK only once all signal data is copied.
             * If the DET check below detects an error, it could only be caused by any paged signal handler called
             * for this DID.
             */
            Dcm_DebugAssert((pDidOpTypeContext->Base.NumSignals > 0), DCM_SID_INTERNAL, DCM_E_PARAM)                                                 /* COV_DCM_RTM_DEV_DEBUG XF */
#  endif

            /* #110 Go on with next signal */
            Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalOpList,  1u);
            Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalInfoList, 1u);
            pDidOpTypeContext->OpType.Read.Offset += (Dcm_CfgDidMgrOptimizedDidLengthType)(pDidOpTypeContext->Base.SignalInfoList->Offset);
          }/* else - transmit gap */
        }
        break;
      case DCM_E_BUFFERTOOLOW:
        /* #120 If there is not enough buffer space available: */
        pDidOpTypeContext->OpType.Read.OpStatus = DCM_PENDING;
        pDidOpTypeContext->OpType.Read.Progress += (Dcm_CfgDidMgrOptimizedDidLengthType)(lAvailLen - pDataContext->AvailLen);
        lHasNext = FALSE;
        break;
      default: /* DCM_E_PENDING, DCM_E_NOT_OK */
        /* In case DCM_E_NOT_OK -> No further call shall be made */
        pDidOpTypeContext->OpType.Read.OpStatus = DCM_PENDING;
        lHasNext = FALSE;
        break;
      }
    }
  }
  while(lHasNext == TRUE);

  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Inlined function implementations (Level1)
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/**********************************************************************************************************************
 *  Dcm_DiagAcceptNewRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DiagAcceptNewRequest(Dcm_NetTransportObjectPtrType pTranspObj)                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  boolean lResult = TRUE;
  /* If SID in range: [0x40, 0x7F]U[0xC0, 0xFF] */
#if(DCM_DIAG_IGNORE_RESPONSE_SID_ENABLED == STD_ON)
  if((pTranspObj->RxData[0] & 0x40u) != 0)
  {
    lResult = FALSE;
  }
  else
#endif
  /* If valid functional "0x3E 0x80" */
  if( (pTranspObj->RxData[0] == 0x3Eu)
    &&(pTranspObj->RxData[1] == 0x80u)
    &&(pTranspObj->RxLength  == 2u)
    &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE) )
  {
    lResult = FALSE;
  }
  else
  {
    /* nothing to do */
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_DiagOnTxFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagOnTxFinished(Dcm_NetTransportObjectPtrType pTranspObj                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                          ,Dcm_NetTransmissionResultType txStatus)
{
  switch(pTranspObj->ResType)
  {
  case DCM_NET_TOBJ_RESTYPE_LINEAR:
  case DCM_NET_TOBJ_RESTYPE_PAGED:
    /* Do finalize main response */
    Dcm_DiagTxFinalization(pTranspObj, txStatus);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_NET_TOBJ_RESTYPE_RCRRP:
    Dcm_DiagRcrRpTxFinished(pTranspObj, txStatus);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
  case DCM_NET_TOBJ_RESTYPE_UNSOLICITED:
    Dcm_DiagOnFblResTxFinished(pTranspObj, txStatus);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    /* Unknown response type */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }
}
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2AOnStateChanged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2AOnStateChanged(void)
{
# if (DCM_DIDMGR_PERIODICDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    Dcm_NegativeResponseCodeType   lNrc;
    Dcm_Svc2ASchdItemHandleOptType schdIter;
    Std_ReturnType lStdReturn;

    for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
    {
      if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate < DCM_SVC2A_RATE_TYPE_STOPPED)/* is still an active entry? */
      {
        lStdReturn = Dcm_DidMgrDynDidStateCheck(&(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].DidContext), &lNrc);
        if (lStdReturn == DCM_E_NOT_OK)
        {
          Dcm_Svc2ASchdStopItemByHandle(schdIter);
        }
      }
    }
  }
# endif
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_STATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CStateCheckSrcItems()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CStateCheckSrcItems(
                                                                         Dcm_CfgDidMgrDynDidHandleOptType dynDidHandle
                                                                        ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  Dcm_CfgDidMgrDynDidSrcItemIdxOptType currItem;
  Dcm_CfgDidMgrDynDidSrcItemIdxOptType endItem;

  currItem = Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle);
  endItem = (Dcm_CfgDidMgrDynDidHandleOptType)(currItem + Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Count);

  Dcm_DebugAssert((currItem < endItem), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                       /* COV_DCM_RTM_DEV_DEBUG XF */

  do
  {
#  if (DCM_SVC_2C_HYBRID_MODE_ENABLED == STD_ON)
    if(Dcm_Svc2CIsDidSrcItem(currItem))
#  endif
    {
#  if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
      lStdResult = Dcm_StateCheck(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[currItem].DidDescriptor.DidContext.Descriptor.DidOpInfoPtr->ExecCondRef, DCM_DIAG_CHK_LVL_PARAMETER, ErrorCode);
#  endif
    }
#  if (DCM_SVC_2C_HYBRID_MODE_ENABLED == STD_ON)
    else
#  endif
    {
#  if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
      lStdResult = Dcm_MemMgrCheckMemBlock(&(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[currItem].MemDescriptor.MemBlock), DCM_MEMMGR_OP_READ, ErrorCode);
#  endif
    }
    ++currItem;
  }
  while((lStdResult == DCM_E_OK)&&(currItem < endItem));

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2COnStateChanged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2COnStateChanged(void)
{
# if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
  /* clear all DynDID definitions not supported any more */
  Dcm_NegativeResponseCodeType lNrc;
  Std_ReturnType lStdResult;
  Dcm_CfgDidMgrDynDidHandleOptType dynDidIter;

  for(dynDidIter = 0; dynDidIter < DCM_NUM_DYNDIDS; ++dynDidIter)
  {
    if(Dcm_Svc2CIsDynDidDefined(dynDidIter))
    {
      lStdResult = Dcm_StateCheck(Dcm_DidMgrGetDynDidReadExecPrecond(dynDidIter), DCM_DIAG_CHK_LVL_PARAMETER, &lNrc);
#  if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_STATE_ENABLED == STD_ON)
      if(lStdResult == DCM_E_OK)/* all DDDID conditions OK - check inside */
      {
        lStdResult = Dcm_Svc2CStateCheckSrcItems(dynDidIter, &lNrc);
      }
#  endif
      if(lStdResult == DCM_E_NOT_OK)/* any condition not fulfilled? */
      {
        Dcm_Svc2CDefMgrClear((Dcm_CfgDidMgrDynDidHandleMemType)dynDidIter);
      }
    }/* else - DDDID not defined yet */
  }
# endif
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2FHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Min Length already checked in DiagDispatcher and expected to be 3 !!! */
    Dcm_DiagConsumeReqDataAsU16(pMsgContext, &(pRepContext->DidInfoContext.Did));                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdResult = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pRepContext->DidInfoContext)
                                   ,&(pRepContext->DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_IO);

  if (lStdResult == DCM_E_OK)
  {
    uint8 lControlOp;
    Dcm_DiagConsumeReqDataAsU8(pMsgContext, &lControlOp);                                                                                            /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

    /* convert from UDS to internal operation representation */
    pRepContext->OpType = (Dcm_DidMgrOpMemType)((lControlOp < 4u) ? Dcm_Svc2FCtrlOp2DidOpTypeMap[lControlOp]/* use interpreted value */
                                                                              :0x00u); /* no supported operation */
    /* Check for supported sub-operation */
    if(Dcm_DidMgrIsOpTypeSupported(pRepContext->DidInfoContext.Descriptor.DidOpInfoPtr
                                  ,pRepContext->OpType) )
    {
      /* Commit response header */
      Dcm_DiagProvideResData(pMsgContext, 3);                                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */

      lStdResult = Dcm_Svc2FIoDidOperationProcessor(pMsgContext, ErrorCode, pRepContext);
    }
    else
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }
  else if(lStdResult == DCM_E_NOT_OK)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* DCM_E_PENDING -> try again */
  }

  /* Reaching this point means diagnostic error was found */
  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FOnStateChanged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FOnStateChanged(void)
{
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON) && \
     (DCM_DIDMGR_IODID_EXEC_PRECOND_LIMIT_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid == TRUE)
  {
    P2VAR(Dcm_UtiBitSetBaseType, AUTOMATIC, DCM_VAR_NOINIT) pActiveIoDids = Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids;
    Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRefPage = 0;
    Dcm_CfgDidMgrIoDidHandleOptType ioDidIter = Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS_CONST);

    Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid = FALSE; /* Assume all IODIDs will be deactivated */

    for(; (ioDidIter != 0u); --ioDidIter)
    {
      Dcm_UtiBitSetBaseType lActiveIoDids = *pActiveIoDids;
      Dcm_UtiBitSetBaseType lActiveIoDidScanner = 0x01u;
      Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef = opInfoRefPage;

      DCM_UTI_LOOP_BIT_SCAN(lActiveIoDids)
      {
        if((*pActiveIoDids & lActiveIoDidScanner) != 0)
        {
          Dcm_NegativeResponseCodeType lNrc;
          Std_ReturnType lStdReturn;

          lStdReturn = Dcm_DidMgrStaticDidStateCheck(Dcm_DidMgrGetCtrlOpExecCondRef(opInfoRef), &lNrc);
          if (lStdReturn == DCM_E_NOT_OK)
          {
            Dcm_UtiBitOpClr(Dcm_UtiBitSetBaseType, *pActiveIoDids, lActiveIoDidScanner);                                                             /* PRQA S 0290 */ /* MD_Dcm_BitNegation_0290 */
            Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_DidMgrGetCtrlOpInfoRef(opInfoRef));
          }
        }

        lActiveIoDidScanner<<=1;
        ++opInfoRef;
      }

      /* If still any IODID active in this row: */
      if(*pActiveIoDids != 0)
      {
        /* Update IODID activity statistics */
        Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid = TRUE;
      }

      Dcm_UtiNextItemByPtr(pActiveIoDids, 1u);
      opInfoRefPage += (Dcm_CfgDidMgrDidOpClassHandleOptType)Dcm_UtiGetNumBitsOfXintType(Dcm_UtiBitSetBaseType);/* next bunch of IoDids */
    }
  }
# endif
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Inlined function implementations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_MemMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_MemMgrInit(void)
{
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.MemMgr.LockedByClient = DCM_MEMMGR_ACCESS_NONE;
# endif
}

/**********************************************************************************************************************
 *  Dcm_MemMgrConvMemOpResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrConvMemOpResult(Dcm_MemMgrOpResultType memOpResult
                                                                         ,Dcm_OpStatusType opStatus
                                                                         ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                         ,Dcm_NegativeResponseCodeType DefaultNrc)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DIAG_CANCEL_OP_ENABLED     == STD_ON) && \
     (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  if (opStatus == DCM_CANCEL)
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
  }
  else
# endif
  {
    switch(memOpResult)
    {
    case DCM_MEMMGR_OP_RSLT_OK:
      lStdResult = DCM_E_OK;
      break;
    case DCM_MEMMGR_OP_RSLT_PENDING:
      lStdResult = DCM_E_PENDING;
      break;
    case DCM_MEMMGR_OP_RSLT_FORCE_RCRRP:
      lStdResult = DCM_E_FORCE_RCRRP;
      break;
    default: /* DCM_MEMMGR_OP_RSLT_FAILED */
      lStdResult = DCM_E_NOT_OK;
# if(DCM_DEV_ERROR_REPORT == STD_ON)
      if(memOpResult != DCM_MEMMGR_OP_RSLT_FAILED)
      {
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      }
# endif
# if (DCM_DCM_AR_VERSION < DCM_DCM_AR_VERSION_422)
      *ErrorCode = DefaultNrc; /* restore default NRC */
# endif
      break;
    }
  }

# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
  Dcm_DiagHandleApplNrc(lStdResult, ErrorCode, DefaultNrc);                                                                                          /* PRQA S 3109 */ /* MD_MSR_14.3 */
# endif

# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  if( (lStdResult != DCM_E_PENDING)
    &&(lStdResult != DCM_E_FORCE_RCRRP))
  {
    /* Release resource */
    Dcm_InstanceContext.MemMgr.LockedByClient = DCM_MEMMGR_ACCESS_NONE;
  }
# endif
  return lStdResult;
}
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId(uint8 ObdMID
                                                                                         ,Dcm_MsgType Data
                                                                                         ,Dcm_DidMgrDidLengthPtrType DataLength
                                                                                         ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  uint32 lObdMidAvailMask;

  /* #10 If request of MID value from Dem is successful */
  if (Dem_DcmGetAvailableOBDMIDs(ObdMID, &lObdMidAvailMask) == E_OK)
  {
    *DataLength = 4u;

    /* #20 Copy MID and MID value to data buffer */
    lStdResult = Dcm_ObdIdMgrReadSupportedId(lObdMidAvailMask, Data);
  }
  else
  {
    /* #30 Otherwise return negative response */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_DataId()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_DataId(uint8 ObdMID
                                                                                    ,Dcm_MsgType Data
                                                                                    ,Dcm_DidMgrDidLengthPtrType DataLength
                                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8 lNumOfTIDs;

  /* #10 Request number of TIDs for DID from Dem */
  if (Dem_DcmGetNumTIDsOfOBDMID(ObdMID, &lNumOfTIDs) == E_OK)
  {
    /* #20 If request is successful */
    uint8 lTidIter;
    uint16 lTestValue;
    uint16 lTestValuMin;
    uint16 lTestValueMax;

    *DataLength = lNumOfTIDs * 8;

    /* #30 Request Test Result of each TID from Dem */
    for (lTidIter = 0; lTidIter < lNumOfTIDs; lTidIter++)
    {
      if (Dem_DcmGetDTRData(ObdMID, lTidIter, &Data[0], &Data[1], &lTestValue, &lTestValuMin, &lTestValueMax) == E_OK)
      {
        /* #40 If request is successful for a TID */
        /* #50 Copy response data to data buffer */

        Data[2] = Dcm_UtiGetHiByte(lTestValue);
        Data[3] = Dcm_UtiGetLoByte(lTestValue);

        Data[4] = Dcm_UtiGetHiByte(lTestValuMin);
        Data[5] = Dcm_UtiGetLoByte(lTestValuMin);

        Data[6] = Dcm_UtiGetHiByte(lTestValueMax);
        Data[7] = Dcm_UtiGetLoByte(lTestValueMax);

        /* next block */
        Data = &Data[8];
      }
      else
      {
        /* #60 Otherwise return negative response */
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
        lStdResult = DCM_E_NOT_OK;
        break;
      }
    }
  }
  else
  {
    /* #70 Otherwise return negative response */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
# if (DCM_UTI_NVM_READ_ENABLED  == STD_ON) || \
     (DCM_UTI_NVM_WRITE_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_UtiNvMGetErrorStatus()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiArEnvNvMGetErrorStatus(uint16 blockId
                                                         ,P2VAR(NvM_RequestResultType, AUTOMATIC, AUTOMATIC) nvmStatus)
{
  NvM_GetErrorStatus(blockId, nvmStatus);
  return E_OK;
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
/**********************************************************************************************************************
 *  Dcm_NetIsRxPduIdValid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsRxPduIdValid(PduIdType rxPduId)
{
  boolean lResult = TRUE;

  if( (rxPduId >= Dcm_PbCfgNetNumRxPduIds)
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
    ||(Dcm_NetGetConnIdOfRxPduId(rxPduId) >= Dcm_PbCfgNetNumConnections)
# endif
    )
  {
    lResult = FALSE;
  }

  return lResult;
}
#endif

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
/**********************************************************************************************************************
 *  Dcm_NetIsTxPduIdValid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsTxPduIdValid(PduIdType txPduId)
{
  boolean lResult = TRUE;

  if( (txPduId >= Dcm_PbCfgNetNumTxPduIds)
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
    ||(Dcm_NetGetConnIdOfTxPduId(txPduId) >= Dcm_PbCfgNetNumConnections)
# endif
    )
  {
    lResult = FALSE;
  }

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetGetComMContext()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetComMContextPtrType, DCM_CODE) Dcm_NetGetComMContext(Dcm_CfgNetNetIdRefOptType index)
{
  Dcm_NetComMContextPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= Dcm_PbCfgNetNumComMChannels)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETGETCOMMCONTEXT);
    lResult = &Dcm_PbRamNetComMContext[0];
  }
  else
#endif
  {
    lResult = &Dcm_PbRamNetComMContext[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetGetBufferContext()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetBufferContextPtrType, DCM_CODE) Dcm_NetGetBufferContext(Dcm_CfgNetBufferRefOptType index)
{
  Dcm_NetBufferContextPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= Dcm_PbCfgNetNumBuffers)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETGETBUFFERCONTEXT);
    lResult = &Dcm_PbRamNetBufferContext[0];
  }
  else
#endif
  {
    lResult = &Dcm_PbRamNetBufferContext[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetGetTransportObject()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetGetTransportObject(
                                                                                    Dcm_CfgNetTObjHandleOptType index)
{
  Dcm_NetTransportObjectPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= Dcm_PbCfgNetNumTransportObjects)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETGETTRANSPORTOBJECT);
    lResult = &Dcm_PbRamNetTransportObject[0];
  }
  else
#endif
  {
    lResult = &Dcm_PbRamNetTransportObject[index];
  }

  return lResult;
}

#if (DCM_NET_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetSetComControlChannelState()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetSetComControlChannelState(uint8_least index
                                                                      ,Dcm_CommunicationModeType value)
{
# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= Dcm_PbCfgNetNumAllComMChannels)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETSETCOMCONTROLCHANNELSTATE);
  }
  else
# endif
  {
    Dcm_PbRamNetComCtrlChannels[index] = value;                                                                                                      /* SBSW_DCM_POINTER_WRITE_COMCONTROLCHANNEL */
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetPutToConn2TObjMap()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPutToConn2TObjMap(Dcm_NetConnRefOptType index
                                                              ,Dcm_CfgNetTObjHandleMemType value)
{
#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= Dcm_PbCfgNetNumConnections)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETPUTTOCONN2TOBJMAP);
  }
  else
#endif
  {
    Dcm_PbRamNetConnId2TObjMap[index] = value;                                                                                                       /* SBSW_DCM_POINTER_WRITE_TOBJHANDLE */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetWriteAddBufferU8At()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetWriteAddBufferU8At(Dcm_NetTransportObjectPtrType pTranspObj
                                                               ,uint8 index
                                                               ,Dcm_MsgItemType value)
{
#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_NET_TOBJ_ADDBUFFER_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETWRITEADDBUFFERU8AT);
  }
  else
#endif
  {
    pTranspObj->AddBuffer[index] = value;                                                                                                            /* SBSW_DCM_POINTER_WRITE_TOBJ_ADDBUFFER */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetGetBufferInfo()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_PbCfgNetBufferInfoPtrType, DCM_CODE) Dcm_NetGetBufferInfo(Dcm_CfgNetBufferRefOptType index)
{
  Dcm_PbCfgNetBufferInfoPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= Dcm_PbCfgNetNumBuffers)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETGETBUFFERINFO);
    lResult = &Dcm_PbCfgNetBufferInfo[0];
  }
  else
#endif
  {
    lResult = &Dcm_PbCfgNetBufferInfo[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetCommonInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetCommonInit(void)
{
  Dcm_SingletonContext.Network.NumActiveConnections = 0u;
#if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.ActiveProtocol = DCM_NET_INVALID_PROTID;
#endif
  Dcm_SingletonContext.Network.ActiveDiagnostic = DCM_NET_COMM_ACTIVE;
#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.RxAllowed = TRUE;
#endif
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.KeepAlive = FALSE;
#endif
}

/**********************************************************************************************************************
 *  Dcm_NetComMInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComMInit(void)
{
  Dcm_CfgNetNetIdRefOptType lNetHandleIter;

  for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
  {
    Dcm_NetComMContextPtrType pComMContext;

    pComMContext = Dcm_NetGetComMContext(lNetHandleIter);

    pComMContext->ComState           = DCM_NET_COMM_STATE_RX_DIS_TX_DIS;                                                                             /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    pComMContext->RegisteredNetworks = 0u;                                                                                                           /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetBufferInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetBufferInit(void)
{
  Dcm_CfgNetBufferRefOptType lBufferIter;

  for(lBufferIter = 0; lBufferIter < Dcm_PbCfgNetNumBuffers; ++lBufferIter)
  {
    Dcm_NetBufferContextPtrType pBufferContext;

    pBufferContext = Dcm_NetGetBufferContext(lBufferIter);

    pBufferContext->IsInUseCnt = 0u;                                                                                                                 /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetConnectionInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetConnectionInit(void)
{
  Dcm_NetConnRefOptType lConnIter;

  for(lConnIter = 0; lConnIter < Dcm_PbCfgNetNumConnections; ++lConnIter)
  {
    Dcm_NetPutToConn2TObjMap(lConnIter, DCM_NET_INVALID_TOBJID);
  }
}

/**********************************************************************************************************************
 *  Dcm_NetTranspObjInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTranspObjInit(void)
{
  Dcm_CfgNetTObjHandleOptType lTObjIter;

  for(lTObjIter = 0; lTObjIter < Dcm_PbCfgNetNumTransportObjects; ++lTObjIter)
  {
    Dcm_NetTransportObjectPtrType pTranspObj;

    pTranspObj = Dcm_NetGetTransportObject(lTObjIter);

    pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_NONE;                                                                                                 /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    pTranspObj->State   = DCM_NET_TOBJ_STATE_FREE;                                                                                                   /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    pTranspObj->Flags   = DCM_NET_TOBJ_FLAG_NONE;                                                                                                    /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    Dcm_NetWriteAddBufferU8At(pTranspObj, 0, 0x7Fu); /* always used for negative responses */                                                        /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    pTranspObj->Handle  = (Dcm_CfgNetTObjHandleMemType)lTObjIter;                                                                                    /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgInit(void)
{
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
  /* Initialize periodic transmission manager state machine */
  Dcm_NetPeriodicMsgResetConnection();
  Dcm_NetPeriodicMsgInitDelayCntr();
  Dcm_NetPeriodicMsgInitFastestRate();
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
  {
    /* Initialization of delay timers */
    uint8_least lDelayTmrIter;
    for (lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
    {
      Dcm_NetDelayTimerSet(lDelayTmrIter, 0);
    }
  }
# endif
  {
    Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;
    for(lPerTxObjIter = 0; lPerTxObjIter < Dcm_PbCfgNetNumPerTxObjects; ++lPerTxObjIter)
    {
      /* Initialize the transport object */
      Dcm_PbRamNetPeriodicTxObject[lPerTxObjIter].Timer = 0u;
      Dcm_PbRamNetPeriodicTxObject[lPerTxObjIter].State = DCM_NET_PERIODIC_TX_STATE_FREE;
      Dcm_PbRamNetPeriodicTxObject[lPerTxObjIter].TxPduInfo.SduDataPtr = Dcm_PbRamNetPeriodicTxObject[lPerTxObjIter].TxBuffer;
    }
  }
#endif
}

/**********************************************************************************************************************
 *  Dcm_NetInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetInit(void)
{
  /* #10 First initialize common variables */
  Dcm_NetCommonInit();
  /* #20 Now initialize all remaining network related sub-elements. The order of execution shall not be relevant */
  Dcm_NetComMInit();
  Dcm_NetBufferInit();
  Dcm_NetConnectionInit();
  Dcm_NetTranspObjInit();
  Dcm_NetPeriodicMsgInit();
}

/**********************************************************************************************************************
 *  Dcm_NetComposeAddNegResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComposeAddNegResponse(Dcm_NetTransportObjectPtrType pTranspObj                                          /* COV_DCM_RTM_NO_RCR_RP_TX */
                                                                  ,Dcm_NetResponseType resType
                                                                  ,Dcm_NegativeResponseCodeType nrc)
{
  Dcm_NetWriteAddBufferU8At(pTranspObj, 2, nrc); /* NRC = nrc, 0x7F and SID are already copied! */                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  pTranspObj->BuffInfo.SduDataPtr = pTranspObj->AddBuffer; /* use the temp buffer to free the main buffer now */                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->BuffInfo.SduLength  = 3u;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->ResType             = resType;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->State               = DCM_NET_TOBJ_STATE_PREPTX;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
}

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetOnRequestDetection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetOnRequestDetection(Dcm_NetConnRefMemType connId)
{
  volatile Dcm_NetTransportObjectPtrType pTranspObj; /* Avoid any potential compiler optimizations declaring volatile kind of data */

  /* #10 Retrieve the transport object from the given connection */
  pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(connId);

  /* #20 Check whether a transport object is in use */
  if(pTranspObj != NULL_PTR)
  {
    /* #30 Enter critical section (Reason: the transport object may not be modified from outside (e.g. Dcm_TpTxConfirmation releases it) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    /* #40 Retrieve again the transport object from connection to guarantee it has still the same state */
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(connId);

    /* #45 Check the connection still uses the same transport object (it is always 1:1 association between connection and a transport object) */
    if(pTranspObj != NULL_PTR)                                                                                                                       /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
    {
      /* #50 Check whether the connection is free */
      if(pTranspObj->State != DCM_NET_TOBJ_STATE_FREE)
      {
# if (DCM_NET_SUPPRESS_ON_FUNC_REQ_ENABLED == STD_ON)
        /* #60 Check if suppression of responses on functional addressed requests is enabled */
        if( (Dcm_NetIsPropertieSet(pTranspObj, DCM_NET_CONN_PROP_TX_ON_FUNC_RX))
          &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE) )
        {
          /*
           * #70 Interruption of functional addressed request is not necessary because response will already be
           * suppressed
           */
        }
        /* #80 Otherwise, interrupt ongoing service processing */
        else
# endif
        {
          /* #90 If a new request is being received: */
          if(pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX)
          {
            /* #100 Isolate this connection */
            pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_CANCELED;                                                                                         /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */

            /* #110 Terminate the ongoing reception immediately */
            (void)Dcm_NetArEnvPduRCancelReceive(pTranspObj->RxPduId);
          }
          /* #120 Otherwise, let the task cancel any pending jobs */
          else
          {
            /* #130 Mark transport object as obsolete. This is used to distinguish between two allocations of the same transport object before the Dcm_NetTaskTaMonitor is called */
            pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_OBSOLETE;                                                                                         /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
            Dcm_TskSetEvent(DCM_TSK_ID_NET_TA_MONITOR, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));
          }
        }
      }/* else - nothing to interrupt */
    }/* else - request no more in progress -> ignore */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* #140 Leave critical section */
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }/* else - no request in progress or different tester -> ignore */
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if(DCM_NET_PROTOCOL_SWITCH_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetExecStartProtocolOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetExecStartProtocolOp(Dcm_ProtocolType newProtocol)
{
  boolean      lResult = TRUE;
  uint16_least lIter;

  for(lIter = 0u; Dcm_CfgNetProtocolNotificationInfo[lIter].StartFunc != NULL_PTR; ++lIter)
  {
    if(Dcm_CfgNetProtocolNotificationInfo[lIter].StartFunc(newProtocol) != DCM_E_OK)                                                                 /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */
    {
      lResult = FALSE;
      break;
    }
  }
  return lResult;
}
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetProcessStartProtocol()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetProcessStartProtocol(Dcm_NetTransportObjectPtrType pTranspObj)
{
# if(DCM_NET_PROTOCOL_SWITCH_NOTIFICATION_ENABLED == STD_ON)
  boolean startProtocolAllowed;

  startProtocolAllowed = Dcm_NetExecStartProtocolOp(Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfTranspObj(pTranspObj)].Id);
  if(startProtocolAllowed == FALSE)
  {
    Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    /* Neg response 0x22 */
    Dcm_NetComposeAddNegResponse(pTranspObj
                                ,DCM_NET_TOBJ_RESTYPE_SIMPLE
                                ,DCM_E_CONDITIONSNOTCORRECT);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND);
  }
  else
# endif
  {
    if(Dcm_NetGetProtIdOfActiveProtocol() < DCM_NET_INVALID_PROTID)
    {
# if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
      Dcm_DiagCancelProcessing();
# endif
      /* According to AR DCM SWS the session switch is executed at start protocol, not at stop! */
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);
    }/* else - no protocol enabled -> no need to reset anything */

    Dcm_SingletonContext.Network.ActiveProtocol = Dcm_NetGetProtIdOfTranspObj(pTranspObj);/* set new active protocol */

    /* Update P2 timings at once */
    Dcm_DiagSetP2Timings(0, Dcm_SingletonContext.Network.ActiveProtocol);

    Dcm_DiagRxIndication(pTranspObj);                                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisation_FindWinner()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetTObjHandleOptType, DCM_CODE) Dcm_NetRxPrioritisation_FindWinner(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pBusyEvents)
{
# if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
  uint16 lMaxPrio = 0x100u;/* lower than the lowest configurable priority (256 > 255) */
# endif
  Dcm_CfgNetTObjHandleOptType lTObjCntr = 0u;
  Dcm_CfgNetTObjHandleOptType lTranspObjWinnerId = DCM_NET_INVALID_TOBJID;

  *pBusyEvents = 0;                                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

  DCM_TSK_EVENT_SCAN_LOOP(ev)
  {
    /* Scan all arrived transport objects */
    if(Dcm_TskIsLocalEventSet(ev, 0x01u)) /* start scan from the LSB since TObjects are allocated by reversed iteration and thus -> first allocated (last checked here) will be the winner */
    {
# if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
      uint8 tmpProtPrio = Dcm_NetGetProtObjOfTranspObj(Dcm_NetGetTransportObject(lTObjCntr))->Priority;

      /* Higher priority */
      if(lMaxPrio <= tmpProtPrio)
      {
        /* Lower priority than current request/pending response */
        *pBusyEvents |= Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, lTObjCntr);                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      else
# endif
      {
        if(lTranspObjWinnerId < DCM_NET_INVALID_TOBJID)
        {
          /* Mark busy for the last winner */
          *pBusyEvents |= Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, lTranspObjWinnerId);                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
        }
# if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
        /* Update maximum priority */
        lMaxPrio = tmpProtPrio;
# endif
        /* potential winner found */
        lTranspObjWinnerId = lTObjCntr;
      }
    }
    ++lTObjCntr;
  }
  return lTranspObjWinnerId;
}
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessWinner()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_NetRxPrioritisationProcessWinner(
                                                                          Dcm_CfgNetTObjHandleOptType TranspObjWinnerId
                                                                         ,Dcm_TskTaskEvOptType BusyEvents)
{
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_NetGetTransportObject(TranspObjWinnerId);

  if(Dcm_NetGetProtIdOfActiveProtocol() != Dcm_NetGetProtIdOfTranspObj(pTranspObj))/* the winner is a different protocol as the old one -> interrupt the old protocol */
  {
    if( (Dcm_NetGetProtIdOfActiveProtocol() >= DCM_NET_INVALID_PROTID) /* very first protocol activation - start the protocol/send NRC 0x21 responses */
# if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
      ||(Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfTranspObj(pTranspObj)].Priority
         < Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfActiveProtocol()].Priority) /* new one is higher priority */
# endif
      ||( (((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE | DCM_DIAG_QUEUE_FLAG_IS_WAITING)
            & Dcm_InstanceContext.Diag.QueuedSet.Flags) == 0 ) /* if idle or post-processing (considered for back-to-back requests) ... */
        &&((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) != 0) ) /* ... still default session - continue with new request */
      )
    {
      Dcm_NetProcessStartProtocol(pTranspObj);                                                                                                       /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    }
    else
    {
      /* Mark busy for the winner */
      BusyEvents |= Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, TranspObjWinnerId);
    }
  }
  else /* same protocol - proceed with the new request/NRC 0x21 responses */
  {
    Dcm_DiagRxIndication(pTranspObj);                                                                                                                /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
  }
  return BusyEvents;
}
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessLoosers()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisationProcessLoosers(Dcm_TskTaskEvOptType BusyEvents)
{
  Dcm_CfgNetTObjHandleOptType lTObjCntr = 0u;

  DCM_TSK_EVENT_SCAN_LOOP(BusyEvents)
  {
    /* Check who did just loose */
    if(Dcm_TskIsLocalEventSet(BusyEvents, 0x01u))
    {
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTransportObject(lTObjCntr);
      Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

      Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                             /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
# if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_BUSY;                                                                                                   /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND);
# else
      Dcm_NetUnRegisterComMActivity(pTranspObj->ConnId);
      Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                               /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
# endif
    }
    ++lTObjCntr;
  }
}
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisation(Dcm_TskTaskEvOptType ev
                                                             ,Dcm_TskTaskEvPtrType pPostEv)                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType lBusyEvents;
  Dcm_CfgNetTObjHandleOptType lTranspObjWinnerId;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lTranspObjWinnerId = Dcm_NetRxPrioritisation_FindWinner(ev, &lBusyEvents);                                                                         /* SBSW_DCM_POINTER_FORWARD_STACK */
  lBusyEvents = Dcm_NetRxPrioritisationProcessWinner(lTranspObjWinnerId, lBusyEvents);
  Dcm_NetRxPrioritisationProcessLoosers(lBusyEvents);
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetRegisterActiveConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRegisterActiveConnection(Dcm_NetTransportObjectPtrType pTranspObj)                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0)/* internal requests do not manage the S3 timer */
#endif
  {
    Dcm_DebugAssert((Dcm_SingletonContext.Network.NumActiveConnections != Dcm_UtiMaxValueOfUintType(uint8)), DCM_SID_INTERNAL, DCM_E_PARAM)          /* COV_DCM_RTM_DEV_DEBUG XF */

    /* Enter critical section (Reason: protect the statistic counter against parallel request notifications or transmission confirmations, executed from within interrupts ) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
     BEGIN CRITICAL SECTION
     *=================================*/
    if(Dcm_SingletonContext.Network.NumActiveConnections == 0u)
    {
      Dcm_TmrStopTimer(DCM_TMR_ID_S3);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
      Dcm_TmrStopTimer(DCM_TMR_ID_KEEP_ALIVE);
#endif
    }

    /* Register a new active connection */
    ++Dcm_SingletonContext.Network.NumActiveConnections;
    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetTransmitUsdtResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTransmitUsdtResponse(Dcm_NetTransportObjectPtrType pTranspObj)
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  boolean doCallTxConfirmation = TRUE;

  /* The Tx path must be still "ready" here. if not, check the caller - it shall take care about this state! */
  Dcm_DebugAssert((pTranspObj->State == DCM_NET_TOBJ_STATE_PREPTX), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                           /* COV_DCM_RTM_DEV_DEBUG XF */

  /* Prepare the given transport object for USDT response transmission (set all relevant attributes to their initial values) */
  pTranspObj->BuffPos = 0u;                                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->State = DCM_NET_TOBJ_STATE_ONTX;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

  /* If the USDT response shall be suppressed for any non-diagnostic but transport protocol reasons (e.g. no response on functional requests or no TxPduId configured), do: */
#if (DCM_NET_SUPPRESS_ON_FUNC_REQ_ENABLED == STD_ON)
  if( (Dcm_NetIsPropertieSet(pTranspObj, DCM_NET_CONN_PROP_TX_ON_FUNC_RX))
    &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE) )
  {
    lStdResult = DCM_E_OK; /* No response on functional requests required -> leave with success */
  }
  else
#endif
#if (DCM_NET_CONNECTION_WITHOUT_TX_ENABLED == STD_ON)
  if (Dcm_NetIsPropertieSet(pTranspObj, DCM_NET_CONN_PROP_NO_MAIN_TX))
  {
    lStdResult = DCM_E_OK; /* No associated TxPduId -> leave with success */
  }
  else
#endif
  {
    /* Otherwise, if the communication mode on the ComM channel associated with the transport object still allows any response transmissions: */
    if((DCM_NET_COMM_STATE_FLAG_TX_EN & Dcm_NetGetComStateByTranspObject(pTranspObj)) != 0)
    {
      lStdResult = PduR_DcmTransmit(Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnId].TxPduIdMain
                                  ,&pTranspObj->BuffInfo);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      /* If this transmission request was accepted, wait for the Tx-Confirmation from the XxxTp */
      if(lStdResult == E_OK)
      {
        doCallTxConfirmation = FALSE;
      }
    }
  }
  /* Otherwise, take the shortcut and loop-back through the USDT message confirmation with failed result (this response had to be sent, but couldn't and no retry is allowed (SWS)) */

  /* Make a loop-back and finalize transmission */
  if(doCallTxConfirmation == TRUE)
  {
    Dcm_NetUsdtTxConfirmation(pTranspObj, lStdResult);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}

#if (DCM_NET_CONN_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetLockConnectionOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetLockConnectionOrNull(Dcm_NetConnRefMemType connId)
{
  Dcm_NetTransportObjectPtrType pTranspObj;

  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Try allocating a new or getting an already allocated transport object */
  pTranspObj = Dcm_NetAllocateOrGetTranspObjectOrNull(connId);

  if(pTranspObj != NULL_PTR)
  {
    if(pTranspObj->State == DCM_NET_TOBJ_STATE_FREE)
    {
      Dcm_NetBufferContextPtrType pBufferContext;

      /* Setup the transport object */
      pTranspObj->ConnId = connId;                                                                                                                   /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
      pTranspObj->BufferHdl = Dcm_NetGetProtObjOfConnection(connId)->RxTxBufferRef;                                                                  /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */

      pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

      /* Is the buffer still free ? */
      if(Dcm_NetBufferIsFree(pBufferContext))
      {
        Dcm_NetBufferLock(pBufferContext); /* the buffer is in use now */                                                                            /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
        pTranspObj->State  = DCM_NET_TOBJ_STATE_RESERVED;                                                                                            /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
      }
      else
      {
        Dcm_NetTranspObjRelease(pTranspObj);                                                                                                         /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        pTranspObj = NULL_PTR;
      }
    }
    else
    {
      pTranspObj = NULL_PTR;
    }
  }/* else - nothing found to be free */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  return pTranspObj;
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationNotOk()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationNotOk(Dcm_NetTransportObjectPtrType pTranspObj)
{
#if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) == 0) /* consider only real buffer usage */
#endif
  {
    Dcm_NetBufferContextPtrType pBufferContext;

    pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
  }
  Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
}

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationOk(Dcm_NetTransportObjectPtrType pTranspObj)
{
#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0) /* CancelReceive was called before -> ignore request although reception couldn't be canceled */
  {
    Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
#endif
  {
    boolean keepTranspObj;
    keepTranspObj = Dcm_DiagAcceptNewRequest(pTranspObj);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    pTranspObj->State = DCM_NET_TOBJ_STATE_RX_END;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

    if(keepTranspObj == TRUE)
    {
      Dcm_NetRegisterComMActivity(pTranspObj);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
#if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) != 0)
      {
        Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND);
      }
      else
#endif
      {
        /* Store SID for RCR-RP/busy on protocol prioritisation responses */
        Dcm_NetWriteAddBufferU8At(pTranspObj, 1u, pTranspObj->RxData[0]);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
        /* signal processing start */
#if (DCM_NET_TASK_RX_ENABLED == STD_ON)
        Dcm_TskSetEvent(DCM_TSK_ID_NET_RX, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));
#else
        Dcm_DiagRxIndication(pTranspObj);                                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
#endif
      }
    }
    else
    {
      Dcm_NetTpRxIndicationNotOk(pTranspObj);                                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
}

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgSetFastestRate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgSetFastestRate(Dcm_Svc2ASchedRateOptType Rate)
{
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  /* If the new rate differs from the previous rate */
  if (Dcm_NetPeriodicMsgGetFastestRate() != Rate)
  {
    Dcm_TmrTimerCntrMemType lRateDiff;
    uint8_least lDelayTmrIter;

    /* If changing to a faster rate */
    if (Rate > Dcm_NetPeriodicMsgGetFastestRate())
    {
      lRateDiff = (Dcm_TmrTimerCntrMemType) ( Dcm_NetGetPeriodicDelayTime(Dcm_NetPeriodicMsgGetFastestRate())
                                            - Dcm_NetGetPeriodicDelayTime(Rate) );

      for (lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
      {
        /*=================================*
          BEGIN CRITICAL SECTION
         *=================================*/
        Dcm_SplitTaskEnterCS(); /* Protect against interrupt from timer task */                                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
        /* If delay timer is set */
        if (!Dcm_NetDelayTimerExpired(lDelayTmrIter))
        {
          if (Dcm_NetDelayTimerGet(lDelayTmrIter) <= lRateDiff)
          {
            Dcm_NetDelayTimerSet(lDelayTmrIter, 1); /* immediate timeout */
          }
          else
          {
            /* decrease timer value by rate difference */
            Dcm_NetDelayTimerSet(lDelayTmrIter, Dcm_NetDelayTimerGet(lDelayTmrIter) - lRateDiff);
          }
        }
        Dcm_SplitTaskLeaveCS();                                                                                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
        /*=================================*
          END CRITICAL SECTION
         *=================================*/
      }
    }
    else /* Otherwise (changing to a slower rate) */
    {
      lRateDiff = (Dcm_TmrTimerCntrMemType) ( Dcm_NetGetPeriodicDelayTime(Rate)
                                            - Dcm_NetGetPeriodicDelayTime(Dcm_NetPeriodicMsgGetFastestRate()) );

      for (lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
      {
        /*=================================*
          BEGIN CRITICAL SECTION
         *=================================*/
        Dcm_SplitTaskEnterCS(); /* Protect against interrupt from timer task */                                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
        /* If delay timer is set */
        if (!Dcm_NetDelayTimerExpired(lDelayTmrIter))
        {
          /* increase timer value by rate difference */
          Dcm_NetDelayTimerSet(lDelayTmrIter, Dcm_NetDelayTimerGet(lDelayTmrIter) + lRateDiff);
        }
        Dcm_SplitTaskLeaveCS();                                                                                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
        /*=================================*
          END CRITICAL SECTION
         *=================================*/
      }
    }

    Dcm_SingletonContext.Network.PeriodicTxContext.FastestRate = (Dcm_Svc2ASchedRateMemType)Rate;
  }
# else
  DCM_IGNORE_UNREF_PARAM(Rate);
# endif
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPTxDelayTimerStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxDelayTimerStart(void)
{
  Dcm_NetDelayTimerSet(Dcm_NetPeriodicMsgGetNextDelayTimer()
                      ,Dcm_NetGetPeriodicDelayTime(Dcm_NetPeriodicMsgGetFastestRate()));
  Dcm_NetPeriodicMsgIncNextDelayTimer();                                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */

  /* Make sure system timer for periodic tx is running */
  Dcm_TmrStartTimer(DCM_TMR_ID_PERIODIC_TX, 1u);
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutTxObjectHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutTxObjectHandler(void)
{
  Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;
  boolean                       lReloadTimer = FALSE;

  for(lPerTxObjIter = 0; lPerTxObjIter < Dcm_PbCfgNetNumPerTxObjects; ++lPerTxObjIter)
  {
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvEnterCriticalSection(); /* protect against high level interrupts from the network interface */                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */
    if(!Dcm_NetPTxObjTimerExpired(lPerTxObjIter))
    {
      Dcm_NetPTxObjTimerDec(lPerTxObjIter);
      if(Dcm_NetPTxObjTimerExpired(lPerTxObjIter))
      {
        (void)Dcm_NetArEnvPduRCancelTransmit(Dcm_NetPeriodicMsgGetTxPduIdCurrConn(lPerTxObjIter)); /* try to cancel still ongoing Tx */
        Dcm_NetPeriodicMsgRelease(lPerTxObjIter);
      }
      else
      {
        lReloadTimer = TRUE; /* at least one active timer - reload timer */
      }
    }
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
  }

  return lReloadTimer;
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutDelayTimerHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutDelayTimerHandler(void)
{
  uint8_least lDelayTmrIter;
  boolean     lReloadTimer = FALSE;
  for(lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
  {
    if(!Dcm_NetDelayTimerExpired(lDelayTmrIter))
    {
      Dcm_NetDelayTimerDec(lDelayTmrIter);
      if(Dcm_NetDelayTimerExpired(lDelayTmrIter))
      {
        Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;
        Dcm_NetPeriodicMsgIncDelayCntr();
        for (lPerTxObjIter = 0; lPerTxObjIter < Dcm_NetPeriodicMsgGetNextMsgHdl(); lPerTxObjIter++)
        {
          if (Dcm_PbRamNetPeriodicTxObject[lPerTxObjIter].State == DCM_NET_PERIODIC_TX_STATE_QUEUED)
          {
            Dcm_NetPeriodicMsgTransmitTxObj(lPerTxObjIter);
            break;
          }
        }
      }
      else
      {
        lReloadTimer = TRUE; /* at least one active timer - reload timer */
      }
    }
  }

  return lReloadTimer;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgResetConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgResetConnection(void)
{
  Dcm_SingletonContext.Network.PeriodicTxContext.ConnIdInUse = DCM_NET_INVALID_CONNID;
  Dcm_NetPeriodicMsgResetNextMsgHdl();
  Dcm_NetPeriodicMsgResetTxObjectSentCntr();
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgStopDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgStopDid(uint16 Did)
{
  Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;
  for (lPerTxObjIter = 0; lPerTxObjIter < Dcm_NetPeriodicMsgGetNextMsgHdl(); lPerTxObjIter++)
  {
    if (  (Dcm_PbRamNetPeriodicTxObject[lPerTxObjIter].State != DCM_NET_PERIODIC_TX_STATE_FREE)
       && (Dcm_PbRamNetPeriodicTxObject[lPerTxObjIter].Did == Did))
    {
      /*=================================*
        BEGIN CRITICAL SECTION
       *=================================*/
      Dcm_UtiArEnvEnterCriticalSection(); /* Enter critical section (Reason: Protect against high level interrupts from the network interface) */    /* PRQA S 3109 */ /* MD_MSR_14.3 */
      switch (Dcm_PbRamNetPeriodicTxObject[lPerTxObjIter].State)
      {
        case DCM_NET_PERIODIC_TX_STATE_ONTX:
          (void)Dcm_NetArEnvPduRCancelTransmit(Dcm_NetPeriodicMsgGetTxPduIdCurrConn(lPerTxObjIter)); /* try to cancel still ongoing Tx */
          /* fallthrough */
        case DCM_NET_PERIODIC_TX_STATE_RESERVED:                                                                                                     /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
        case DCM_NET_PERIODIC_TX_STATE_QUEUED:
# endif
          Dcm_NetPeriodicMsgRelease(lPerTxObjIter);
          break;
        default:
          /* nothing to do */
          break;
      }
      Dcm_UtiArEnvLeaveCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
      /*=================================*
        END CRITICAL SECTION
       *=================================*/
    }
  }
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmitTxObj()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmitTxObj(Dcm_CfgNetPTxObjHandleOptType perTxObjHandle)
{
  Std_ReturnType lStdResult;

  if((DCM_NET_COMM_STATE_FLAG_TX_EN & Dcm_NetGetComStateByConnection(Dcm_NetPeriodicMsgGetConnection())) != 0)
  {
    Dcm_NetPeriodicMsgDecDelayCntr();
    Dcm_PbRamNetPeriodicTxObject[perTxObjHandle].State = DCM_NET_PERIODIC_TX_STATE_ONTX;
    /* Note: In case the following two lines are not executed within 100ms, the timeout may occur before the message was
     * sent (only if split tasks used). This may lead to inconsistent periodic data, since the transmitted message is
     * free to be reused again while it is on transmission. The design avoiding this very rare scenario will increase
     * the software complexity unnecessarily. Entering such conditions means that the ECU is not capable of holding the
     * periodic rates too.
     */
    Dcm_NetPTxObjTimerStart(perTxObjHandle, Dcm_PbCfgNetConnectionInfo[Dcm_NetPeriodicMsgGetConnection()].PeriodicTxConfTimeout);                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lStdResult = PduR_DcmTransmit(Dcm_NetPeriodicMsgGetTxPduIdCurrConn(perTxObjHandle)
                                 ,&(Dcm_PbRamNetPeriodicTxObject[perTxObjHandle].TxPduInfo));
  }
  else
  {
    lStdResult = DCM_E_NOT_OK;
  }

  if(lStdResult != DCM_E_OK)
  {
    /* Do not retry transmission -> make a loop-back and finalize transmission */
    Dcm_NetPeriodicMsgRelease(perTxObjHandle);
  }
}
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetTpTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpTxConfirmation(PduIdType txPduId
                                                             ,Dcm_NetArEnvNotifResultType result)
{
  uint8 lErrorId = DCM_E_NO_ERROR;
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfTxPduId(txPduId));

  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(pTranspObj == NULL_PTR)
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
  {
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    if(pTranspObj->State != DCM_NET_TOBJ_STATE_ONTX)
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
# endif
    {
      Dcm_NetUsdtTxConfirmation(pTranspObj, Dcm_NetArEnvGetTransmResult(result));                                                                    /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TXCONFIRMATION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
/**********************************************************************************************************************
 *  Dcm_NetIsPduInfoValid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsPduInfoValid(P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info)
{
  boolean lResult;

  if(info == NULL_PTR)
  {
    lResult = FALSE;
  }
  else if( (info->SduLength  != 0)
         &&(info->SduDataPtr == NULL_PTR) )
  {
    lResult = FALSE;
  }
  else
  {
    lResult = TRUE;
  }

  return lResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_NetCopyRxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyRxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                         ,P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info
                                                         ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr)
{
  BufReq_ReturnType lResult;
  uint8             lErrorId = DCM_E_NO_ERROR;

  /* #10 If the XxxTp (e.g. CanTp or FrTp) requests Dcm to copy any data: */
  if(info->SduLength != 0u) /* any payload now? */
  {
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    lResult = BUFREQ_E_NOT_OK;
    if (pTranspObj->BuffPos >= pTranspObj->RxLength)
    {
      lErrorId = DCM_E_PARAM;
    }
    else if((PduLengthType)(pTranspObj->RxLength - pTranspObj->BuffPos) < info->SduLength)
    {
      lErrorId = DCM_E_PARAM;
    }
    else
# endif
    {
# if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
      /* #30 If connection has been yet canceled (if RxPath supports cancellation), do return failed copy data result */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0)
      {
        lResult = BUFREQ_E_NOT_OK;
      }
      else
# endif
      {

        /* #40 If the transmission is for a main-client (full request reception), do copy the data portion provided by the XxxTp */
# if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
        if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) != 0)
        {
          /* #50 For the very first call of this function for this request reception, do copy the request head (SID and SubFunction) for later usage (i.e. for 0x3E 0x80 detection) */
          if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_COPYHEAD) != 0)
          {
            Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_COPYHEAD);  /* Toggle flag for next calls to not extract any SID/SUBSID data */ /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */ /* SBSW_DCM_PARAM_PTR_WRITE */
            Dcm_NetWriteAddBufferU8At(pTranspObj, 1, info->SduDataPtr[0]); /* copy the SID */                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
            Dcm_NetWriteAddBufferU8At(pTranspObj, 2, info->SduDataPtr[1]); /* copy the SUBSID */                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
          }
        }
        else
# endif
        {
          Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

          lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

          Dcm_UtiMemCopySafe(info->SduDataPtr
                            ,lBufferInfo->BufferPtr
                            ,pTranspObj->BuffPos
                            ,lBufferInfo->Size
                            ,info->SduLength);                                                                                                       /* SBSW_DCM_POINTER_WRITE_BUFFERINFO */
        }
        /* #60 Update the transport object's buffer-copy-progress */
        pTranspObj->BuffPos += (Dcm_CfgNetBufferSizeMemType)(info->SduLength);                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

        /* #70 Report the remaining available DCM buffer size to the XxxTp */
        *bufferSizePtr = (PduLengthType)(pTranspObj->RxLength - pTranspObj->BuffPos);                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = BUFREQ_OK;
      }
    }
    /* #80 Otherwise if connection has been canceled, return negative result to signal the XxxTp to abort the transmission (if RxPath supports cancellation) */
  }
  else
  {
    /* #90 Otherwise, the XxxTp requests Dcm only to report the available buffer size  */
    *bufferSizePtr = (PduLengthType)(pTranspObj->RxLength - pTranspObj->BuffPos); /* Notify lower layer about available buffer space */              /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = BUFREQ_OK;
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COPYRXDATA, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndication(PduIdType rxPduId
                                                           ,Dcm_NetArEnvNotifResultType result)
{
  Dcm_NetTransportObjectPtrType pTranspObj;
  pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfRxPduId(rxPduId));

  /* If no transport object has been associated with this connection yet, do ignore this indication */
  if(pTranspObj != NULL_PTR)
  {
    /* Otherwise, if the transport object is determined to belong to the expected request, that means: */
    if( (pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX) /* expected state for Rx indication? */
      &&(rxPduId == pTranspObj->RxPduId) ) /* Consider also any nested request on different TP connection but from the same tester! */
    {
      if(result != DCM_NET_ARENV_NTFRSLT_OK)
      {
        Dcm_NetTpRxIndicationNotOk(pTranspObj);                                                                                                      /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
      else
      {
        Dcm_NetTpRxIndicationOk(pTranspObj);                                                                                                         /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
    }/* Otherwise, just ignore this call since this API call is most probably due to a (concurrent request (i.e. 0x3E 0x80) from the same tester) OR
      * (indication of unexpected connection) */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetCopyLinearTxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyLinearTxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                      ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                             /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                      ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr)
{
  BufReq_ReturnType lResult;
  uint8             lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = BUFREQ_E_NOT_OK;

  if( (info->SduLength != 0u)
    &&(pTranspObj->BuffPos >= pTranspObj->BuffInfo.SduLength) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else if((PduLengthType)(pTranspObj->BuffInfo.SduLength - pTranspObj->BuffPos) < info->SduLength)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    /* Copy requested amount of data to the XxxTp */
    Dcm_UtiMemCopySafe(&(pTranspObj->BuffInfo.SduDataPtr[pTranspObj->BuffPos])
                      ,info->SduDataPtr
                      ,0u
                      ,info->SduLength
                      ,info->SduLength);                                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
    /* Update Tx-buffer read progress */
    pTranspObj->BuffPos += (Dcm_CfgNetBufferSizeMemType)(info->SduLength);                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Report remaining amount of data in the Tx-buffer */
    *availableDataPtr = (PduLengthType)(pTranspObj->BuffInfo.SduLength - pTranspObj->BuffPos);                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = BUFREQ_OK;
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COPYTXDATA, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetCopyTxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyTxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                      ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                             /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                      ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr)
{
  BufReq_ReturnType lResult;

# if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0)
  {
    lResult = BUFREQ_E_NOT_OK;
  }
  else
# endif
  {
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
    if(pTranspObj->ResType == DCM_NET_TOBJ_RESTYPE_PAGED)
    {
      lResult = Dcm_PagedBufferCopyData(info, availableDataPtr);                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
# endif
    {
      lResult = Dcm_NetCopyLinearTxData(pTranspObj, info, availableDataPtr);                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }

  return lResult;
}
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_RepeaterNextStep()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_RepeaterNextStep(Dcm_RepeaterProgressType nextStep)
{
  Dcm_InstanceContext.Repeater.Contexts.Progress = nextStep;
  Dcm_RepeaterResetOpStatus();
}

/**********************************************************************************************************************
 *  Dcm_CfgDiagServiceInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgDiagServiceInfoPtrType, DCM_CODE) Dcm_CfgDiagServiceInfoGetEntryOrNull(uint8 SidIndex)
{
  Dcm_CfgDiagServiceInfoPtrType lServiceInfo;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SidIndex >= DCM_CFGDIAGSERVICEINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGDIAGSERVICEINFOGETENTRY);
    lServiceInfo = NULL_PTR;
  }
  else
#endif
  {
    lServiceInfo = &Dcm_CfgDiagServiceInfo[SidIndex];
  }

  return lServiceInfo;
}
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_ModeInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeInit(void)
{
  /* Initialize ControlDTCsetting internal mode */
  Dcm_ModeSetControlDtcSettingGroup(DEM_DTC_GROUP_ALL_DTCS);
  Dcm_ModeSetControlDtcSettingMode(RTE_MODE_DcmControlDtcSetting_ENABLEDTCSETTING);

# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  /* Initialize CommunicationControl internal mode */
  {
    uint8_least channelIter;
    for(channelIter = 0; channelIter < Dcm_PbCfgNetNumAllComMChannels; ++channelIter)
    {
      Dcm_ModeSetCommControlState(channelIter, DCM_ENABLE_RX_TX_NORM_NM);
    }
  }
# endif
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.LastDisableDTCClientID = DCM_NET_DEFAULT_DEM_CLIENTID;
# endif
}

# if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgModeMgrRulesGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_ModeRuleFuncType, DCM_CODE) Dcm_CfgModeMgrRulesGetEntryOrNull(Dcm_CfgModeMgrRuleRefOptType modeRuleRef)
{
  Dcm_ModeRuleFuncType lModeRuleFunc;

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (modeRuleRef >= DCM_CFGMODEMGRRULES_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGMODEMGRRULESGETENTRY);
    lModeRuleFunc = NULL_PTR;
  }
  else
#  endif
  {
    lModeRuleFunc = Dcm_CfgModeMgrRules[modeRuleRef];
  }

  return lModeRuleFunc;
}
# endif

# if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeCheck(Dcm_CfgModeMgrRuleRefOptType modeRuleRef
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdReturn = DCM_E_NOT_OK;
  Dcm_NegativeResponseCodeType lNrc = DCM_E_CONDITIONSNOTCORRECT;/* default NRC in case no rule specifies any NRC */
  Dcm_ModeRuleFuncType lModeRuleFunc;

  /* Retrieve mode rule verification handler */
  lModeRuleFunc = Dcm_CfgModeMgrRulesGetEntryOrNull(modeRuleRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (lModeRuleFunc == NULL_PTR)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_MODECHECK);
    lNrc = DCM_E_PANIC_NRC;
  }
  else
#  endif
  {
    /* Execute the mode-rule handler and return the result */
    if(lModeRuleFunc(&lNrc) == TRUE)                                                                                                                 /* SBSW_DCM_CALL_FUNCPTR_MODEMGRRULES */
    {
      lStdReturn = DCM_E_OK;
    }
  }

  *ErrorCode = lNrc;                                                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
  return lStdReturn;
}
# endif

# if (DCM_MODE_CTRLDTCSETTING_MONITOR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeMonitorControlDtcSetting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeMonitorControlDtcSetting(Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_NegativeResponseCodeType lNrc;/* the value is not used, just the standard API requires it */
  Dcm_ModeRuleFuncType lModeRuleFunc;

  lModeRuleFunc = Dcm_CfgModeMgrRulesGetEntryOrNull(DCM_MODE_CTRLDTCSETTING_MONITOR_MODERULE_REF);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (lModeRuleFunc == NULL_PTR)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_MODEMONITORCONTROLDTCSETTING);
    /* Try to recover immediately since something obviously went wrong and no automatic recovery will take place later */
    /* fire and forget */
    (void)Dcm_Svc85EnableDtcSetting(Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.LastDisableDTCClientID);
  }
  else
#  endif
  {
    if (lModeRuleFunc(&lNrc) == TRUE)                                                                                                                /* SBSW_DCM_CALL_FUNCPTR_MODEMGRRULES */
    {
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_MODE_MON_SVC85);                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      /* fire and forget */
      (void)Dcm_Svc85EnableDtcSetting(Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.LastDisableDTCClientID);
    }
  }
}
# endif

# if (DCM_MODE_COMMCTRL_MONITOR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeMonitorCommunicationControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeMonitorCommunicationControl(Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_NegativeResponseCodeType lNrc;/* the value is not used, just the standard API requires it */
  Dcm_ModeRuleFuncType lModeRuleFunc;

  lModeRuleFunc = Dcm_CfgModeMgrRulesGetEntryOrNull(DCM_MODE_COMMCTRL_MONITOR_MODERULE_REF);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (lModeRuleFunc == NULL_PTR)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_MODEMONITORCOMMUNICATIONCONTROL);
    /* Try to recover immediately since something obviously went wrong and no automatic recovery will take place later */
    Dcm_Svc28EnableCommunication();
  }
  else
#  endif
  {
    if (lModeRuleFunc(&lNrc) == TRUE)                                                                                                                /* SBSW_DCM_CALL_FUNCPTR_MODEMGRRULES */
    {
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_MODE_MON_SVC28);                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      Dcm_Svc28EnableCommunication();
    }
  }
}
# endif
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON) || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckEcuReset(void)
{
  return DCM_E_OK;/* always succeeds */
}
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON) || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchEcuReset(Dcm_ResetModeType mode)
{
  BswM_Dcm_RequestResetMode(mode);
  return DCM_E_OK;
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)   || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckResultInterpreter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckResultInterpreter(Std_ReturnType modeSwitchAckResult)
{
  Std_ReturnType lStdResult;

  switch(modeSwitchAckResult)
  {
  case RTE_E_TRANSMIT_ACK:
    /* switch accomplished */
    lStdResult = DCM_E_OK;
    break;
  case RTE_E_NO_DATA:
    lStdResult = DCM_E_PENDING;
    break;
  default: /* any error situation */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckEcuReset(void)
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_SwitchAck_DcmEcuReset_DcmEcuReset();

  return Dcm_ModeSwitchAckResultInterpreter(lStdResult);
}
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckRapidShutDown()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckRapidShutDown(void)
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_SwitchAck_DcmModeRapidPowerShutDown_DcmModeRapidPowerShutDown();

  return Dcm_ModeSwitchAckResultInterpreter(lStdResult);
}
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchEcuReset(Rte_ModeType_DcmEcuReset mode)
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_Switch_DcmEcuReset_DcmEcuReset(mode);

  Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
  return lStdResult;
}
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchRapidShutDown()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchRapidShutDown(Rte_ModeType_DcmModeRapidPowerShutDown mode)
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_Switch_DcmModeRapidPowerShutDown_DcmModeRapidPowerShutDown(mode);

  Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
  return lStdResult;
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_StateInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateInit(void)
{
  Dcm_SingletonContext.StateMgr.Preconditions.Session  = DCM_STATE_VALUE_SESSION_INIT;
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  Dcm_SingletonContext.StateMgr.Preconditions.Security = DCM_STATE_VALUE_SECURITY_INIT;
#endif

  Dcm_StateSyncPendingSession();
}

#if (DCM_STATE_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateExecOnStateChangeFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateNotificationInfoPtrType notifList                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,uint8 formerStateId
                                                                    ,uint8 newStateId)
{
  /* Iterate over all with the diagnostic state group state change related notifications, as long as the EndOfList marker is not reached */
  while(notifList->OnChgFunc != NULL_PTR)
  {
    /* Invoke the configured notification function */
    notifList->OnChgFunc(formerStateId, newStateId);                                                                                                 /* SBSW_DCM_PARAM_FUNCPTR_CALL */
    Dcm_UtiNextItemByPtr(notifList,1u);/* take next function */
  }
}
#endif

#if (DCM_STATE_SECURITY_LOOKUP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateFindStateIndexFromSecLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint8_least, DCM_CODE) Dcm_StateFindStateIndexFromSecLevel(Dcm_SecLevelType secLevel)
{
  sint8_least lResult;

  /* #10 If "locked" level: */
  if(secLevel == DCM_SEC_LEV_LOCKED)
  {
    /* #20 Return the only possible index - 0 */
    lResult = 0;
  }
  else
  {
    /* #30 Otherwise locate the index of the security level value in the security info table */
    uint8_least lSecLvlIter;

    lResult = -1;
    for(lSecLvlIter = 0; lSecLvlIter < DCM_STATE_SECURITY_NUM_LEVELS; ++lSecLvlIter)
    {
      if (Dcm_CfgStateSecurityInfo[lSecLvlIter].Value == secLevel)
      {
        /* #40 Found the correct index into the table - compensate zero offset for locked level */
        lResult = (sint8_least)(lSecLvlIter + 1);
        break;
      }
    }
    /* #50 If the security level is not found, return -1 */
  }
  /* #60 Return final result */
  return lResult;
}
#endif

#if ((DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)  &&  (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON))                                     /* COV_DCM_UNSUPPORTED XF tf xf */
/**********************************************************************************************************************
*  Dcm_StateVsgGetSecurityFixedByteStateIdx()
*********************************************************************************************************************/
/*!
* Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateVsgGetSecurityFixedByteStateIdx(
                                                            P2VAR(sint32_least, AUTOMATIC, DCM_APPL_DATA) pStateIndex)
{
  Std_ReturnType lStdResult;
  Dcm_CfgVarMgrDiagVariantIdOptType varRowIter;
  Dcm_VsgSizeType lNumberOfFixedBytes;
  sint32_least lRefToVsg;

  lRefToVsg = (sint32) Dcm_StateGetVsgMaskInfoIdx(*pStateIndex);
  lStdResult = DCM_E_NOT_OK;

  /* If there is any Securtiy Level with more than 1 security fixed byte configured */
  lNumberOfFixedBytes = Dcm_StateGetNumberOfVsgs(*pStateIndex);

  /* Iterate over all securtiy fixed bytes that are assigned to referenced security level */
  /* If lNumberOfFixedBytes is 0 -> no security fixed byte is configured for securtiy level */
  for (; lNumberOfFixedBytes > 0; --lNumberOfFixedBytes)
  {
    varRowIter = Dcm_VarMgrBitSetCalcSize(DCM_VARMGR_NUM_CFG_VARIANTS);

    /* scan all variants (at least 8 way scan) for at least one match */
    do
    {
      --varRowIter;
      if ((Dcm_CfgStateVsgMaskSecurityFixedByte[lRefToVsg][varRowIter] & Dcm_SingletonContext.VarMgr.ActiveCfgVariants[varRowIter]) != 0)
      {
        lStdResult = DCM_E_OK;/* at least one matched variant */
        *pStateIndex = lRefToVsg;
        break;
      }/* else - continue searching */
    } while (varRowIter != 0);

    /* If security level is assigned to active VSG */
    if (lStdResult == DCM_E_OK)
    {
      /* stop iterating over fixed bytes */
      break;
    }

    ++lRefToVsg;
  }

  return lStdResult;
}
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateGetSecurityLevelFixedBytes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateGetSecurityLevelFixedBytes(Dcm_SecLevelType secLevel
                                                                    ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) fixedBytes
                                                                    ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) bufferSize)
{
  Std_ReturnType  lResult;
  sint32_least    lStateIdx;

  lStateIdx = Dcm_StateFindStateIndexFromSecLevel(secLevel);
  if (lStateIdx <= 0)
  {
    /* Locked, or unsupported security level */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    uint8 lFixedByteSize;
    --lStateIdx; /* norm to zero index (excluded locked state offset) */

# if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                              /* COV_DCM_UNSUPPORTED XF */
    lResult = Dcm_StateVsgGetSecurityFixedByteStateIdx(&lStateIdx);
    if (lResult == DCM_E_NOT_OK)
    {
      lFixedByteSize = 0;
      lResult = E_OK;
    }
    else
# endif
    {
      lFixedByteSize = (uint8)(Dcm_CfgStateSecurityFixedByteInfo[lStateIdx + 1]
                             - Dcm_CfgStateSecurityFixedByteInfo[lStateIdx + 0]);
      if (lFixedByteSize > *bufferSize)
      {
        lResult = DCM_E_BUFFERTOOLOW;
      }
      else
      {
        Dcm_UtiMemCopySafe(&Dcm_CfgStateSecurityFixedBytes[Dcm_CfgStateSecurityFixedByteInfo[lStateIdx]]
                          ,fixedBytes
                          ,0u
                          ,*bufferSize
                          ,lFixedByteSize);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
        lResult = E_OK;
      }
    }
    *bufferSize = lFixedByteSize;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_StateNotifyServiceProcessors()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateNotifyServiceProcessors(void)
{
  /* now process session/security state updates:
    - on any session transition: security is always changed
    - on security state transition: security is always changed
  */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc27OnStateChanged();
#endif
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2COnStateChanged();
#endif
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2AOnStateChanged();
#endif
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2FOnStateChanged();
#endif
}
/**********************************************************************************************************************
 *  Dcm_TskGetTaskInfoOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskInfoPtrType, DCM_CODE) Dcm_TskGetTaskInfoOrNull(Dcm_TskTaskIdOptType index)
{
  Dcm_TskTaskInfoPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_TSK_NUM_TASKS)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_TSKGETTASKINFO);
    lResult = NULL_PTR;
  }
  else
#endif
  {
    lResult = &Dcm_TskTaskInfo[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_TskGetTaskContextOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskContextPtrType, DCM_CODE) Dcm_TskGetTaskContextOrNull(Dcm_TskTaskIdOptType taskId)
{
  Dcm_TskTaskContextPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(taskId >= DCM_TSK_NUM_TASKS)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_TSKGETTASKCONTEXT);
    lResult = NULL_PTR;
  }
  else
#endif
  {
    lResult = &Dcm_SingletonContext.TaskMgr.TaskContext[taskId];
  }

  return lResult;
}

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskRegisterActiveTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskRegisterActiveTask(Dcm_TskTaskIdOptType taskId)
{
  /* Enter critical section (Reason: To guarantee safe reentrancy policy for the task stack when split-tasks interrupt each other.) */
  Dcm_SplitTaskEnterCS();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(Dcm_TskTraceIsFull())
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_TSKREGISTERACTIVETASK);
  }
  else
# endif
  {
    Dcm_TskTraceTskPush(taskId);                                                                                                                     /* PRQA S 3440 */ /* MD_Dcm_OptimizedInlineCode_3440 */ /* SBSW_DCM_POINTER_WRITE_CURRENT_TASK_PRIO_STACK */
  }

  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();
}
#endif

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskUnRegisterActiveTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskUnRegisterActiveTask(void)
{
  /* Enter critical section (Reason: To guarantee safe reentrancy policy for the task stack when split-tasks interrupt each other.) */
  Dcm_SplitTaskEnterCS();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(Dcm_TskTraceIsEmpty())
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_TSKUNREGISTERACTIVETASK);
  }
  else
# endif
  {
    Dcm_TskTraceTskPop();
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();
}
#endif

/**********************************************************************************************************************
 *  Dcm_TskGetSchedulerContextOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskSchedulerContextPtrType, DCM_CODE) Dcm_TskGetSchedulerContextOrNull(
                                                                                  Dcm_TskTaskPrioOptType schedulerPrio)
{
  Dcm_TskSchedulerContextPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(schedulerPrio >= DCM_TSK_NUM_PRIOS)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_TSKGETSCHEDULERCONTEXT);
    lResult = NULL_PTR;
  }
  else
#endif
  {
    lResult = &Dcm_SingletonContext.TaskMgr.TaskScheduler[schedulerPrio];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_TskInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskInit(void)
{
  /* #10 Initialize task activity tracer */
  Dcm_TskTraceInit();

  /* #20 Initialize priority related states */
  {
    Dcm_TskTaskPrioOptType tskPrioIter;

    for(tskPrioIter = 0; tskPrioIter < DCM_TSK_NUM_PRIOS; ++tskPrioIter)
    {
      Dcm_TskSchedulerContextPtrType pSchedulerContext;
      pSchedulerContext = Dcm_TskGetSchedulerContextOrNull(tskPrioIter);
      pSchedulerContext->SchdIsActive = FALSE;                                                                                                       /* SBSW_DCM_POINTER_WRITE_SCHEDULERCONTEXT */
    }
  }

  /* #30 Initialize task related events */
  {
    Dcm_TskTaskIdOptType tskIter;

    for(tskIter = 0; tskIter < DCM_TSK_NUM_TASKS; ++tskIter)
    {
      Dcm_TskTaskContextPtrType pTaskContext;
      pTaskContext = Dcm_TskGetTaskContextOrNull(tskIter);
      pTaskContext->TaskEvents = DCM_TSK_EV_NONE;                                                                                                    /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */
    }
  }
}

#if (DCM_TSK_TASK_KILL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskKillAllTasks()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskKillAllTasks(void)
{
  Dcm_TskTaskIdOptType tskIter;

  /* Enter critical section (Reason: A task event can be set during any ISR processing.) */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/

   for(tskIter = 0; tskIter < DCM_TSK_NUM_TASKS; ++tskIter)
   {
     if((Dcm_TskTaskInfo[tskIter].TskAtr & DCM_TSK_ATR_KILL_ALWAYS) != 0)
     {
       Dcm_TskTaskContextPtrType pTaskContext = Dcm_TskGetTaskContextOrNull(tskIter);
       pTaskContext->TaskEvents &= Dcm_TskTaskInfo[tskIter].NonKillEvents; /* clear only killable events */                                          /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */

# if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)
       Dcm_TskSetFlag(pTaskContext, DCM_TSK_TASK_FLAG_KILLED);                                                                                       /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */
# endif
     }
   }

  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}
#endif

#if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TskReviveAllTasks()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskReviveAllTasks(void)
{
   Dcm_TskTaskIdOptType tskIter;

   for(tskIter = 0; tskIter < DCM_TSK_NUM_TASKS; ++tskIter)
   {
     Dcm_TskTaskContextPtrType pTaskContext = Dcm_TskGetTaskContextOrNull(tskIter);
     Dcm_TskClrFlag(pTaskContext, DCM_TSK_TASK_FLAG_KILLED);                                                                                         /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */ /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */
   }
}
#endif

/**********************************************************************************************************************
 *  Dcm_TskScheduleActiveTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskExecuteActiveTask(Dcm_TskTaskIdOptType taskId
                                                              ,Dcm_TskTaskEvOptType taskEv)
{
  Dcm_TskTaskInfoPtrType lTaskInfo;

  lTaskInfo = Dcm_TskGetTaskInfoOrNull(taskId);

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(lTaskInfo != NULL_PTR)                                                                                                                          /* COV_DCM_RTM_RUNTIME_CHECK TX */
#endif
  {
    Dcm_TskTaskEvOptType postEv = DCM_TSK_EV_NONE;

    /* Handle task execution: */
    do
    {
      /* Clear all already known global events */
      Dcm_TskClrEvent(taskId, (Dcm_TskTaskEvMemType)taskEv);

      /* Register the taskID to the task trace */
      Dcm_TskRegisterActiveTask(taskId);

      /* Execute the task */
      lTaskInfo->TskFunc(taskEv, &postEv);                                                                                                           /* SBSW_DCM_CALL_FUNCPTR_TASKINFO */

      /* Unregister the taskID from the task trace */
      Dcm_TskUnRegisterActiveTask();

      /* If the task supports multiple activations per scheduler invocation, do get any new events sent to this task */
      if((lTaskInfo->TskAtr & DCM_TSK_ATR_EXEC_MULTI) != 0)
      {
        taskEv = Dcm_TskGetEvent(taskId);
      }
      else
      {
        /* Otherwise do not re-activate the task in this scheduler invocation */
        taskEv = DCM_TSK_EV_NONE;
      }
    }
    /* As long as the task needs the be re-activated */
    while(taskEv != DCM_TSK_EV_NONE);

    /* Register any new events of the already finished task that are scheduled for its next activation */
    if(postEv != DCM_TSK_EV_NONE)
    {
      Dcm_TskSetEvent(taskId, (Dcm_TskTaskEvMemType)postEv);
    }
  }
}
/**********************************************************************************************************************
 *  Dcm_TmrGetTimerInfoOrNull()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerInfoPtrType, DCM_CODE) Dcm_TmrGetTimerInfoOrNull(Dcm_TmrTimerIdOptType index)
{
  Dcm_TmrTimerInfoPtrType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_TMR_NUM_TIMERS_CASTED)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_TMRGETTIMERINFO);
    lResult = NULL_PTR;
  }
  else
#endif
  {
    lResult = &Dcm_TmrTimerInfo[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_TmrSetTimer()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TmrSetTimer(Dcm_TmrTimerIdOptType timerId, Dcm_TmrTimerCntrMemType value)
{
#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(timerId >= DCM_TMR_NUM_TIMERS_CASTED)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_TMRSETTIMER);
  }
  else
#endif
  {
    Dcm_SingletonContext.TimerMgr.Timer[timerId] = value;                                                                                            /* SBSW_DCM_POINTER_WRITE_TIMER */
  }
}

/**********************************************************************************************************************
 *  Dcm_TmrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TmrInit(void)
{
  Dcm_TmrTimerIdOptType iter;

  for(iter = 0; iter < DCM_TMR_NUM_TIMERS_CASTED; ++iter)
  {
    Dcm_TmrSetTimer(iter, 0u);
  }
}
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_CfgRidMgrOpInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RidMgrOpInfoPtrType, DCM_CODE) Dcm_CfgRidMgrOpInfoGetEntryOrNull(Dcm_CfgRidMgrOpHandleOptType ridOpInfoIdx)
{
  Dcm_RidMgrOpInfoPtrType lRidOpInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (ridOpInfoIdx >= DCM_CFGRIDMGROPINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGRIDMGROPINFOGETENTRY);
    lRidOpInfo = NULL_PTR;
  }
  else
# endif
  {
    lRidOpInfo = &Dcm_CfgRidMgrOpInfo[ridOpInfoIdx];
  }

  return lRidOpInfo;
}

/**********************************************************************************************************************
 *  Dcm_RidMgrExecuteRoutine()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrExecuteRoutine(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc31RepeaterProxyContextPtrType pRepContext)                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType          lStdResult;
  Dcm_RidMgrOpInfoPtrType pRidOpInfo;
# if (DCM_RIDMGR_DYN_LEN_ENABLED == STD_ON)
  Dcm_RidMgrRidLengthType reqResLen;
# endif

# if (DCM_RIDMGR_DYN_LEN_ENABLED == STD_ON)
  reqResLen = (Dcm_RidMgrRidLengthType)(pMsgContext->reqDataLen - Dcm_CfgRidMgrOpInfoReqMinLength(pRepContext->RidOpInfoIdx));/* on dynamic length -> already subtracted to the last signal length */
# endif

  pRidOpInfo = Dcm_CfgRidMgrOpInfoGetEntryOrNull(pRepContext->RidOpInfoIdx);
# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if ((pRidOpInfo == NULL_PTR) || (pRidOpInfo->ResMaxLength > pMsgContext->resMaxDataLen))                                                           /* COV_DCM_RTM_RUNTIME_CHECK TF xf tf */
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_RIDMGREXECUTEROUTINE);
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
# endif
  {
  /* Prepare response buffer for routine info byte (if enabled) */
# if (DCM_RIDMGR_SUPPORT_ROUTINEINFOBYTE_ENABLED == STD_ON)

    /* Read routine info byte of RID from configuration; RIDs that do not support routine info byte have a invalid value */
    Dcm_CfgRidMgrRoutineInfoByteMemType lRoutineInfoByte = Dcm_CfgRidMgrRidInfoRoutineInfoByte(pRepContext->RidInfoIdx);

    /* If initial call of function and routine info byte of Rid is valid, reserve 1 byte in response buffer by moving response buffer pointer */
    if ((opStatus == DCM_INITIAL)
        && (lRoutineInfoByte != DCM_CFGRIDMGR_INVALID_ROUTINEINFOBYTE))
    {
      pRepContext->RIBResIdx = pMsgContext->resIndex;
      Dcm_DiagProvideResData(pMsgContext, 1u);
    }
# endif

    /* call appropriate function prototype */
    switch(pRidOpInfo->OpType)
    {
# if (DCM_RIDMGR_OPTYPE_NONE_ENABLED == STD_ON)
    case DCM_RIDMGR_OPTYPE_NONE:
    lStdResult = ((Dcm_RidMgrOpFuncNoParamsType)pRidOpInfo->OpFunc)(opStatus                                                                         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                   ,ErrorCode);
      break;
# endif
# if (DCM_RIDMGR_OPTYPE_REQ_ENABLED == STD_ON)
    case DCM_RIDMGR_OPTYPE_REQ:
    lStdResult = ((Dcm_RidMgrOpFuncReqType)pRidOpInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                              ,opStatus
                                                              ,ErrorCode);
      break;
# endif
# if (DCM_RIDMGR_OPTYPE_REQ_RES_ENABLED == STD_ON)
    case DCM_RIDMGR_OPTYPE_REQ_RES:
    lStdResult = ((Dcm_RidMgrOpFuncReqResType)pRidOpInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                 ,opStatus
                                                                 ,Dcm_DiagGetResData(pMsgContext)                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                 ,ErrorCode);
      break;
# endif
# if (DCM_RIDMGR_OPTYPE_RES_ENABLED == STD_ON)
    case DCM_RIDMGR_OPTYPE_RES:
    lStdResult = ((Dcm_RidMgrOpFuncResType)pRidOpInfo->OpFunc)(opStatus                                                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                              ,Dcm_DiagGetResData(pMsgContext)                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                              ,ErrorCode);
      break;
# endif
# if (DCM_RIDMGR_OPTYPE_REQ_DYNLEN_ENABLED == STD_ON)
    case DCM_RIDMGR_OPTYPE_REQ_DYNLEN:
    lStdResult = ((Dcm_RidMgrOpFuncReqDynLenType)pRidOpInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                                 /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                    ,opStatus
                                                                    ,reqResLen
                                                                    ,ErrorCode);
      break;
# endif
# if (DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_ENABLED == STD_ON)
    case DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES:
    lStdResult = ((Dcm_RidMgrOpFuncReqDynLenResType)pRidOpInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                       ,opStatus
                                                                       ,Dcm_DiagGetResData(pMsgContext)                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                       ,reqResLen
                                                                       ,ErrorCode);
      break;
# endif
# if (DCM_RIDMGR_OPTYPE_RES_DYNLEN_ENABLED == STD_ON)
    case DCM_RIDMGR_OPTYPE_RES_DYNLEN:
    lStdResult = ((Dcm_RidMgrOpFuncResDynLenType)pRidOpInfo->OpFunc)(opStatus                                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                    ,Dcm_DiagGetResData(pMsgContext)                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                    ,&reqResLen
                                                                    ,ErrorCode);
      break;
# endif
# if (DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_DYNLEN_ENABLED == STD_ON) || \
     (DCM_RIDMGR_OPTYPE_REQ_RES_DYNLEN_ENABLED == STD_ON)
#  if (DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_DYNLEN_ENABLED == STD_ON)
    case DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_DYNLEN:
#  endif
#  if (DCM_RIDMGR_OPTYPE_REQ_RES_DYNLEN_ENABLED == STD_ON)
    case DCM_RIDMGR_OPTYPE_REQ_RES_DYNLEN:
#  endif
    lStdResult = ((Dcm_RidMgrOpFuncReqAnyLenResDynLenType)pRidOpInfo->OpFunc)(Dcm_DiagGetReqData(pMsgContext)                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                             ,opStatus
                                                                             ,Dcm_DiagGetResData(pMsgContext)                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                             ,&reqResLen
                                                                             ,ErrorCode);
      break;
# endif

    default:
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }

    if(lStdResult == DCM_E_OK) /* consider only final results */
    {
      Dcm_DiagProvideResData(pMsgContext, Dcm_CfgRidMgrOpInfoResMinLength(pRepContext->RidOpInfoIdx));                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
# if (DCM_RIDMGR_DYN_RES_LEN_ENABLED == STD_ON)
      if(pRidOpInfo->ResMinLength != pRidOpInfo->ResMaxLength)
      {
        Dcm_DiagProvideResData(pMsgContext, reqResLen); /* register response length of the last signal  */                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
# endif
    }

    /* Provide routine Info byte (if enabled) */
# if (DCM_RIDMGR_SUPPORT_ROUTINEINFOBYTE_ENABLED == STD_ON)
    /* If final result is ok and routine info byte value is valid, copy routine info byte to reserved place in response buffer */
    if ((lStdResult == DCM_E_OK)
      && (lRoutineInfoByte != DCM_CFGRIDMGR_INVALID_ROUTINEINFOBYTE))
    {
      Dcm_DiagSetResDataAsU8At(pMsgContext, pRepContext->RIBResIdx, (uint8)lRoutineInfoByte);
    }
# endif
  }

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
    &&(lStdResult != DCM_E_PENDING)
    &&(lStdResult != DCM_E_NOT_OK)
    &&(lStdResult != DCM_E_FORCE_RCRRP) )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  Dcm_DiagHandleApplNrc(lStdResult, ErrorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
/**********************************************************************************************************************
 *  Dcm_RidMgrGetOpInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrGetOpInfo(Dcm_CfgRidMgrInfoHandleOptType ridInfoIdx
                                                                   ,Dcm_RidMgrOpType ridOp
                                                                   ,Dcm_CfgRidMgrOpHandlePtrType pRidOpInfoIdx)
{
  Std_ReturnType lResult = DCM_E_NOT_OK;

  if ((Dcm_CfgRidMgrRidInfoOperations(ridInfoIdx) & ridOp) != 0)
  {
    Dcm_CfgRidMgrOpHandleOptType opHandle = Dcm_CfgRidMgrRidInfoOpBaseIdx(ridInfoIdx);
    do
    {
      ridOp>>= 1;/* pre-decrement! */
      if ((Dcm_CfgRidMgrRidInfoOperations(ridInfoIdx) & ridOp) != 0)
      {
        ++opHandle;
      }
    }
    while(ridOp != 0);
    *pRidOpInfoIdx = opHandle;
    lResult = DCM_E_OK;

  }
  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUpFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUpFilter(uint16 rid
                                                                         ,Dcm_CfgRidMgrInfoHandleOptType ridInfoIdx)
{
  Std_ReturnType lStdReturn = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(rid);                                                                                                                       /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ridInfoIdx);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
# if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
  if (Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgRidMgrRidInfoExecCondRef(ridInfoIdx)) == FALSE)
  {
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  /* check session state */
  if (!Dcm_StateIsSupportedInSession(Dcm_StateGetPreconditionStates(Dcm_CfgRidMgrRidInfoExecCondRef(ridInfoIdx))))
  {
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  {
# if (DCM_SVC_31_OBD_CALIBRATION_ENABLED == STD_ON) && (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
    if( (rid >= (uint16)0xE000u)
      &&(rid <= (uint16)0xE1FFu) )
    {
      if(Dcm_ObdIdMgrIsIdEnabled(Dcm_UtiGetLoByte(rid), &Dcm_CfgSvc31SupportedIdMask[Dcm_CfgSvc31SupportedIdMaskOffset[Dcm_UtiGetHiByte(rid)-(uint8)0xE0u]]) == FALSE)
      {
        lStdReturn = DCM_E_NOT_OK;
      }/* else - an enabled (WWH-)OBD RID */
    }/* else - a non (WWH-)OBD RID */
# endif
  }
  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUp(Dcm_OpStatusType opStatus
                                                                   ,uint16 rid
                                                                   ,Dcm_CfgRidMgrInfoHandlePtrType pRidInfoIdx)
{
  Std_ReturnType lStdReturn;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdReturn = DCM_E_OK;

# if (DCM_RIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
  if(opStatus == DCM_INITIAL)
# endif
  {
    sint16_least  lResult;

    lResult = Dcm_UtiLookUpUint16(Dcm_CfgRidMgrRidLookUpTable, rid);
    if (lResult >= 0)
    {
      *pRidInfoIdx = (Dcm_CfgRidMgrInfoHandleOptType)lResult;
    }
    else
    {
      lStdReturn = DCM_E_NOT_OK;
    }
  }

# if (DCM_RIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
  if(lStdReturn == DCM_E_OK)
  {
    /* Process DID enabled filter */
    lStdReturn = Dcm_FilterRidLookUpResult(opStatus, rid);

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
    if(opStatus == DCM_CANCEL)
    {
      /* Terminate immediately any further processing */
      lStdReturn = DCM_E_NOT_OK;
    }
#  endif

#  if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    if( (lStdReturn != DCM_E_OK)
      &&(lStdReturn != DCM_E_PENDING)
      &&(lStdReturn != DCM_E_NOT_OK) )
    {
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      lStdReturn = DCM_E_NOT_OK;
    }
#  endif
  }/* else - DCM_E_NOT_OK */
# endif

  if(lStdReturn == DCM_E_OK)
  {
    lStdReturn = Dcm_RidMgrRidLookUpFilter(rid, *pRidInfoIdx);
  }/* else - DCM_E_NOT_OK, DCM_E_PENDING */
  return lStdReturn;
}
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrSetNextStep()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ObdDtcMgrSetNextStep(Dcm_RepeaterProgressType NextStep
                                                              ,Dcm_ObdDtcManagerContextPtrType pRepContext)
{
  pRepContext->DcmObdDtcManagerProgress = NextStep;
}

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrGetNextStep()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RepeaterProgressType, DCM_CODE) Dcm_ObdDtcMgrGetNextStep(
                                                                          Dcm_ObdDtcManagerContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  return pRepContext->DcmObdDtcManagerProgress;
}

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrDemGetNumFltrdDtc(Dcm_OpStatusType opStatus
                                                                          ,Dcm_MsgContextPtrType pMsgContext                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                          ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                          ,Dcm_ObdDtcManagerContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetNumberOfFilteredDTCType demResult;
  uint16 lNumDtc;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEM_API_430_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(GetNumberOfFilteredDTC)(pRepContext->DemClientId
                                                ,&lNumDtc);
# else
  demResult = Dcm_DemAPI(GetNumberOfFilteredDTC)(&lNumDtc);
# endif

  switch(demResult)
  {
  case DCM_DEM_RET_NUMBER_OK:
    if(lNumDtc <= 0xFFu)
    {
      Dcm_DiagProvideResDataAsU8(pMsgContext, Dcm_UtiGetLoByte(lNumDtc));                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
      Dcm_PagedBufferStart((Dcm_MsgLenType)(lNumDtc * 2));
      lStdResult = DCM_E_STOP_REPEATER;
# else
      Dcm_ObdDtcMgrSetNextStep(DCM_OBDDTCMGR_PROGRESS_COPYLINEARDATA, pRepContext);
      lStdResult = DCM_E_LOOP;
# endif
    }
    else
    {
      /* else - NRC 0x22 */
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    break;
  case DCM_DEM_RET_NUMBER_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:/* DEM_NUMBER_FAILED or unknown */
    *ErrorCode  = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_DemApiNrcMapGetNumberOfFilteredDTC);                                                 /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCopyLinearData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCopyLinearData(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_ObdDtcManagerContextPtrType pRepContext)
{
  Std_ReturnType           lStdResult;
  Dcm_DiagDataContextType  lDataContext;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagInitDataContext(&lDataContext, Dcm_DiagGetResData(pMsgContext), pMsgContext->resMaxDataLen);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

  lStdResult = Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(&lDataContext, ErrorCode, pRepContext);

  /* Commit copied data */
  Dcm_DiagProvideResData(pMsgContext, lDataContext.Usage);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

  if (lStdResult == DCM_E_BUFFERTOOLOW)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;/* for OBD send (suppress with) NRC 0x31 since 0x14 (ResponseTooLong is not defined!) */                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else if ((lStdResult == DCM_E_NOT_OK)  /* ErrorCode already set */
        || (lStdResult == DCM_E_PENDING))
  {
  }
  else
  {
    lStdResult = DCM_E_OK;
  }

  return lStdResult;
}
# endif
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_DiagSetNewReqBaseToCurProgress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewReqBaseToCurProgress(Dcm_MsgContextPtrType pMsgContext)
{
#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pMsgContext->reqIndex >= pMsgContext->reqBufSize)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_DIAGSETNEWREQBASETOCURPROGRESS);
  }
  else
#endif
  {
    pMsgContext->reqBufSize -= pMsgContext->reqIndex;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_UtiNextItemByPtr(pMsgContext->reqData, pMsgContext->reqIndex);                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->reqIndex = 0;                                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagSetQueuedTranspObj()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetQueuedTranspObj(Dcm_NetTransportObjectPtrType pTranspObj)                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
#if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.QueuedSet.TObjHdl = pTranspObj->Handle;
# if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
  Dcm_UtiBitOpSet(Dcm_TskTaskEvMemType
                 ,Dcm_InstanceContext.Diag.QueuedSet.QueuedTObjects
                 ,Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));                                                                 /* PRQA S 3453, 3458 */ /* MD_MSR_19.7, MD_MSR_19.4 */
# endif
#else
  Dcm_DiagSetTranspObj(pTranspObj);
#endif
}

/**********************************************************************************************************************
 *  Dcm_DiagSetNewResBaseToCurProgress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewResBaseToCurProgress(Dcm_MsgContextPtrType pMsgContext)
{
#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pMsgContext->resIndex >= pMsgContext->resBufSize)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_DIAGSETNEWRESBASETOCURPROGRESS);
  }
  else
#endif
  {
    pMsgContext->resBufSize -= pMsgContext->resIndex;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resMaxDataLen = pMsgContext->resBufSize;                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resProtHeadLen += pMsgContext->resDataLen;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resDataLen = 0;                                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_UtiNextItemByPtr(pMsgContext->resData, pMsgContext->resIndex);                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resIndex = 0;                                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessorFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcConfirmationFuncType, DCM_CODE) Dcm_DiagGetPostProcessorFunc(uint8 index)
{
  Dcm_DiagSvcConfirmationFuncType lResult;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_CFGDIAGSVCPOSTPROCESSORS_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_DIAGGETPOSTPROCESSORFUNC);
    lResult = Dcm_CfgDiagSvcPostProcessors[0];
  }
  else
#endif
  {
    lResult = Dcm_CfgDiagSvcPostProcessors[index];
  }

  return lResult;
}

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetUpdateFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcUpdateFuncType, DCM_CODE) Dcm_DiagGetUpdateFunc(uint8 index)
{
  Dcm_DiagSvcUpdateFuncType lResult;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_CFGDIAGSVCUPDATERS_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_DIAGGETUPDATEFUNC);
    lResult = Dcm_CfgDiagSvcUpdaters[0];
  }
  else
# endif
  {
    lResult = Dcm_CfgDiagSvcUpdaters[index];
  }

  return lResult;
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetCancelFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcCancelFuncType, DCM_CODE) Dcm_DiagGetCancelFunc(uint8 index)
{
  Dcm_DiagSvcCancelFuncType lResult;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_CFGDIAGSVCCANCELLERS_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_DIAGGETCANCELFUNC);
    lResult = Dcm_CfgDiagSvcCancellers[0];
  }
  else
# endif
  {
    lResult = Dcm_CfgDiagSvcCancellers[index];
  }

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInit(void)
{
  Dcm_InstanceContext.Diag.State           = DCM_DIAG_STATE_IDLE;
#if (DCM_DIAG_PROCESSOR_FLAGS_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.QueuedSet.Flags = DCM_DIAG_QUEUE_FLAG_NONE;
#endif
#if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.QueuedSet.QueuedTObjects = 0;
#endif

#if (DCM_DIAG_SVC_INITIALIZERS_ENABLED == STD_ON)
  /* Initialize all processors */
  {
    uint8_least lIter;

    for(lIter = 0u; Dcm_CfgDiagSvcInitializers[lIter] != NULL_PTR; ++lIter)
    {
      Dcm_CfgDiagSvcInitializers[lIter]();                                                                                                           /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */
    }
  }
#endif

  Dcm_DiagSetP2Timings(0, 0);

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
  Dcm_SingletonContext.Network.RxAllowed = FALSE;
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_RECOVERY, DCM_TSK_EV_DIAG_RECOVERY_GETSTATE);
#endif

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
  /* Delegate to the first task activation */
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_FBLRES, DCM_TSK_EV_DIAG_FBLRES_SEND);
#endif
}

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagPutStartUpFblResBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagPutStartUpFblResBuffer(uint8 index, Dcm_MsgItemType value)
{
# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(index >= DCM_DIAG_START_UP_FBL_RES_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_DIAGPUTSTARTUPFBLRESBUFFER);
  }
  else
# endif
  {
    Dcm_InstanceContext.Diag.StartUpFbl.ResBuffer[index] = value;                                                                                    /* SBSW_DCM_POINTER_WRITE_START_UP_FBL_RES_BUFFER */
  }
}
#endif

#if (DCM_DIAG_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagExecConfirmationFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagExecConfirmationFunc(Dcm_CfgDiagNotificationInfoPtrType notifList                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_ConfirmationStatusType confStatus)
{
  uint16_least lIter;

  for(lIter = 0u; notifList[lIter].ConfFunc != NULL_PTR; ++lIter)
  {
    (void)notifList[lIter].ConfFunc(Dcm_InstanceContext.Diag.PostProcessorContext.Sid
                                   ,Dcm_InstanceContext.Diag.PostProcessorContext.ReqType
                                   ,Dcm_InstanceContext.Diag.PostProcessorContext.SrcAddr
                                   ,confStatus);                                                                                                     /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_ConfirmationStatusType, DCM_CODE) Dcm_DiagGetPostProcessResult(void)
{
  Dcm_ConfirmationStatusType confStatus  = DCM_DIAG_RES_ANY_OK;

  if(Dcm_InstanceContext.Diag.TxStatus != DCM_E_OK)
  {
    /* Set Tx error flag */
    confStatus |= DCM_DIAG_RES_ANY_NOT_OK;
  }

  if(Dcm_InstanceContext.Diag.ErrorRegister != DCM_E_POSITIVERESPONSE)
  {
    /* Set neg response flag */
    confStatus |= DCM_DIAG_RES_NEG_ANY;
  }
  return confStatus;
}

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoverySignature()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_DiagGetRecoverySignature(void)
{
  uint32 lResult;

  lResult = Dcm_PbCfgNetNumComMChannels;

# if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
  lResult |= Dcm_UtiMake32Bit(0u, 0u, Dcm_PbCfgNetNumAllComMChannels, 0u);
# endif

# if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
  lResult |= Dcm_UtiMake32Bit(Dcm_UtiGetHiNibble(Dcm_PbCfgNetNumProtocols) /* Since at most 32 protocols are allowed the high nibble never exceeds 1 bit */
                             ,Dcm_UtiGetLoNibble(Dcm_PbCfgNetNumProtocols)
                             ,0u
                             ,0u);                                                                                                                   /*lint !e572 if a constant fits into uint8, then lint threats it as such and ignores any casts */
# endif

  lResult |= Dcm_UtiGetBitFromIndex(uint32, 21u);

# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 22u);
# endif

# if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 23u);
# endif

# if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 24u);
# endif

# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 25u);
# endif

  lResult |= Dcm_UtiMake32Bit(0x08, 0x00, 0u, 0u);

  lResult |= Dcm_UtiMake32Bit(0xA0, 0u, 0u, 0u);

  return lResult;
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagProvideRecoveryStates()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagProvideRecoveryStates(
                                                    P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo)
{
  /* Retrieve ComM channel states */
  Dcm_CfgNetNetIdRefOptType lNetHandleIter;
  for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
  {
    RecoveryInfo->ComMChannelState[lNetHandleIter] = (boolean)(Dcm_PbRamNetComMContext[lNetHandleIter].RegisteredNetworks != 0u);
  }

  /* Retrieve session state */
  RecoveryInfo->SessionLevel = Dcm_UtiGetBitPosition(Dcm_StateGetSession());

  /* Retrieve session connection */
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  RecoveryInfo->SessionConnection = Dcm_NetGetSessionConnection();
# endif

  /* Retrieve active protocol */
# if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
  RecoveryInfo->ActiveProtocol = Dcm_NetGetProtIdOfActiveProtocol();
# endif

  /* Retrieve security state */
# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  RecoveryInfo->SecurityLevel = Dcm_UtiGetBitPosition(Dcm_StateGetSecurity());
# endif

  /* Retrieve DTC settings state */
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
#  if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
  RecoveryInfo->ControlDTCSettingDTCGroup = Dcm_ModeGetControlDtcSettingGroup();
#  endif
  RecoveryInfo->ControlDTCSettingDisabled = (boolean)(Dcm_ModeGetControlDtcSettingMode() == RTE_MODE_DcmControlDtcSetting_DISABLEDTCSETTING);
# endif

  /* Retrieve communication control state */
# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  {
    uint8_least lChannelIter;
    for(lChannelIter = 0; lChannelIter < Dcm_PbCfgNetNumAllComMChannels; ++lChannelIter)
    {
      RecoveryInfo->CommControlState[lChannelIter] = Dcm_ModeGetCommControlState(lChannelIter);
    }
  }
# endif

  RecoveryInfo->Signature = Dcm_DiagGetRecoverySignature();
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagProcessRecoveryInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagProcessRecoveryInfo(
                                                P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo
                                               ,Dcm_OpStatusType opStatus)
{
  Std_ReturnType lStdResult = DCM_E_OK;

  if (opStatus == DCM_INITIAL)
  {
    /* If a non-default session was active: */
    if(RecoveryInfo->SessionLevel != 0)
    {
      /* Activate ComM channels */
      Dcm_CfgNetNetIdRefOptType lNetHandleIter;
      for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
      {
        if(RecoveryInfo->ComMChannelState[lNetHandleIter] == TRUE)
        {
          Dcm_NetArEnvComMActiveDiag(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandleIter]]);
        }
      }

      /* Recover session state */
      Dcm_StateSetSession(RecoveryInfo->SessionLevel);

      /* Recover active protocol */
# if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
      Dcm_SingletonContext.Network.ActiveProtocol = RecoveryInfo->ActiveProtocol;
# endif

      /* Update P2 timings at once */
      Dcm_DiagSetP2Timings(RecoveryInfo->SessionLevel, Dcm_NetGetProtIdOfActiveProtocol());

      /* Recover session connection */
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
      Dcm_NetSetSessionConnection(RecoveryInfo->SessionConnection);
# endif

      Dcm_TmrStartTimer(DCM_TMR_ID_S3, DCM_DIAG_TIME_S3);
    }

# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
    /* If any security level was unlocked: */
    if(RecoveryInfo->SecurityLevel != 0)
    {
      /* Recover security state */
      Dcm_StateSetSecurity(RecoveryInfo->SecurityLevel);
    }
# endif
  }

# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  /* If DTC settings were disabled: */
  if(RecoveryInfo->ControlDTCSettingDisabled == TRUE)
  {
    /* Recover DTC updating state */
    lStdResult = Dcm_Svc85DisableDtcSetting(
#  if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
                                            RecoveryInfo->ControlDTCSettingDTCGroup
#  else
                                            DEM_DTC_GROUP_ALL_DTCS
#  endif
                                           ,Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol())
                                           );

  }
# endif

# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
#  if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  /* If no DTC settings update was necessary or it succeeded */
  if (lStdResult == DCM_E_OK)
#  endif
  /* Recover communication control states */
  {
    uint8_least lChannelIter;
    for(lChannelIter = 0; lChannelIter < Dcm_PbCfgNetNumAllComMChannels; ++lChannelIter)
    {
      if(RecoveryInfo->CommControlState[lChannelIter] != DCM_ENABLE_RX_TX_NORM_NM)
      {
        Dcm_ModeSwitchCommControl(lChannelIter, RecoveryInfo->CommControlState[lChannelIter]);
      }
    }
  }
# endif
  return lStdResult;
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagSafeProcessRecoveryInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSafeProcessRecoveryInfo(
                                                 P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo
                                                ,Dcm_OpStatusType opStatus)
{
  uint8  lErrorId = DCM_E_NO_ERROR;
  Std_ReturnType lStdResult = DCM_E_OK;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(RecoveryInfo->Signature != Dcm_DiagGetRecoverySignature())
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(RecoveryInfo->SessionLevel >= DCM_STATE_NUM_SESSION)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
  if( (RecoveryInfo->SessionLevel != 0u) /* non-default session */
    &&(RecoveryInfo->ActiveProtocol >= DCM_NET_INVALID_PROTID) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
#  if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  if( (RecoveryInfo->SessionLevel != 0u) /* non-default session */
    &&(RecoveryInfo->SessionConnection >= DCM_NET_INVALID_CONNID) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
#  if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON) && \
      (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  if( (RecoveryInfo->SessionLevel != 0u) /* non-default session */
    &&(Dcm_NetGetProtIdOfConnection(RecoveryInfo->SessionConnection) != RecoveryInfo->ActiveProtocol) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
#  if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(RecoveryInfo->SecurityLevel >= DCM_STATE_NUM_SECURITY)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
# endif
  {
    lStdResult = Dcm_DiagProcessRecoveryInfo(RecoveryInfo, opStatus);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_GETRECOVERYSTATES, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcCancelOpenJobs()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcCancelOpenJobs(void)
{
  /* #10 If any diagnostic job still open (PagedBuffer transfers are not part of them), call the job handle one last time with DCM_CANCEL signal */
  if(Dcm_InstanceContext.Diag.State == DCM_DIAG_STATE_PROCESS)
  {
    Dcm_NegativeResponseCodeType lNrc;
    Dcm_InstanceContext.Repeater.Contexts.OpStatus = DCM_CANCEL;/* Override any other opStatus values up to now */
    (void)Dcm_RepeaterExecute(&lNrc);/* signal cancellation */                                                                                       /* SBSW_DCM_POINTER_FORWARD_STACK */
    Dcm_SetNegResponse(lNrc); /* register negative result */
  }

  /* #20 If any diagnostic job still open (including PagedBuffer transfers) or already on transmission: */
  if(((DCM_DIAG_STATE_PROCESS | DCM_DIAG_STATE_ON_TX) & Dcm_InstanceContext.Diag.State) != 0) /* any open diagnostic job? (optimize interrupt lock times) */
  {
    /* Immediately cancel any ongoing transmission (RCR-RP, final response (RoE or external)) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    if(((DCM_DIAG_STATE_PROCESS | DCM_DIAG_STATE_ON_TX) & Dcm_InstanceContext.Diag.State) != 0) /* STILL any open diagnostic job -> diagnostic transport object is still in use -> try cancel it */ /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
    {
      Dcm_NetTransportObjectPtrType pTranspObj;

      pTranspObj = Dcm_DiagGetTranspObj();

      /* #30 If any USDT response transmission is still ongoing (incl. RCR-RPs): */
      if(pTranspObj->State == DCM_NET_TOBJ_STATE_ONTX)
      {
        pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_CANCELED;/* isolate this connection */                                                                /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        /* Short cut to speed up the service processing finalization - RCR-RP responses will just end with the cancellation below */
        Dcm_DiagTxFinalization(pTranspObj, DCM_E_NOT_OK);                                                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

        /* Try cancel any ongoing response. The return value does not matter:
          * OK -> there will be a confirmation for this cancellation
          * N_OK -> request rejected, but there will be a confirmation due to the ongoing transmission */
        (void)Dcm_NetArEnvPduRCancelTransmit(Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnId].TxPduIdMain);
        /* Any response (final, RCR-RP, etc) will just end with releasing the connection assigned to the tObject! No confirmation post-processing will be performed! */
      }
      /* #40 Otherwise, if there is no USDT response initiated yet, just notify the diagnostic kernel for the transmission finalization to accomplish the diagnostic job cycle */
      else if (pTranspObj->State == DCM_NET_TOBJ_STATE_READY)                                                                                        /* COV_DCM_RTM_UNREACHABLE TX */
      {
        /* no transmission yet started -> just loop back the diagnostic confirmation immediately. Note: no other Tx-confirmation type is expected here */
        Dcm_DiagTxFinalization(pTranspObj, DCM_E_NOT_OK);                                                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      }
      else
      {
        /* #50 Otherwise, unexpected transport object state reached (inconsistent in the context of diagnostic kernel state, showing a job is still in progress) */
        Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                 /* COV_DCM_RTM_DEV_DEBUG XF */
      }
    }
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
  /* #55 Otherwise, diagnostic kernel is in "post processing" or "idle" state and they are to be handled in a normal way
         Note: This case can be reached since the prioritization just fires a cancellation event, disregarding any internal states of the diagnostic kernel */
}                                                                                                                                                    /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcReviveKilledTasks()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcReviveKilledTasks(void)
{
  /* All cancellation activities are done now - revive all killed tasks to allow normal processing of the newly received diagnostic job (the one caused the interruption) */
  if((DCM_TSK_EV_DIAG_WORK_KILL_JOBS & Dcm_TskGetEvent(DCM_TSK_ID_DIAG_WORK)) == 0)/* Look ahead: Any nested kill job received? If so, no task revival! */ /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
  {
# if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
    Dcm_TskTaskEvOptType queuedTObjBitSet = 0; /* nothing to clean (for now) */
# endif
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    if((DCM_TSK_EV_DIAG_WORK_KILL_JOBS & Dcm_TskGetEvent(DCM_TSK_ID_DIAG_WORK)) == 0)/* STILL no nested kill job received? */                        /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
    {
      Dcm_TskReviveAllTasks();/* from now on enable tasks for working */
# if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
      queuedTObjBitSet = Dcm_InstanceContext.Diag.QueuedSet.QueuedTObjects;
      /* Clear all except the last queued one  */
      Dcm_UtiBitOpClr(Dcm_TskTaskEvOptType, queuedTObjBitSet, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, Dcm_DiagGetQueuedTranspObj()->Handle));   /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
      /* Remove all processed transport objects from the queue (the last queued one will be removed from the queue once transfered to the active tObject or canceled by higher prio request here again) */
      Dcm_UtiBitOpClr(Dcm_TskTaskEvMemType, Dcm_InstanceContext.Diag.QueuedSet.QueuedTObjects, queuedTObjBitSet);                                    /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
# endif
    }
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
# if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
    if(queuedTObjBitSet > 0)
    {
      /* Some connections to clean up (in background)? */
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_GARB_COL, (Dcm_TskTaskEvMemType)queuedTObjBitSet);
    }
# endif                                                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
}
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerDoCancelProcessing(Dcm_TskTaskEvOptType ev
                                                                                      ,Dcm_TskTaskEvPtrType pPostEv)                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagWorkerDoCancelProcCancelOpenJobs(); /* Cancel open diagnostic jobs */

  /* Sync with TxEnd events set above OR Tx confirmation. No ISR lock since:
   * - No Tx confirmation can occur from now on
   * - If above Tx confirmation executed -> no other changes of the state are possible!
   * - If there was already a Tx Confirmation (above code not executed) -> the task will just be re-triggered
   */
  /* If the Dcm_DiagTaskWorker() has (by finished transmission or through the above cancellation activity) already received a post-processing event: */
  if((DCM_TSK_EV_DIAG_WORK_TX_END_FINAL & Dcm_TskGetEvent(DCM_TSK_ID_DIAG_WORK)) != 0)
  {
    Dcm_TskClrEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL);/* clear any potentially globally set Tx-end-response (from the above Tx cancellation code) */
    Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL);/* set/transfer the Tx end event */
  }
  /* Otherwise, either no Tx-end event OR nothing to do OR it is already set in the local "ev" -> will be post-processed in next task stages */

  Dcm_DiagWorkerDoCancelProcReviveKilledTasks(); /* Revive killed tasks */

  return lResultEv;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoPostProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoPostProcessing(void)
{
  Dcm_ConfirmationStatusType   confStatus;
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_NegativeResponseCodeType lNrc;
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  /* reset any pending PB processing */
  if(Dcm_PagedBufferCancel(&lNrc) == DCM_E_NOT_OK)                                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    Dcm_SetNegResponse(lNrc);/* Set NRC now to affect the post-processor confirmation status */
  }
#endif

  confStatus = Dcm_DiagGetPostProcessResult();
  /* First process any diagnostic service post-handler (e.g. to perform any state transitions at this stage): */
  if(((DCM_DIAG_APPL_NOTIFICATION_SVC_HDLR | DCM_DIAG_APPL_NOTIFICATION_SID_FOUND) & Dcm_InstanceContext.Diag.ApplNotification) != 0)
  {
    Dcm_DiagSvcConfirmationFuncType lPostProcessorFunc;
    lPostProcessorFunc = Dcm_DiagGetPostProcessorFunc(Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].ConfFuncRef);

    lPostProcessorFunc(confStatus);/* execute any internal service processor post-handlers */                                                        /* SBSW_DCM_CALL_FUNCPTR_SVCPOSTPROCESSORS */

    if((DCM_DIAG_APPL_NOTIFICATION_SVC_HDLR & Dcm_InstanceContext.Diag.ApplNotification) != 0)
    {
      Dcm_Confirmation(0, Dcm_InstanceContext.Diag.MsgContext.rxPduId, confStatus);/* notify the application about transmission end (of any service) */
    }
  }
  /* At next process any system supplier and OEM notification (e.g. to perform any additional state transitions at this stage): */
#if(DCM_DIAG_SYS_NOTIFICATION_ENABLED == STD_ON)
  if((DCM_DIAG_APPL_NOTIFICATION_SYS & Dcm_InstanceContext.Diag.ApplNotification) != 0)
  {
    Dcm_DiagExecConfirmationFunc(Dcm_CfgDiagSysNotificationInfo, confStatus);                                                                        /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }
#endif
#if(DCM_DIAG_OEM_NOTIFICATION_ENABLED == STD_ON)
  if((DCM_DIAG_APPL_NOTIFICATION_OEM & Dcm_InstanceContext.Diag.ApplNotification) != 0)
  {
    Dcm_DiagExecConfirmationFunc(Dcm_CfgDiagOemNotificationInfo, confStatus);                                                                        /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }
#endif
  /* At next process any internal service processors background task notifications: */
#if(DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Diag.IsInternRequest == TRUE)/* manage ComM states only on processed requests from external clients */
  {
# if (DCM_SVC_86_TX_END_IND_ENABLED == STD_ON)                                                                                                       /* COV_DCM_UNSUPPORTED XF */
    Dcm_ExtSvc86TxEnd(confStatus);
# endif
  }
  else
#endif
  {
    Dcm_NetUnRegisterComMActivity(Dcm_NetGetConnIdOfRxPduId(Dcm_InstanceContext.Diag.MsgContext.rxPduId));/* process here to take a potentially new session change into account */
  }
  Dcm_InstanceContext.Diag.State = DCM_DIAG_STATE_IDLE;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_DiagWorkerSetDefSessionExtern()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerSetDefSessionExtern(Dcm_TskTaskEvOptType ev
                                                                                       ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  /* If diagnostic kernel is still busy with a diagnostic job, retry next task activation if there is no other such request yet */
  if(Dcm_InstanceContext.Diag.State != DCM_DIAG_STATE_IDLE)
  {
    if(!Dcm_TskIsLocalEventSet(lResultEv, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF))                                                                         /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY XX */
    {
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF); /* retry later again */                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
  else
  {
    /* Redirect the external request for resetting the session to the internal request handler (same activity) */
    Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);

    /* If non-default session is active the current protocol id is unequal to DCM_NET_INVALID_PROTID */
    if(!Dcm_StateIsDefaultSessionActive())
    {
      Dcm_DiagSetP2Timings(0, Dcm_NetGetProtIdOfActiveProtocol());
    }/* else - P2 timings of default session already set */

#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
    Dcm_SingletonContext.Network.RxAllowed = TRUE;
#endif
  }

  return lResultEv;
}

/**********************************************************************************************************************
 *  Dcm_DiagSwitchProcessingContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSwitchProcessingContext(void)
{
  Std_ReturnType lStdResult = DCM_E_OK;

#if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON) || \
    (DCM_DIAG_GARB_COL_ENABLED == STD_ON) || \
    (DCM_DIAG_SYNCH_FLAGS_ENABLED == STD_ON)
  Dcm_SplitTaskEnterCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
# if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
  if((DCM_TSK_EV_DIAG_WORK_KILL_JOBS & Dcm_TskGetEvent(DCM_TSK_ID_DIAG_WORK)) != 0)/* STILL no (nested) kill job received? */
  {
    lStdResult = DCM_E_NOT_OK; /* skip any further processing in this Dcm_DiagTaskWorker() activation (i.e. return immediately) */
  }
  else
# endif
  {
# if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON) || \
     (DCM_DIAG_GARB_COL_ENABLED ==STD_ON)
    Dcm_NetTransportObjectPtrType pQueuedTObj;
    pQueuedTObj = Dcm_DiagGetQueuedTranspObj();
# endif

# if (DCM_DIAG_SYNCH_FLAGS_ENABLED == STD_ON)                                                                                                        /* COV_DCM_SUPPORT_ALWAYS TX */
    Dcm_UtiBitOpClr(Dcm_DiagProcessorFlagType, Dcm_InstanceContext.Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_WAITING);                            /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    Dcm_UtiBitOpSet(Dcm_DiagProcessorFlagType, Dcm_InstanceContext.Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_ACTIVE);
# endif

# if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON)
    Dcm_DiagSetTranspObj(pQueuedTObj); /* switch work contexts! RCR-RP will be sent also from this one (QueuedCtxt) */
# endif
# if (DCM_DIAG_GARB_COL_ENABLED ==STD_ON)
    Dcm_UtiBitOpClr(Dcm_TskTaskEvMemType, Dcm_InstanceContext.Diag.QueuedSet.QueuedTObjects, (Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pQueuedTObj->Handle)));
# endif
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
#endif

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_DiagInitiateServiceProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInitiateServiceProcessing(Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_NetTransportObjectPtrType pTranspObj;
  Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

  /* Now take the active transport object */
  pTranspObj = Dcm_DiagGetTranspObj();

#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.IsInternRequest = (boolean)((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0);
#endif

  lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

  /* Compose message context (skip SID byte) */
  pMsgContext->reqData = &(lBufferInfo->BufferPtr[0]);                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resData = &(lBufferInfo->BufferPtr[0]);                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->reqDataLen = pTranspObj->RxLength;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resDataLen = 0u;                                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->reqBufSize = lBufferInfo->Size;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resBufSize = lBufferInfo->Size;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resMaxDataLen = lBufferInfo->Size;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resProtHeadLen = 0;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->reqIndex = 0u;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resIndex = 0u;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->rxPduId = pTranspObj->RxPduId;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->msgAddInfo.reqType  = (uint8)((Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE)?1u:0u);                                  /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->msgAddInfo.suppressPosResponse = 0;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Update diagnostic kernel context */
  Dcm_InstanceContext.Diag.ErrorRegister        = DCM_E_POSITIVERESPONSE;
  Dcm_InstanceContext.Diag.ApplNotification     = DCM_DIAG_APPL_NOTIFICATION_NONE;
  Dcm_InstanceContext.Diag.DoSuppressResponse   = FALSE;
  Dcm_InstanceContext.Diag.State                = DCM_DIAG_STATE_PROCESS;

  Dcm_PagedBufferInit();
}

/**********************************************************************************************************************
 *  Dcm_DiagHandleSuppressBit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagHandleSuppressBit(Dcm_NetTransportObjectPtrType pTranspObj                                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                               ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Check if the new service supports sub-function parameter */
  if((Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].Props & DCM_DIAG_SVC_CFG_PROP_HAS_SUBFUNC)  != 0)
  {
    uint8 reqSf = Dcm_DiagGetReqDataAsU8(pMsgContext);
    /* If so, deal with the SPRMIB: extract and store */
    if ((reqSf & 0x80u) != 0)
    {
      Dcm_DiagSetReqDataAsU8(pMsgContext, (reqSf & 0x7Fu));/* mask out the SPRMIB */                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_SplitTaskEnterCS();/* protect against hi-priority Dcm_DiagTaskRx/Tx */                                                                     /* PRQA S 3109 */ /* MD_MSR_14.3 */
      /*=================================*
        BEGIN CRITICAL SECTION
       *=================================*/
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
      /* On split task it could happen that RCR-RP is already on transmission */
      if((pTranspObj->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_ON_TX | DCM_NET_TOBJ_FLAG_RCRRP_SENT)) == 0)/* RCR-RP is NOT on transmission or was sent */
#endif
      {
        pMsgContext->msgAddInfo.suppressPosResponse = 1;                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      /*=================================*
        END CRITICAL SECTION
       *=================================*/
      Dcm_SplitTaskLeaveCS();                                                                                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
    }
    /* copy the sub-function byte once split Rx/Tx buffers are supported.
    pMsgContext->resData[0] = pMsgContext->reqData[0];
    */
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagValidateAndDispatchService()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagValidateAndDispatchService(
                                                                            Dcm_MsgContextPtrType           pMsgContext
                                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  Dcm_MsgItemType lSid;

  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &lSid);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_DiagProvideResDataAsU8(pMsgContext, lSid + 0x40u);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Skip SID data, since already processed */
  Dcm_DiagSetNewReqBaseToCurProgress(pMsgContext);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_DiagSetNewResBaseToCurProgress(pMsgContext);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

#if(DCM_DIAG_OEM_NOTIFICATION_ENABLED == STD_ON)
  /* Execute manufacturer specific environment checks */
  if(Dcm_DiagExecIndicationFunc(lSid, DCM_DIAG_APPL_NOTIFICATION_OEM, Dcm_CfgDiagOemNotificationInfo, ErrorCode) == DCM_E_OK)                        /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
#endif
  {
    sint16_least sidIter = Dcm_DiagLookUpFilter(Dcm_UtiLookUpUint8(Dcm_CfgDiagSvcIdLookUpTable, lSid)
                                               ,Dcm_CfgDiagSvcIdExecPrecondTable
                                               ,DCM_DIAG_CHK_LVL_SERVICE_ID
                                               ,ErrorCode);                                                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    /* Service found? */
    if(sidIter >= 0)
    {
      Dcm_NetTransportObjectPtrType pTranspObj;

      pTranspObj = Dcm_DiagGetTranspObj();
      Dcm_InstanceContext.Diag.SidIndex = (uint8)sidIter;
#if (DCM_DIAG_MULTI_SVC_TABLE_ENABLED == STD_ON)
      /* use protocol of the current working context! Otherwise a hi priority task (NetTaskRx) could interrupt this task and change the protocol! */
      if((Dcm_PbCfgDiagSvcId2ProtMap[Dcm_InstanceContext.Diag.SidIndex] & Dcm_UtiGetBitFromIndex(Dcm_CfgDiagSvc2ProtMapMemType, Dcm_NetGetProtIdOfTranspObj(pTranspObj))) == 0)
      {
        /* Unknown service requested */
        *ErrorCode = DCM_E_SERVICENOTSUPPORTED;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      else
#endif
      {
        if((Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].Props & DCM_DIAG_SVC_CFG_PROP_CALL_POST_HDLR_ALWAYS)  != 0)
        {
          /* mark application notification once the SID is identified! */
          Dcm_InstanceContext.Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_SID_FOUND;
        }

        /* Check SID pre-conditions */
        lStdResult = Dcm_StateCheck(Dcm_CfgDiagSvcIdExecPrecondTable[Dcm_InstanceContext.Diag.SidIndex]
                                   ,DCM_DIAG_CHK_LVL_SERVICE_ID
                                   ,ErrorCode);                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
        if(lStdResult == DCM_E_OK)
        {
#if(DCM_DIAG_SYS_NOTIFICATION_ENABLED == STD_ON)
          /* Execute supplier specific environment checks */
          lStdResult = Dcm_DiagExecIndicationFunc(lSid, DCM_DIAG_APPL_NOTIFICATION_SYS, Dcm_CfgDiagSysNotificationInfo, ErrorCode);                  /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
          if(lStdResult == DCM_E_OK)
#endif
          {
            /* Check for available minimum length */
            if(pMsgContext->reqDataLen >= Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].MinLength)
            {
              /* Handle SPRMIB */
              Dcm_DiagHandleSuppressBit(pTranspObj, pMsgContext);                                                                                    /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

              /* From now on, mark application calls for post-processing later */
              Dcm_InstanceContext.Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_SVC_HDLR; /* mark application notification at last here */
            }
            else
            {
              /* Minimum length is not reached  */
              *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
              lStdResult = DCM_E_NOT_OK;
            }
          } /* else - NRC already set - finalize processing */
        }/* else - NRC already set - finalize processing */
      }
    }/* else - already written "Unsupported service requested" */
  }/* else - NRC already set - finalize processing */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050, 6080 */ /* MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessNewRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerProcessNewRequest(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pPostEv)                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType         lResultEv = ev;
  Std_ReturnType               lStdResult;
  Dcm_NegativeResponseCodeType lNrc;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DiagSwitchProcessingContext();

  if(lStdResult == DCM_E_OK)
  {
    Dcm_DiagInitiateServiceProcessing(&(Dcm_InstanceContext.Diag.MsgContext));                                                                       /* SBSW_DCM_POINTER_INIT_MESSAGE_CONTEXT */

    /* Validate received diagnostic service on SID level */
    lStdResult = Dcm_DiagValidateAndDispatchService(&(Dcm_InstanceContext.Diag.MsgContext)
                                                   ,&lNrc);                                                                                          /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)
    {
      /* Set repeater per default to be no specific service */
      Dcm_RepeaterSetUser(DCM_REPEATER_USER_NONE);
      /* Execute Main-Handler (register it and it will be called immediately) */
      Dcm_RepeaterSetCallee(Dcm_InstanceContext.Diag.SidIndex);
      /* Let the service processor take over immediately */
      Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_WORK_REPEAT);
    }
    else
    {
      /* DCM_E_NOT_OK */
      Dcm_SetNegResponse(lNrc);
      Dcm_ProcessingDone();
    }
  }
  else
  {
    /* DCM_E_NOT_OK */
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, (Dcm_TskTaskEvMemType)ev);/* repeat all still unprocessed events at once together with the kill-event in order to get these always synchronized */
    lResultEv = 0; /* skip any further processing in this Dcm_DiagTaskWorker() activation (i.e. return immediately) */
  }
  return lResultEv;
}

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessRcrRpTxEnd()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerProcessRcrRpTxEnd(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pPostEv)                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType lResultEv = ev;
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj();

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if((DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL & pTranspObj->Flags) != 0)/* this is a RCR-RP response - check which kind */
  {
    Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL);                                           /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */ /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    Dcm_InstanceContext.Repeater.Contexts.OpStatus = (Dcm_OpStatusType)((Dcm_InstanceContext.Diag.TxStatus != DCM_E_OK)
                                                                        ?DCM_FORCE_RCRRP_NOT_OK
                                                                        :DCM_FORCE_RCRRP_OK);
    Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_WORK_REPEAT); /* notify immediately */
  }

  return lResultEv;
}

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON) && \
    (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerCancelOperation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerCancelOperation(Dcm_TskTaskEvOptType ev
                                                                                   ,Dcm_TskTaskEvPtrType pPostEv)                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType         lResultEv = ev;
  Dcm_NegativeResponseCodeType lNrc;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_PagedBufferCancel(&lNrc) == DCM_E_NOT_OK)                                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    /* Stop polling and wait for confirmation */
    Dcm_SetNegResponse(lNrc);
    Dcm_ProcessingDone();
  }

  return lResultEv;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoRepeat()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerDoRepeat(Dcm_TskTaskEvOptType ev
                                                                            ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;
  Std_ReturnType lStdResult;
  Dcm_NegativeResponseCodeType lNrc = DCM_E_POSITIVERESPONSE;
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj();

#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
  if(Dcm_TskIsLocalEventSet(lResultEv, DCM_TSK_EV_DIAG_WORK_CANCEL_OP))
  {
    Dcm_InstanceContext.Repeater.Contexts.OpStatus = DCM_CANCEL; /* override any other opStatus values up to now */
  }
#endif
  lStdResult = Dcm_RepeaterExecute(&lNrc);                                                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */

  switch(lStdResult)
  {
  case DCM_E_NOT_OK:
    Dcm_SetNegResponse(lNrc);
    /* fall through */
  case DCM_E_OK:                                                                                                                                     /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
  case DCM_E_PROCESSINGDONE:
    Dcm_ProcessingDone();
    break;
  case DCM_E_PENDING:
    Dcm_InstanceContext.Repeater.Contexts.OpStatus = DCM_PENDING;
#if (DCM_RUNTIME_USAGE_LIMIT_ENABLED == STD_ON)
    /* fall through - keep the last opStatus on "pending" forced by Dcm_RepeaterExecute code */
  case DCM_E_PENDING_LIMITER:                                                                                                                        /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
#endif
    /* Retry next cycle with the same parameter */
    Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_WORK_REPEAT);                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case DCM_E_FORCE_RCRRP:
    Dcm_UtiArEnvEnterCriticalSection();/* protect against Dcm_TpTxConfirmation or hi-priority Dcm_DiagTaskRx */                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL;                                                                                          /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    if((pTranspObj->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_ON_TX | DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ))  == 0)/* no RCR-RP already requested for transmission/ongoing? */ /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
    {
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_RX, DCM_TSK_EV_DIAG_RX_TMR_P2_TO);/* trigger a RCR-RP event timeout */
    }/* else - just wait for confirmation signal */

    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    break;
  default: /* DCM_E_STOP_REPEATER */
    Dcm_RepeaterSetCallee(DCM_DIAG_SERVICEINFO_REPEATEREND_IDX); /* any other return value leads to a dead end */
    break;
  }

  return lResultEv;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoGetProgCond()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoGetProgCond(Dcm_TskTaskEvOptType ev
                                                                                 ,Dcm_TskTaskEvPtrType pPostEv)                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* #10 Read the programming conditions of the pre-boot cycle */
  /* #20 If the ECU boot type is marked as a transition from the bootloader: */
  if(Dcm_GetProgConditions(&Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions) == DCM_WARM_START)                                                   /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  {
    sint16_least sesSfIter = -1;
# if (DCM_DIAG_NOTIF_BSWM_APPL_UPDATED_ENABLED == STD_ON)
    /* #30 If the application has been updated, notify the BswM (if enabled BswM notification) */
    if(Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ApplUpdated == TRUE)
    {
      BswM_Dcm_ApplicationUpdated();
    }
# endif

    /* #40 Check the diagnostic service identifier to be processed here: */

    /* #41 If the SID is for "DiagnosticSessionControl": */
    if(Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.Sid == 0x10u)
    {
      sesSfIter = Dcm_VarMgrLookUpFilter(Dcm_UtiLookUpUint8(Dcm_CfgSvc10SubFuncLookUpTable, Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.SubFuncId) /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
                                        ,Dcm_CfgSvc10SubFuncExecPrecondTable);                                                                       /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    }
    /* #50 Otherwise, send a response with any other SID and sub-function directly */

    if( (Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ResponseRequired == TRUE) /* a response is to be sent */
      ||(sesSfIter > 0) ) /* OR a non-default session is to be activated (need ComM active) */
    {
      Dcm_NetConnRefMemType connId;

      connId = Dcm_NetGetConnIdByTesterAddress(Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.TesterSourceAddr);

      if(connId < DCM_NET_INVALID_CONNID)
      {
        Dcm_NetTransportObjectPtrType pTranspObj; /* use a local copy to avoid collision with a RxIndication! */

        pTranspObj = Dcm_NetLockConnectionOrNull(connId);

        if(pTranspObj != NULL_PTR) /* try to lock the connection to this tester */
        {
          Dcm_InstanceContext.Diag.StartUpFbl.ConnId = pTranspObj->ConnId;
          Dcm_DiagSetTranspObj(pTranspObj);/* store working context */
          Dcm_TmrStartTimer(DCM_TMR_ID_FBLRES, Dcm_InstanceContext.Diag.P2Timings.P2Star); /* wait at most P2 star to finalize the FBL positive response */
          /* Start communication */
          Dcm_NetRegisterActiveConnection(pTranspObj);                                                                                               /* SBSW_DCM_POINTER_WRITE_RESERVEDTOBJ */
          Dcm_NetRegisterComMActivity(pTranspObj);                                                                                                   /* SBSW_DCM_POINTER_WRITE_RESERVEDTOBJ */
          Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_FBLRES_WAITTXCOMM);/* Try immediately */
        }
        /* else - there is a problem locking the channel (there is already a tester request) */
      }
      else
      {
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_PARAM);
      }
    }
    /* #60 In any case store any analysis results for later use (i.e. during the clear response required flag) */
    Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef = (sint8)sesSfIter;
    Dcm_InstanceContext.Diag.StartUpFbl.IsResponseRequired = Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ResponseRequired;
    /* #70 Signal the current task to start immediately the parallel job for clearing the response required flag, to avoid re-triggering of this sequence at next power on cycle */
    Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_FBLRES_RSTFLAGS);
  }

  return lResultEv;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoWaitTxComm()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoWaitTxComm(Dcm_TskTaskEvOptType ev
                                                                                ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj();

  /* If the corresponding ComM channel state is in "FullComMode": */
  if((DCM_NET_COMM_STATE_FLAG_TX_EN & Dcm_NetGetComStateByTranspObject(pTranspObj)) != 0)
  {
    Dcm_TmrStopTimer(DCM_TMR_ID_FBLRES);

    if(Dcm_InstanceContext.Diag.StartUpFbl.IsResponseRequired == FALSE) /* is final response required ? */
    {
      Dcm_DiagOnFblResTxFinished(pTranspObj, DCM_E_OK);/* Loop-back to the confirmation (successful "virtual" transmission) to clean up transportObject and ComM */ /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    }
    else
    {
      pTranspObj->State   = DCM_NET_TOBJ_STATE_PREPTX;                                                                                               /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_UNSOLICITED;                                                                                        /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->BuffInfo.SduDataPtr = &Dcm_InstanceContext.Diag.StartUpFbl.ResBuffer[0];                                                           /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->BuffInfo.SduLength  = 2u; /* only service and a sub-function to be sent */                                                         /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      /* Prepare final response to be sent */
      Dcm_DiagPutStartUpFblResBuffer(0, (uint8)(Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.Sid + 0x40u));
      Dcm_DiagPutStartUpFblResBuffer(1, Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.SubFuncId);

      if(Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.Sid == 0x10u)
      {
        if(Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef >= 0)
        {
          Dcm_DiagPutStartUpFblResBuffer(2, Dcm_UtiGetHiByte(Dcm_CfgSvc10SubFuncInfo[Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2));
          Dcm_DiagPutStartUpFblResBuffer(3, Dcm_UtiGetLoByte(Dcm_CfgSvc10SubFuncInfo[Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2));
          Dcm_DiagPutStartUpFblResBuffer(4, Dcm_UtiGetHiByte(Dcm_CfgSvc10SubFuncInfo[Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2Star));
          Dcm_DiagPutStartUpFblResBuffer(5, Dcm_UtiGetLoByte(Dcm_CfgSvc10SubFuncInfo[Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2Star));
          pTranspObj->BuffInfo.SduLength = 6u;                                                                                                       /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
        else
        {
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_PARAM);
        }
      }/* else - for SID 0x11 or other it is not critical to send any response - it will be up to the application to use the API! */

      Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND);
    }
  }
  else
  { /* Otherwise, check if still shall wait for ComM (deadline not yet expired): */
    if(Dcm_TskIsLocalEventSet(lResultEv, DCM_TSK_EV_DIAG_FBLRES_CANCEL))/* stop polling since time is up */
    {
      /* Loop-back to the confirmation (failed transmission) to clean up transportObject and ComM */
      Dcm_DiagOnFblResTxFinished(pTranspObj, DCM_E_NOT_OK);                                                                                          /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    }
    else
    {
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_FBLRES_WAITTXCOMM);/* Retry next time */                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  return lResultEv;
}
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoResetFlags()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoResetFlags(Dcm_TskTaskEvOptType ev
                                                                                ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;
  Std_ReturnType lStdResult;

  /* Reset all programming condition fields to their inactive states */
  Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ReprogrammingRequest = FALSE;
  Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ApplUpdated      = FALSE;
  Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ResponseRequired = FALSE;

  /* Write the updated pre-conditions */
  lStdResult = Dcm_SetProgConditions(&Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  switch(lStdResult)
  {
  case DCM_E_OK:
    break;
  case DCM_E_PENDING:
    Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_FBLRES_RSTFLAGS);/* Retry next time */                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lResultEv;
}
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoProcessTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoProcessTxConfirmation(Dcm_TskTaskEvOptType ev
                                                                                           ,Dcm_TskTaskEvPtrType pPostEv)                            /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* #10 If the final response was for a non-default session and was successfully sent: */
  if( (Dcm_InstanceContext.Diag.StartUpFbl.TxStatus == DCM_E_OK) /* only if successfully sent response ... */
    &&(Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef > 0) )/* ... of diagnostic session control for a non-default session ... */
  {
    /* #20 Enter critical section (Reason: Protect against Dcm_StartOfReception) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* #30 Register the diagnostic client for this session */
    Dcm_NetSetSessionConnection(Dcm_InstanceContext.Diag.StartUpFbl.ConnId);/* set tester for the session */
# if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
    /* #40 Register new active protocol */
    Dcm_SingletonContext.Network.ActiveProtocol = Dcm_NetGetProtIdOfConnection(Dcm_InstanceContext.Diag.StartUpFbl.ConnId);
# endif
    /* #50 Leave critical section */
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* #60 Perform the corresponding session transition */
    Dcm_StateSetSession((Dcm_StateIndexMemType)Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef);

    /* #70 Update P2 timings at once */
    Dcm_DiagSetP2Timings((Dcm_StateIndexMemType)Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef
                        ,Dcm_NetGetProtIdOfActiveProtocol());
  }
  /* #80 Unregister diagnostic client in order to consider any non-default session activated above */
  Dcm_NetUnRegisterComMActivity(Dcm_InstanceContext.Diag.StartUpFbl.ConnId);

  return lResultEv;
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagTxPostponeFinalPagedResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagTxPostponeFinalPagedResponse(
                                                                                          Dcm_TskTaskEvOptType ev
                                                                                         ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj();

  /* Wait for RCR-RP if SPRMIB was set */
  if ( (Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.suppressPosResponse != 0) /* SPRMIB == TRUE */
     &&((pTranspObj->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_SENT | DCM_NET_TOBJ_FLAG_RCRRP_ON_TX )) == 0) /* RcrRp was not sent yet */                     /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TF tf xf */
     )
  {
    /* wait for P2 timeout and RCR-RP response transmission */
    Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_TX_SEND_PAGED); /* retry later */                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_TskClrLocalEvent(lResultEv, DCM_TSK_EV_DIAG_TX_SEND_PAGED); /* avoid transmit attempt now */                                                 /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
  }

  return lResultEv;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTxStartFinalResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagTxStartFinalResponse(Dcm_TskTaskEvOptType ev
                                                                                  ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj();

  /* kill any pending RCR-RP orders */
  Dcm_TskClrLocalEvent(lResultEv, DCM_TSK_EV_DIAG_TX_SEND_RCRRP);                                                                                    /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
  Dcm_TmrStopTimer(DCM_TMR_ID_P2);/* stop in any case since from now on only the service will be finalized (either with or without response) */

  if ( (Dcm_InstanceContext.Diag.DoSuppressResponse == TRUE)                 /* No response to send */
      &&(0 == (pTranspObj->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_SENT | DCM_NET_TOBJ_FLAG_RCRRP_ON_TX /* Suppress only if RcrRp was not sent or not waiting for RCR-RP confirmation. If just attempted -> skip RCR-RP transmission */
                              /* | DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ - since DCM_TSK_EV_DIAG_TX_SEND_RCRRP cleared -> RCR-RP will not be sent. Instead finish the service processing at P2 time */))) )
  {
    Dcm_DiagTxFinalization(pTranspObj, DCM_E_OK);/* always OK */                                                                                     /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
  }
  else
  {
    /* prepare final response transmission */
    if(pTranspObj->State == DCM_NET_TOBJ_STATE_READY)
    {
      Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

      lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

      /* clear flag */
      Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, (DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ | DCM_NET_TOBJ_FLAG_RCRRP_ON_TX));          /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */ /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->State = DCM_NET_TOBJ_STATE_PREPTX;                                                                                                 /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->BuffInfo.SduDataPtr = lBufferInfo->BufferPtr;/* reassign the worker buffer */                                                      /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

      if(Dcm_InstanceContext.Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
      {
        /* Positive response */
        pTranspObj->BuffInfo.SduLength = (PduLengthType)(Dcm_InstanceContext.Diag.MsgContext.resDataLen
                                                       + Dcm_InstanceContext.Diag.MsgContext.resProtHeadLen); /* don't forget the SID or/and SF bytes */ /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
        if(Dcm_TskIsLocalEventSet(lResultEv, DCM_TSK_EV_DIAG_TX_SEND_PAGED))
        {
          pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_PAGED;                                                                                          /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
        else
#endif
        {
          pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_LINEAR;                                                                                         /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
      }
      else
      {
        /* Neg response */
        Dcm_NetComposeAddNegResponse(pTranspObj
                                    ,DCM_NET_TOBJ_RESTYPE_LINEAR
                                    ,Dcm_InstanceContext.Diag.ErrorRegister);                                                                        /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      }

      Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND);
    }
    else
    {
      /* retry later */
      Dcm_TskSetLocalEvent(*pPostEv, (lResultEv & (Dcm_TskTaskEvOptType)(DCM_TSK_EV_DIAG_TX_SEND_PAGED | DCM_TSK_EV_DIAG_TX_SEND_LINEAR)));          /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  return lResultEv;
}

/**********************************************************************************************************************
 *  Dcm_DiagTxStartRcrRpResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxStartRcrRpResponse(void)
{
  Dcm_NetTransportObjectPtrType pQueuedTObj;

  pQueuedTObj = Dcm_DiagGetQueuedTranspObj();

  /* don't start the P2* timer within the RCR-RP confirmation but here because of prioritization and synchronization issues which could occur otherwise */
  Dcm_TmrStartTimer(DCM_TMR_ID_P2, Dcm_InstanceContext.Diag.P2Timings.P2Star);/* start now to cover also the application triggered RCR-RPs */

  Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.suppressPosResponse = 0; /* reset the suppress bit and send final response */

  Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pQueuedTObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ);                                               /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */ /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
  Dcm_UtiBitOpSet(Dcm_NetTransportObjectFlagType, pQueuedTObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_ON_TX); /* mark transmission flag */                   /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */

#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pQueuedTObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0)
  {
    /* suppress any RCR-RP responses on RoE - just do loop back ! */
    Dcm_DiagRcrRpTxFinished(pQueuedTObj, DCM_E_OK); /* always OK */                                                                                  /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
  }
  else
#endif
  {
    Dcm_NetComposeAddNegResponse(pQueuedTObj
                                ,DCM_NET_TOBJ_RESTYPE_RCRRP
                                ,DCM_E_REQUESTCORRECTLYRECEIVEDRESPONSEPENDING);                                                                     /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */

    Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND); /* delegate job */
  }
}
#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON) && \
    (DCM_DEV_RAM_SHREDDER_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF tf xf */
/**********************************************************************************************************************
 *  Dcm_VarMgrRamShredder()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrRamShredder(void)
{
 /*
  * Depending on the configuration all PBL related RAM object shall be shredded for debug purposes.
  * The order is not of importance.
  */
# if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
  Dcm_UtiRamShredderArray(Dcm_PbRamNetPeriodicTxObject, Dcm_NetPeriodicTxObjectType,  Dcm_PbCfgNetNumPerTxObjects,      DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
# endif
  Dcm_UtiRamShredderArray(Dcm_PbRamNetComMContext,      Dcm_NetComMContextType,       Dcm_PbCfgNetNumComMChannels,      DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
# if(DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_OFF)
  Dcm_UtiRamShredderArray(Dcm_PbRamNetConnId2TObjMap,   Dcm_CfgNetTObjHandleMemType,  Dcm_PbCfgNetNumConnections,       DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
# endif
  Dcm_UtiRamShredderArray(Dcm_PbRamNetTransportObject,  Dcm_NetTransportObjectType,   Dcm_PbCfgNetNumTransportObjects,  DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
  Dcm_UtiRamShredderArray(Dcm_PbRamNetBufferContext,    Dcm_NetBufferContextType,     Dcm_PbCfgNetNumBuffers,           DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  Dcm_UtiRamShredderArray(Dcm_PbRamNetComCtrlChannels,  Dcm_CommunicationModeType,    Dcm_PbCfgNetNumAllComMChannels,   DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
# endif
}                                                                                                                                                    /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
#endif

#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_VarMgrInit(Dcm_ConfigPtrType configPtr)
{
  uint8 lErrorId = DCM_E_NO_ERROR;
  boolean lResult = TRUE;

# if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                              /* COV_DCM_UNSUPPORTED XF */
  Dcm_VarMgrInitActiveCfgVariants();
# endif

# if (DCM_VARMGR_MODE_POSTBUILD_ANY_ENABLED == STD_ON)                                                                                               /* COV_DCM_SUPPORT_ALWAYS TX */
  /* Check plausibility of the configuration pointer parameter */
  if (configPtr == NULL_PTR)
  {
    Dcm_EcuMErrorNotification(ECUM_BSWERROR_NULLPTR);
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#  if(DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
  if (configPtr->FinalMagicNumber != DCM_CFG_FINAL_MAGIC_NUMBER)
  {
    Dcm_EcuMErrorNotification(ECUM_BSWERROR_MAGICNUMBER);
    lErrorId = DCM_E_INVALID_CONFIG;
  }
  else if (configPtr->GenOutputType != DCM_CFG_GEN_COMPATIBILITY_VERSION)
  {
    Dcm_EcuMErrorNotification(ECUM_BSWERROR_COMPATIBILITYVERSION);
    lErrorId = DCM_E_INVALID_CONFIG;
  }
  else
#  endif
  {
    /* If the passed configuration variant is valid: */

    /* Store currently active variant(s) */
#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
    Dcm_SingletonContext.VarMgr.ActiveComVariant = configPtr->ComVariant;
#  endif
    /* Set bridge */
#  if (DCM_DIAG_MULTI_SVC_TABLE_ENABLED == STD_ON)
    Dcm_UtiAssignStruct(Dcm_SingletonContext.VarMgr.ActiveBridgeVariant, configPtr->BridgeVariant);                                                  /* PRQA S 0310 */ /* MD_Dcm_GenericStructAssign_0310 */
#  endif
#  if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
    Dcm_UtiAssignStruct(Dcm_SingletonContext.VarMgr.ActiveRamVariant, *(configPtr->RamVariant));                                                     /* PRQA S 0310 */ /* MD_Dcm_GenericStructAssign_0310 */
    Dcm_UtiAssignStruct(Dcm_SingletonContext.VarMgr.ActiveRomVariant, *(configPtr->RomVariant));                                                     /* PRQA S 0310 */ /* MD_Dcm_GenericStructAssign_0310 */
#  endif

    /* (Optional) DCM global PBL RAM shredding for debug purposes (must be done after the variant reference cache is initialized) */
    Dcm_VarMgrRamShredder();

    /* Store currently active CFG-criteria(s) */
#  if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
#   if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_OFF)                                                                                           /* COV_DCM_UNSUPPORTED TX */
    Dcm_SingletonContext.VarMgr.ActiveCfgVariantId = configPtr->DiagVariantId;
#   endif
#  endif
  }

#  if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_INIT, lErrorId);
  }
#  endif
  lResult = (boolean) (lErrorId == DCM_E_NO_ERROR);
# endif

  DCM_IGNORE_UNREF_PARAM(configPtr);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return lResult;
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VarMgrInitActiveCfgVariants()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrInitActiveCfgVariants(void)
{
  Dcm_CfgVarMgrDiagVariantIdOptType varRowIter = Dcm_VarMgrBitSetCalcSize(DCM_VARMGR_NUM_CFG_VARIANTS);
  Dcm_CfgVarMgrDiagVariantIdOptType lVariantIter = 0u;
  /* Deactivate all Variants in ActiveCfgVariant Bitmap */
  for (; lVariantIter < varRowIter; ++lVariantIter)
  {
    Dcm_SingletonContext.VarMgr.ActiveCfgVariants[lVariantIter] = 0u;
  }

  Dcm_VarMgrBitSetSetBit(Dcm_SingletonContext.VarMgr.ActiveCfgVariants, 0u);/* activate base variant */
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VarMgrVsgSetSingle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrVsgSetSingle(Dcm_VsgIdentifierType VsgId, Dcm_VsgStateType State)
{
  if(State == DCM_VSG_ENABLED)
  {
    Dcm_VarMgrBitSetSetBit(Dcm_SingletonContext.VarMgr.ActiveCfgVariants, VsgId);
  } /* else State == DCM_VSG_DISABLED */
  else
  {
    Dcm_VarMgrBitSetClrBit(Dcm_SingletonContext.VarMgr.ActiveCfgVariants, VsgId);
  }
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VarMgrVsgIsActive()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrVsgIsActive(Dcm_VsgIdentifierType VsgId
                                                           ,P2VAR(Dcm_VsgStateType, AUTOMATIC, DCM_APPL_DATA) State)
{
  /* If Bit assigned to VsgId is set */
  if ((boolean)Dcm_VarMgrBitSetTestBit(Dcm_SingletonContext.VarMgr.ActiveCfgVariants, VsgId) == TRUE)
  {
    /* Set out parameter to enabled */
    *State = DCM_VSG_ENABLED;
  }
  /* If Bit assigned to VsgId is cleared */
  else
  {
    /* Set out parameter to disabled */
    *State = DCM_VSG_DISABLED;
  }
}
#endif
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc02ReadPidData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint8, DCM_CODE) Dcm_Svc02ReadPidData(uint8 pid, Dcm_MsgContextPtrType pMsgContext, uint32 maskValue)
{
  uint8 lResult = 1u;

  if(Dcm_ObdIdMgrIsAvailabilityId(pid)) /* availability PID */
  {
    /* the response data starts with PID and FF */
    Dcm_DiagProvideResDataAsU8(pMsgContext, pid);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResDataAsU8(pMsgContext, 0x00u); /* Only FF 0x00 is supported */                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Commit availability mask */
    Dcm_DiagProvideResDataAsU32(pMsgContext, maskValue);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else if(pid == 0x02u) /* read data PID from freeze frame */
  {
    uint32 lDtc;

    /* the response data starts with PID and FF */
    Dcm_DiagProvideResDataAsU8(pMsgContext, 0x02u);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResDataAsU8(pMsgContext, 0x00u); /* Only FF 0x00 is supported */                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

# if (DCM_DEM_API_430_ENABLED == STD_ON)
    if(Dem_DcmGetDTCOfOBDFreezeFrame(0x00u, &lDtc) != E_OK)
# else
    if(Dcm_DemAPI(GetDTCOfOBDFreezeFrame)(0x00u, &lDtc) != E_OK)
# endif
    {
      lDtc = 0x0000u;
    }

    /* PID 0x02: DTC that stored the freeze frame */
    Dcm_DiagProvideResDataAsU8(pMsgContext, Dcm_UtiGetHiLoByte(lDtc));                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResDataAsU8(pMsgContext, Dcm_UtiGetLoHiByte(lDtc));                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    /* other PID: get data from freeze frame */
    Std_ReturnType lStdReturn;
    uint8 bufSize;
    Dcm_MsgLenType remainingLen;
    Dcm_MsgType freezeFrameDataBuffer;

    remainingLen = Dcm_DiagGetRemainingResLenWithOffset(pMsgContext, 2u);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    freezeFrameDataBuffer = Dcm_DiagGetResDataRel(pMsgContext, 2);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Calculate maximum possible buffer size (reduce by two to compensate the place for PID and FF!) */
    bufSize = (uint8)Dcm_UtiMathMin(remainingLen, 0xFFu);

# if (DCM_DEM_API_430_ENABLED == STD_ON)
    lStdReturn = Dem_DcmReadDataOfOBDFreezeFrame(
# else
    lStdReturn = Dcm_DemAPI(ReadDataOfOBDFreezeFrame)(
# endif
                                                      pid                                                                                            /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
                                                     ,0x00u /* DCM does not know the data index, so 0x00 is used here */
                                                     ,freezeFrameDataBuffer
                                                     ,&bufSize);

    if( (lStdReturn == E_OK)
      &&(bufSize > 0) )
    {
      /* the response data starts with PID and FF */
      Dcm_DiagProvideResDataAsU8(pMsgContext, pid);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideResDataAsU8(pMsgContext, 0x00u); /* Only FF 0x00 is supported */                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

      /* PID have been successfully read */
      Dcm_DiagProvideResData(pMsgContext, bufSize);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      /* else - PID can not be read or no data stored --> ignore */
      lResult = 0;
    }
  }

  return lResult;
}
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc04Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04Handler(Dcm_OpStatusType                     opStatus
                                                                ,Dcm_MsgContextPtrType                pMsgContext                                    /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                ,Dcm_Svc04RepeaterProxyContextPtrType pRepContext)                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType lStdResult;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(pMsgContext->reqDataLen == 0u)
  {
    Dcm_RepeaterSetUser(DCM_REPEATER_USER_DEM);/* set user for central repeater handling */
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
    Dcm_RepeaterNextStep(DCM_SVC04_PROGRESS_REPEATERPROXY_SELECT_DTC);
# else
    Dcm_RepeaterNextStep(DCM_SVC04_PROGRESS_REPEATERPROXY);
# endif
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc04_XX_RepeaterProxy_SelectDTC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04_XX_RepeaterProxy_SelectDTC(Dcm_OpStatusType      opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc04RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Std_ReturnType lDemResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lDemResult = Dcm_DemAPI(SelectDTC)(pRepContext->DemClientId
                                    ,DEM_DTC_GROUP_ALL_DTCS
                                    ,DEM_DTC_FORMAT_OBD
                                    ,DEM_DTC_ORIGIN_OBD_RELEVANT_MEMORY);

  switch(lDemResult)
  {
  case E_OK:
    lStdResult = DCM_E_LOOP;
    Dcm_RepeaterNextStep(DCM_SVC04_PROGRESS_REPEATERPROXY);
    break;
  case DEM_PENDING:
    lStdResult = DCM_E_PENDING; /* try again later */
    break;
  default:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc04_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04_XX_RepeaterProxy(Dcm_OpStatusType                opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc04RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnClearDTCType lResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lResult = Dcm_DemAPI(ClearDTC)(
# if (DCM_DEM_API_430_ENABLED == STD_ON)
                                 pRepContext->DemClientId
# else
                                 DEM_DTC_GROUP_ALL_DTCS
                                ,DEM_DTC_FORMAT_OBD
                                ,DEM_DTC_ORIGIN_PRIMARY_MEMORY
# endif
                                );

  switch(lResult)
  {
  case DCM_DEM_RET_CLEAR_OK:
    lStdResult = DCM_E_OK;
    break;
  case DCM_DEM_RET_CLEAR_PENDING:
    lStdResult = DCM_E_PENDING; /* try again later */
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lResult, Dcm_Svc04NrcMapClearDTC);                                                                   /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_Service06Process_SupportedMid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service06Process_SupportedMid(Dcm_MsgContextPtrType pMsgContext
                                                                           ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8 lSupportedMids[6];
  uint8_least lMidIter;
  uint8_least lNumberOfMids = (uint8) pMsgContext->reqDataLen;

  /* #10 Check if every MID in request is an availability MID (0x00, 0x20, 0x40...) */
  for (lMidIter = 0; lMidIter < lNumberOfMids; lMidIter++)
  {
    if (Dcm_ObdIdMgrIsAvailabilityId(pMsgContext->reqData[lMidIter]))
    {
      /* #20 If MID is an availabilty MID */
      /* #30 Copy MID value to local buffer */
      lSupportedMids[lMidIter] = pMsgContext->reqData[lMidIter];
    }
    else
    {
      /* Otherwise return NRC DCM_E_REQUESTOUTOFRANGE (Mix of Data and Availability MIDs is not allowed) */
      *errorCode = DCM_E_REQUESTOUTOFRANGE;
      lStdResult = DCM_E_NOT_OK;
      break;
    }
  }

  if (lStdResult == DCM_E_OK)
  {
    /* #50 If every MID is a availability MID */
    /* #60 Request from Dem value of each MID */
    for (lMidIter = 0; lMidIter < lNumberOfMids; lMidIter++)
    {
      uint32 lObdMidAvailMask;
      if (Dem_DcmGetAvailableOBDMIDs(lSupportedMids[lMidIter], &lObdMidAvailMask) == E_OK)                                                           /* PRQA S 3353 */ /* MD_Dcm_3353 */
      {
        /* If request of a MID value is successful */

        /* #80 If response data buffer has not enough space */
        if (pMsgContext->resMaxDataLen < 5)
        {
          /* #81 Return NRC DCM_E_REQUESTOUTOFRANGE */
          *errorCode = DCM_E_REQUESTOUTOFRANGE;
          lStdResult = DCM_E_NOT_OK;
          break;
        }
        /* #90 Otherwise copy MID and MID value to response buffer */
        else
        {
          Dcm_DiagProvideResDataAsU8(pMsgContext, lSupportedMids[lMidIter]);                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
          Dcm_DiagProvideResDataAsU32(pMsgContext, lObdMidAvailMask);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }
      /* else NRC will be set later if response length equal 0 -> none of the OBD MIDs could be read */
    }

    /* #110 If response data buffer is empty  */
    if (pMsgContext->resDataLen == 0)
    {
      /* #120 return NRC DCM_E_REQUESTOUTOFRANGE */
      *errorCode = DCM_E_REQUESTOUTOFRANGE;
      lStdResult = DCM_E_NOT_OK;
    }
  }
  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service06Process_SingleMid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service06Process_SingleMid(Dcm_MsgContextPtrType pMsgContext
                                                                            ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8 lObdMid = pMsgContext->reqData[0];
  uint8 lNumOfTIDs;

  /* #10 Request number of TIDs for MID from Dem */
  if (Dem_DcmGetNumTIDsOfOBDMID(lObdMid, &lNumOfTIDs) == E_OK)
  {
    /* #20 If request is successful */
    uint8 lTidIter;
    uint8 lTIDValue;
    uint8 lUaSID;
    uint16 lTestValue;
    uint16 lTestValueMin;
    uint16 lTestValueMax;

    /* #30  Request Test Result of each TID from Dem */
    for (lTidIter = 0; lTidIter < lNumOfTIDs; lTidIter++)
    {
      if (Dem_DcmGetDTRData(lObdMid
                           ,lTidIter
                           ,&lTIDValue
                           ,&lUaSID
                           ,&lTestValue
                           ,&lTestValueMin
                           ,&lTestValueMax) == E_OK)
      {

        /* #40 If request is successful for a TID */

        /* #50 If response data buffer has not enough space */
        if (pMsgContext->resMaxDataLen < 9)
        {
          /* #51 Return NRC DCM_E_REQUESTOUTOFRANGE */
          *errorCode = DCM_E_REQUESTOUTOFRANGE;
          lStdResult = DCM_E_NOT_OK;
          break;
        }
        /* #60 Otherwise copy response data to response buffer */
        else
        {
          Dcm_DiagProvideResDataAsU8(pMsgContext, lObdMid);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

          Dcm_DiagProvideResDataAsU8(pMsgContext, lTIDValue);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */

          Dcm_DiagProvideResDataAsU8(pMsgContext, lUaSID);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

          Dcm_DiagProvideResDataAsU16(pMsgContext, lTestValue);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
          Dcm_DiagProvideResDataAsU16(pMsgContext, lTestValueMin);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
          Dcm_DiagProvideResDataAsU16(pMsgContext, lTestValueMax);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }
      else
      {
        /* #70 Otherwise return NRC DCM_E_CONDITIONSNOTCORRECT */
        *errorCode = DCM_E_CONDITIONSNOTCORRECT;
        lStdResult = DCM_E_NOT_OK;
        break;                                                                                                                                       /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
      }
    }
  }
  else
  {
    /* #80 Otherwise return NRC DCM_E_REQUESTOUTOFRANGE */
    *errorCode = DCM_E_REQUESTOUTOFRANGE;
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc09Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc09RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  pRepContext->ParserDesc.GetMaskFunc    = Dcm_Svc09GetAvailabilityMask;
  pRepContext->ParserDesc.ParseFlags     = DCM_OBDIDMGR_PFLAG_SINGLEDATAID;

  *ErrorCode = Dcm_ObdIdMgrParseReqAndPrepRes(&pRepContext->ParserDesc, pMsgContext);                                                                /* SBSW_DCM_PARAM_PTR_WRITE */

  if(*ErrorCode == DCM_E_POSITIVERESPONSE)
  {
    if(pRepContext->ParserDesc.IsAvailabilityId == FALSE)
    {
      Dcm_RepeaterNextStep(DCM_SVC09_PROGRESS_REPEATERPROXY);
      lStdResult = DCM_E_LOOP;/* speed up processing */
    }
    else
    {/* else - already copied data */
      lStdResult = DCM_E_OK;
    }
  }
  else
  { /* else - ErrorCode is already set */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc09_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc09RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_ObdIdMgrListItemPtrType  lIdList = pRepContext->ParserDesc.ParseResult;
  uint8 lVidDataLength = (uint8)Dcm_UtiMathMin(Dcm_CfgSvc09ServiceInfoTable[lIdList->Result.Handle].Length, pMsgContext->resMaxDataLen);

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(opStatus == DCM_INITIAL)
  {
    /* Write the VID first, then the response data */
    Dcm_DiagProvideResDataAsU8(pMsgContext, lIdList->Id);
  }

  /* compose response record */
  lStdResult = Dcm_CfgSvc09ServiceInfoTable[lIdList->Result.Handle].OpFunc(opStatus, Dcm_DiagGetResData(pMsgContext)
# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
                                                                          ,&lVidDataLength
# endif
                                                                          );

  if (lStdResult == DCM_E_OK)
  {
# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
#  if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    /* Update final response length only in positive/final case */
    if (lVidDataLength > (Dcm_CfgSvc09ServiceInfoTable[lIdList->Result.Handle].Length))
    {
      lStdResult = DCM_E_NOT_OK;
      Dcm_SetNegResponse(DCM_E_PANIC_NRC);
      Dcm_DebugReportError(DCM_SID_SVCPORT_DATASVCS_OP_READVID, DCM_E_INTERFACE_BUFFER_OVERFLOW);
    }
    else
#  endif
# endif
    {
      /* VID reading finished with OK -> check for next */
      Dcm_DiagProvideResData(pMsgContext, lVidDataLength); /* data size */                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
  else if(lStdResult == DCM_E_PENDING)
  {
    /* Retry later */
  }
  else
  {
    Dcm_DebugApiCheckRte((lStdResult == DCM_E_NOT_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForResetAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForResetAck(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Check mode switch state */
  lStdResult = Dcm_ModeMgrArEnvSwitchAckEcuReset();
  switch(lStdResult)
  {
  case DCM_E_PENDING:
    break;
  case DCM_E_OK:
#  if (DCM_DIAG_RCRRP_ON_BOOT_ENABLED == STD_ON)
    Dcm_RepeaterNextStep(DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK);
    if(Dcm_NetGetProtObjOfTranspObj(Dcm_DiagGetTranspObj())->HasRespPendOnBoot == TRUE)                                                              /* COV_DCM_RTM_DEPENDS_ON_UNSUPPORTED TX */
    {
      lStdResult = DCM_E_FORCE_RCRRP;
    }
    else
    {
      lStdResult = DCM_E_LOOP;
    }
#  else
#   if (DCM_SVC_10_RST2BOOT_HIS_ENABLED == STD_ON)
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_SplitTaskEnterCS();/* avoid interrupt from the Dcm_DiagTaskTx */                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    if(pMsgContext->msgAddInfo.suppressPosResponse != 0)
    {
      pRepContext->ProgConditions.ResponseRequired = FALSE;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_TmrStopTimer(DCM_TMR_ID_P2);/* Stop to avoid inconsistency between P2 timer and the SetProgCond asynchronous API's "ResponseRequired" value */
    }
    else
    {
      pRepContext->ProgConditions.ResponseRequired = TRUE;                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    Dcm_SplitTaskLeaveCS();/* avoid interrupt from the Dcm_DiagTaskTx */                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
#   else
    pRepContext->ProgConditions.ResponseRequired = FALSE;/* no response required since DCM sends the final response */                               /* SBSW_DCM_PARAM_PTR_WRITE */
#   endif

    Dcm_RepeaterNextStep(DCM_SVC10_PROGRESS_SET_PRGCOND);
    lStdResult = DCM_E_LOOP;
#  endif
    break;/* go on with next step - fall through */
  default:
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
#  if (DCM_DIAG_RCRRP_ON_BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForRcrRpAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForRcrRpAck(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

#   if (DCM_SVC_10_RST2BOOT_HIS_ENABLED == STD_ON)
  pRepContext->ProgConditions.ResponseRequired = TRUE;/* always since at least one RCR-RP is sent! */                                                /* SBSW_DCM_PARAM_PTR_WRITE */
#   else
  pRepContext->ProgConditions.ResponseRequired = FALSE;/* no response required since DCM sends the final response */                                 /* SBSW_DCM_PARAM_PTR_WRITE */
#   endif
  Dcm_RepeaterNextStep(DCM_SVC10_PROGRESS_SET_PRGCOND);

  return DCM_E_LOOP;
}
#  endif
# endif

# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_SetProgConditions()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_SetProgConditions(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Consider the SPRMIB now in order to take any sent RCR-RP response */
  lStdResult = Dcm_SetProgConditions(&pRepContext->ProgConditions);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
  switch(lStdResult)
  {
  case DCM_E_OK:
#  if (DCM_SVC_10_RST2BOOT_HIS_ENABLED == STD_ON)
    lStdResult = Dcm_ModeMgrArEnvSwitchReqEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_EXECUTE);
    if(lStdResult == DCM_E_OK)/* fire and forget */
    {
      /* just wait for reset */
      lStdResult = DCM_E_STOP_REPEATER;
    }
    else
    {
      /* This code shall not be reached, since the programming conditions are already set! */
      *ErrorCode = DCM_E_PANIC_NRC; /* Use panic NRC since the first mode switch has succeeded, and this one shall too */                            /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
#  endif
    break; /* send final response and if applicable - do reset */
  case DCM_E_PENDING:
    /* already set */
    break;
  case DCM_E_NOT_OK:
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
# endif

/**********************************************************************************************************************
 *  Dcm_Svc10Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc10RepeaterProxyContextPtrType pRepContext)
{
  Dcm_DiagSubServiceRefOptType  subSvcRef;
  Std_ReturnType                lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                            ,Dcm_CfgSvc10SubFuncLookUpTable
                                            ,Dcm_CfgSvc10SubFuncExecPrecondTable
                                            ,Dcm_DiagSvcWithOnlySubFuncReqLengthGetter
                                            ,&subSvcRef                                                                                              /* SBSW_DCM_CALL_VERIFY_SERVICE_WITH_SUBFUNCTION */
                                            ,ErrorCode);
  if(lStdResult == DCM_E_OK)
  {
    /* Compose positive response */
    Dcm_DiagProvideResDataAsU16(pMsgContext, Dcm_CfgSvc10SubFuncInfo[subSvcRef].ResponseTime.P2);                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResDataAsU16(pMsgContext, Dcm_CfgSvc10SubFuncInfo[subSvcRef].ResponseTime.P2Star);                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

    Dcm_StateSetPendingSession(Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, subSvcRef));
    /* Set always a potential tester owner:
      * in case of failed positive response confirmation or negative response, the session will remain in its old state (default) -> the set value does not matter!
      * The situation that the session was a non-default one and another client has requested SID 0x10 is not possible:
      * - Each protocol switch invokes session transition to the default one!
      * - As long as a non-default session is active, no other client with the same priority can access the ECU! */
    Dcm_NetSetSessionConnection(Dcm_DiagGetTranspObj()->ConnId);/* set potential tester for the session */

    pRepContext->SesStateIdx = (uint8)subSvcRef;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
    pRepContext->ResetMode = DCM_MODEMGR_ARENV_MODE_ECURESET_NONE;                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    if(Dcm_CfgSvc10SubFuncInfo[subSvcRef].BootType != DCM_SVC10_BOOT_TYPE_NONE)
    {
      /* Prepare programming conditions */
      (void)Dcm_GetActiveProtocol(&pRepContext->ProgConditions.ProtocolId);                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
      pRepContext->ProgConditions.TesterSourceAddr = Dcm_PbCfgNetConnectionInfo[Dcm_DiagGetTranspObj()->ConnId].ClientSrcAddr;                       /* SBSW_DCM_PARAM_PTR_WRITE */
      pRepContext->ProgConditions.Sid = 0x10u;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      pRepContext->ProgConditions.SubFuncId = Dcm_CfgSvc10SubFuncLookUpTable[subSvcRef+1];                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      pRepContext->ProgConditions.ReprogrammingRequest = TRUE;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      /* This flag shall be initialized from the FBL, not the DCM!
      pRepContext->ProgConditions.ApplUpdated = TRUE; */
      /* To be set once the Dcm_setProgCond API is called in order to consider the current RCR-RP status!
        * pRepContext->ProgConditions.ResponseRequired = ...; */
      pRepContext->ResetMode = (Dcm_ModeMgrArEnvModeEcuResetType)((Dcm_CfgSvc10SubFuncInfo[subSvcRef].BootType == DCM_SVC10_BOOT_TYPE_OEM)
                                                                                                   ?DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_OEM
                                                                                                   :DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_SYS);   /* SBSW_DCM_PARAM_PTR_WRITE */

      if(Dcm_ModeMgrArEnvSwitchReqEcuReset(pRepContext->ResetMode) == DCM_E_OK)
      {
        /* Determine entry point - with or without RCR-RP */
        Dcm_RepeaterNextStep(DCM_SVC10_PROGRESS_WAIT_RESET_ACK);
        lStdResult = DCM_E_LOOP; /* start immediately */
      }
      else
      {
        /* for some reason, no mode switch is possible - exit with NRC */
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }/* else - just send the final response */
# endif
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc11SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc11SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc11SubFuncInfoGetEntryOrNull(
                                                                                Dcm_DiagSubServiceRefOptType SubSvcRef)
{
  Dcm_CfgSvc11SubFuncInfoPtrType lSubFuncInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SubSvcRef >= DCM_CFGSVC11SUBFUNCINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC11SUBFUNCINFOGETENTRY);
    lSubFuncInfo = NULL_PTR;
  }
  else
# endif
  {
    lSubFuncInfo = &Dcm_CfgSvc11SubFuncInfo[SubSvcRef];
  }

  return lSubFuncInfo;
}

/**********************************************************************************************************************
 *  Dcm_Svc11Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_SVC_11_ECURESET_EXEC_FILTER_ENABLED == STD_ON)
  pRepContext->SubFuncId = Dcm_DiagGetReqDataAsU8(pMsgContext);                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
# endif

  /* Min Length already checked in DiagDispatcher and expected to be 1 !!! */
  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc11SubFuncLookUpTable
                                                   ,Dcm_CfgSvc11SubFuncExecPrecondTable
                                                   ,Dcm_DiagSvcWithOnlySubFuncReqLengthGetter
                                                   ,&lSubSvcRef                                                                                      /* SBSW_DCM_CALL_VERIFY_SERVICE_WITH_SUBFUNCTION */
                                                   ,ErrorCode);

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)(lSubSvcRef);                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_RepeaterNextStep(DCM_SVC11_PROGRESS_SUBFUNCTION); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc11SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11SubFuncHandler(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_CfgSvc11SubFuncInfoPtrType pSubFuncInfo;

  pSubFuncInfo = Dcm_CfgSvc11SubFuncInfoGetEntryOrNull(pRepContext->SubSvcRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSubFuncInfo == NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(opStatus, pMsgContext, ErrorCode);                                                                         /* SBSW_DCM_CALL_FUNCPTR_SVC11SUBFUNC */
  }

  return lStdResult;
}

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_EcuRst_WaitForAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_EcuRst_WaitForAck(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_ModeMgrArEnvSwitchAckEcuReset();
  switch(lStdResult)
  {
  case DCM_E_OK:
    /* switch accomplished */
    break;
  case DCM_E_PENDING:
    /* Result already set
      lStdResult = DCM_E_PENDING; */
    break;
  default: /* any error situation */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_RapPwrDwn_WaitForAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_RapPwrDwn_WaitForAck(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc11RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_ModeMgrArEnvSwitchAckRapidPowerShutDown();
  switch(lStdResult)
  {
  case DCM_E_OK:
    /* switch accomplished */
    break;
  case DCM_E_PENDING:
    /* Result already set
      lStdResult = DCM_E_PENDING; */
    break;
  default: /* any error situation */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14Handler(Dcm_OpStatusType                     opStatus
                                                                ,Dcm_MsgContextPtrType                pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(pMsgContext->reqDataLen == 3u)
  {
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
    pRepContext->DemClientId = Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol());                                                            /* SBSW_DCM_GLOBAL_PTR_WRITE */
# endif

    /* Store requested DTC for asynchronous processing */
    Dcm_DiagConsumeReqDataAsU24(pMsgContext, &(pRepContext->Dtc));                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

    Dcm_RepeaterSetUser(DCM_REPEATER_USER_DEM);/* set user for central repeater handling */
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
    Dcm_RepeaterNextStep(DCM_SVC14_PROGRESS_REPEATERPROXY_SELECT_DTC);
# else
    Dcm_RepeaterNextStep(DCM_SVC14_PROGRESS_REPEATERPROXY);
# endif

    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxy(Dcm_OpStatusType                opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType            lStdResult;
  Dcm_DemReturnClearDTCType lResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEM_API_430_ENABLED == STD_ON)
  lResult = Dcm_DemAPI(ClearDTC)(pRepContext->DemClientId);
# else
  lResult = Dcm_DemAPI(ClearDTC)(pRepContext->Dtc
                                ,DEM_DTC_FORMAT_UDS
                                ,DEM_DTC_ORIGIN_PRIMARY_MEMORY);
# endif

  switch(lResult)
  {
  case DCM_DEM_RET_CLEAR_OK:
    lStdResult = DCM_E_OK;
    break;
  case DCM_DEM_RET_CLEAR_PENDING:
    lStdResult = DCM_E_PENDING; /* try again later */
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lResult, Dcm_Svc14NrcMapClearDTC);                                                                   /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }

  return lStdResult;
}

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxySelectDTC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxySelectDTC(
                                                                       Dcm_OpStatusType                     opStatus
                                                                      ,Dcm_MsgContextPtrType                pMsgContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                      ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                      ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext)                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Std_ReturnType lDemResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lDemResult = Dcm_DemAPI(SelectDTC)(pRepContext->DemClientId
                                    ,pRepContext->Dtc
                                    ,DEM_DTC_FORMAT_UDS
                                    ,DEM_DTC_ORIGIN_PRIMARY_MEMORY);

  switch(lDemResult)
  {
  case E_OK:
    lStdResult = DCM_E_LOOP;
    Dcm_RepeaterNextStep(DCM_SVC14_PROGRESS_REPEATERPROXY_CHECK_SELECTION_RESULT);
    break;
  case DEM_PENDING:
    lStdResult = DCM_E_PENDING; /* try again later */
    break;
  default:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
# endif

# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxyCheckSelectionResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxyCheckSelectionResult(
                                                                       Dcm_OpStatusType                     opStatus
                                                                      ,Dcm_MsgContextPtrType                pMsgContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                      ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                      ,Dcm_Svc14RepeaterProxyContextPtrType pRepContext)                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType            lStdResult;
  Dcm_DemReturnClearDTCType lResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lResult = Dcm_DemAPI(GetDTCSelectionResult)(pRepContext->DemClientId);

  switch(lResult)
  {
  case DCM_DEM_RET_CLEAR_OK:
    lStdResult = DCM_E_LOOP;
    Dcm_RepeaterNextStep(DCM_SVC14_PROGRESS_REPEATERPROXY);
    break;
  case DCM_DEM_RET_CLEAR_PENDING:
    lStdResult = DCM_E_PENDING; /* try again later */
    break;
  case DCM_DEM_RET_CLEAR_W_DTC:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
# endif
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc19SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc19SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc19SubFuncInfoGetEntryOrNull(
                                                                               Dcm_DiagSubServiceRefOptType SubSvcRef)
{
  Dcm_CfgSvc19SubFuncInfoPtrType lSubFuncInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SubSvcRef >= DCM_CFGSVC19SUBFUNCINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC19SUBFUNCINFOGETENTRY);
    lSubFuncInfo = NULL_PTR;
  }
  else
# endif
  {
    lSubFuncInfo = &Dcm_CfgSvc19SubFuncInfo[SubSvcRef];
  }

  return lSubFuncInfo;
}

/**********************************************************************************************************************
 *  Dcm_Svc19Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19Handler(Dcm_OpStatusType                     opStatus
                                                                ,Dcm_MsgContextPtrType                pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc19SubFuncLookUpTable
                                                   ,Dcm_CfgSvc19SubFuncExecPrecondTable
                                                   ,Dcm_Svc19ReqLengthGetter
                                                   ,&lSubSvcRef                                                                                      /* SBSW_DCM_CALL_VERIFY_SERVICE_WITH_SUBFUNCTION */
                                                   ,ErrorCode);

# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
  pRepContext->DemClientId = Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol());                                                              /* SBSW_DCM_GLOBAL_PTR_WRITE */
# endif

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)(lSubSvcRef);                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_RepeaterSetUser(DCM_REPEATER_USER_DEM);/* set user for central repeater handling */
    Dcm_RepeaterNextStep(DCM_SVC19_PROGRESS_SUBFUNCTION); /* delegate job */

    Dcm_ExtSvc19UtiPatchDtcStatusInit();
    lStdResult = DCM_E_LOOP;/* speed up processing */
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc19SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19SubFuncHandler(Dcm_OpStatusType                   opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_CfgSvc19SubFuncInfoPtrType pSubFuncInfo;

  pSubFuncInfo = Dcm_CfgSvc19SubFuncInfoGetEntryOrNull(pRepContext->SubSvcRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSubFuncInfo == NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(opStatus, pMsgContext, ErrorCode);                                                                         /* SBSW_DCM_CALL_FUNCPTR_SVC19SUBFUNC */
  }

  return lStdResult;
}
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectDTC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectDTC(Dcm_OpStatusType                  opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DemAPI(SelectDTC)(pRepContext->DemClientId
                                    ,pRepContext->Dtc
                                    ,DEM_DTC_FORMAT_UDS
                                    ,pRepContext->Origin);

  switch (lStdResult)
  {
    case E_OK:
      lStdResult = Dcm_Svc19UtiChainNext(pRepContext);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
 /* case DEM_BUSY: */ /* Not yet specified in SWS - DEM_BUSY not defined */
      /* try again */
   /* lStdResult = DCM_E_PENDING; */
   /* break; */
    default:
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_DemApiNrcMapSelectDTC);                                                            /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_SETDTCFILTER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSetDTCFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSetDTCFilter(
                                                                   Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                  ,Dcm_Svc19DemSetFilterClassType       DsfClass
                                                                  ,uint8                                DtcStatusMask
                                                                  ,Dem_DTCSeverityType                  DtcSeverityMask
                                                                  ,Dcm_DemFilterForFDCType              FilterForFDC
                                                                  ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnSetFilterType demResultSetFilter;
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  demResultSetFilter = Dcm_DemAPI(SetDTCFilter)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
                                                pRepContext->DemClientId,
#  endif
                                                DtcStatusMask
#  if (DCM_DEM_API_430_ENABLED == STD_OFF)
                                               ,Dcm_Svc19DemDtcFilterInfo[DsfClass].Kind
#  endif
                                               ,DEM_DTC_FORMAT_UDS
                                               ,Dcm_Svc19DemDtcFilterInfo[DsfClass].Origin
                                               ,Dcm_Svc19DemDtcFilterInfo[DsfClass].ConsiderSeverity
                                               ,DtcSeverityMask
                                               ,FilterForFDC);

  if(demResultSetFilter == DCM_DEM_RET_FILTER_ACCEPTED)
  {
    lStdResult = DCM_E_OK;
  }
  else
  {
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResultSetFilter, Dcm_DemApiNrcMapSetDTCFilter);                                                   /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_MSR_STPAR */
# endif

# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Sv19UtiStartReporting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Sv19UtiStartReporting(uint8                            subUpdater
                                                                     ,Dcm_MsgLenType                       reportSize
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  DCM_IGNORE_UNREF_PARAM(reportSize);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pRepContext->SubUpdater = subUpdater;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */

#  if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_PagedBufferStart(reportSize);
  return DCM_E_STOP_REPEATER;
#  else
  Dcm_RepeaterNextStep(DCM_SVC19_PROGRESS_UTI_COPYLINEARDATA);
  return DCM_E_LOOP;
#  endif
}
# endif

# if (DCM_SVC_19_ABSTRACT_RECORD_ITER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Sv19UtiRecordIterNext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc19UtiRecordIterResultType, DCM_CODE) Dcm_Svc19UtiRecordIterNext(
                                                                      Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Dcm_Svc19UtiRecordIterResultType lRecIterResult;

  lRecIterResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;

  if(pRepContext->RecordNumList != NULL_PTR)
  {
    Dcm_UtiNextItemByPtr(pRepContext->RecordNumList, 1u);                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->RecordNum = pRepContext->RecordNumList[0];                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
    if(pRepContext->RecordNum != DCM_SVC_19_RECLIST_END)
    {
      lRecIterResult = DCM_SVC19_UTI_REC_ITER_RSLT_OK;
    }
  }

  return lRecIterResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemDisableRecordUpdate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemDisableRecordUpdate(Dcm_OpStatusType        opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnDisableDTCRecordUpdateType demResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(DisableDTCRecordUpdate)(pRepContext->DemClientId);
#  else
  demResult = Dcm_DemAPI(DisableDTCRecordUpdate)(pRepContext->Dtc
                                                ,pRepContext->Origin);
#  endif
  switch(demResult)
  {
  case DCM_DEM_RET_DISABLE_DTC_REC_UP_OK:
    lStdResult = Dcm_Svc19UtiChainNext(pRepContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_DEM_RET_DISABLE_DTC_REC_UP_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapAnyAbleRecordUpdate);                                                      /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSTATUSOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetStatusOfDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetStatusOfDtc(Dcm_OpStatusType             opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetStatusOfDTCType demResult;
  uint8 dtcStatusMask;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(GetStatusOfDTC)(pRepContext->DemClientId
                                        ,&dtcStatusMask);                                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  demResult = Dcm_DemAPI(GetStatusOfDTC)(pRepContext->Dtc
                                        ,pRepContext->Origin
                                        ,&dtcStatusMask);                                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif
  switch(demResult)
  {
  case DCM_DEM_RET_STATUS_OK:
    Dcm_ExtSvc19UtiPatchDtcStatusApplyByResult(&dtcStatusMask);                                                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */

    Dcm_DiagProvideResDataAsU24(pMsgContext, pRepContext->Dtc);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResDataAsU8(pMsgContext, dtcStatusMask);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_Svc19UtiChainNext(pRepContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#  if defined (DCM_DEM_RET_STATUS_NO_SUCH_ELEMENT)
  case DCM_DEM_RET_STATUS_NO_SUCH_ELEMENT:
    /* Skip committing data (SWS_Dcm_01409) */
    lStdResult = Dcm_Svc19UtiChainNext(pRepContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#  endif
  case DCM_DEM_RET_STATUS_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetStatusOfDTC);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFFFRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfFFRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfFFRecord(Dcm_OpStatusType         opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetSizeOfFFRByDTCType demResult;
  uint16 dataLen;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(GetSizeOfFreezeFrameSelection)(pRepContext->DemClientId
                                                       ,&dataLen);                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  demResult = Dcm_DemAPI(GetSizeOfFreezeFrameByDTC)(pRepContext->Dtc
                                                   ,pRepContext->Origin
                                                   ,pRepContext->RecordNum
                                                   ,&dataLen);                                                                                       /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif
  switch(demResult)
  {
  case DCM_DEM_RET_SIZEOFFFR_OK:
    if(dataLen != 0u) /* consider only stored records */
    {
      if(pRepContext->RecordNumList != NULL_PTR)
      {
        pRepContext->RecordNum = pRepContext->RecordNumList[0]; /* take first one */                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
        Dcm_DebugAssert((DCM_SVC_19_RECNUM_ALL != pRepContext->RecordNum), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                    /* COV_DCM_RTM_DEV_DEBUG XF */
      }

      lStdResult = Dcm_Sv19UtiStartReporting(DCM_SVC_19_UPDATE_GET_FF_RECORD
                                            ,dataLen
                                            ,pRepContext);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      /* Otherwise, proceed with response transmission with no further data */
      lStdResult = DCM_E_OK;
    }
    break;
  case DCM_DEM_RET_SIZEOFFFR_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetSizeOfFreezeFrameByDTC);                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEM_API_SELECT_EDR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectExtRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectExtRecord(Dcm_OpStatusType            opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  (void)Dcm_DemAPI(SelectExtendedDataRecord)(pRepContext->DemClientId
                                            ,pRepContext->RecordNum);

  return Dcm_Svc19UtiChainNext(pRepContext);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFEXTRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfExtRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfExtRecord(Dcm_OpStatusType         opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;
  Dcm_DemReturnGetSizeOfEDRByDTCType demResult;
  uint16 dataLen;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(GetSizeOfExtendedDataRecordSelection)(pRepContext->DemClientId
                                                              ,&dataLen);                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  demResult = Dcm_DemAPI(GetSizeOfExtendedDataRecordByDTC)(pRepContext->Dtc
                                                          ,pRepContext->Origin
                                                          ,pRepContext->RecordNum
                                                          ,&dataLen);                                                                                /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif
  switch(demResult)
  {
  case DCM_DEM_RET_SIZEOFEDR_OK:
    if(dataLen != 0u) /* consider only stored records */
    {
      if(pRepContext->RecordNumList != NULL_PTR)
      {
        pRepContext->RecordNum = pRepContext->RecordNumList[0];/* take first one */                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
        Dcm_DebugAssert((DCM_SVC_19_RECNUM_ALL != pRepContext->RecordNum), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                    /* COV_DCM_RTM_DEV_DEBUG XF */
      }
#  if (DCM_DEM_API_403_ENABLED == STD_ON)                                                                                                            /* COV_DCM_UNSUPPORTED XF */
      else
      {
        ++dataLen; /* DEM considers the RecordNumberByte in case of ALL RECs, in single RecordNum -> add manually */
      }
#  endif
      lStdReturn = Dcm_Sv19UtiStartReporting(DCM_SVC_19_UPDATE_GET_EXT_RECORD
                                            ,dataLen
                                            ,pRepContext);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      /* Otherwise, proceed with response transmission with no further data */
      lStdReturn = DCM_E_OK;
    }
    break;
  case DCM_DEM_RET_SIZEOFEDR_PENDING:
    lStdReturn = DCM_E_PENDING;
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetSizeOfExtendedDataRecordByDTC);                                         /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
    break;
  }
  return lStdReturn;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETNUMFILTEREDDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNumFltrdDtc(Dcm_OpStatusType             opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetNumberOfFilteredDTCType demResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  demResult = Dcm_DemAPI(GetNumberOfFilteredDTC)(pRepContext->DemClientId
                                                ,&pRepContext->NumDtc);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
#  else
  demResult = Dcm_DemAPI(GetNumberOfFilteredDTC)(&pRepContext->NumDtc);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
#  endif
  switch(demResult)
  {
  case DCM_DEM_RET_NUMBER_OK:
    lStdResult = Dcm_Svc19UtiChainNext(pRepContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_DEM_RET_NUMBER_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:/* DEM_NUMBER_FAILED or unknown */
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_DemApiNrcMapGetNumberOfFilteredDTC);                                                  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdSeverity(Dcm_OpStatusType        opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Sv19UtiStartReporting(DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY
                                  ,(Dcm_MsgLenType)(pRepContext->NumDtc * 6)
                                  ,pRepContext);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSeverityOfDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSeverityOfDtc(Dcm_OpStatusType           opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetSeverityOfDTCType demResultSeverity;
  uint8 dtcSeverity;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  demResultSeverity = Dcm_DemAPI(GetSeverityOfDTC)(pRepContext->DemClientId
                                                  ,&dtcSeverity);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  demResultSeverity = Dcm_DemAPI(GetSeverityOfDTC)(pRepContext->Dtc
                                                  ,&dtcSeverity);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  switch(demResultSeverity)
  {
#  if defined (DCM_DEM_RET_GET_SEVERITY_OF_DTC_NOSEVERITY)
  case DCM_DEM_RET_GET_SEVERITY_OF_DTC_NOSEVERITY:
    dtcSeverity = 0; /* set to NO SEVERITY as specified in ISO14229-1 and go on with the remained part */
    /* fall through */
#  endif
  case DCM_DEM_RET_GET_SEVERITY_OF_DTC_OK:                                                                                                           /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
    Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSeverity);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = Dcm_Svc19UtiChainNext(pRepContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_DEM_RET_GET_SEVERITY_OF_DTC_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResultSeverity, Dcm_Svc19NrcMapGetSeverityOfDTC);                                                 /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetFuncUnitOfDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetFuncUnitOfDtc(Dcm_OpStatusType           opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  uint8 functionalUnit;
  Dcm_DemReturnGetFunctionalUnitOfDTCType lDemResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  lDemResult = Dcm_DemAPI(GetFunctionalUnitOfDTC)(pRepContext->DemClientId
                                                 ,&functionalUnit);                                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  lDemResult = Dcm_DemAPI(GetFunctionalUnitOfDTC)(pRepContext->Dtc
                                                 ,&functionalUnit);                                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  switch(lDemResult)
  {
    case DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_OK:
      Dcm_DiagProvideResDataAsU8(pMsgContext, functionalUnit);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = Dcm_Svc19UtiChainNext(pRepContext);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  if defined (DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_PENDING)
    case DCM_DEM_RET_GET_FUNCTIONALUNITOFDTC_PENDING:
      lStdResult = DCM_E_PENDING;
      break;
#  endif
    default:
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lDemResult, Dcm_Svc19NrcMapGetFunctionalUnitOfDTC);                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdDtc(Dcm_OpStatusType             opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Sv19UtiStartReporting(DCM_SVC_19_UPDATE_GET_NXT_FLTRD_DTC
                                  ,(Dcm_MsgLenType)(pRepContext->NumDtc * 4)
                                  ,pRepContext);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiPutNumFilteredDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiPutNumFilteredDtc(Dcm_OpStatusType            opStatus
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagProvideResDataAsU16(pMsgContext, pRepContext->NumDtc);                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

  return DCM_E_OK;
}
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdFDC(Dcm_OpStatusType              opStatus
                                                                      ,Dcm_MsgContextPtrType                pMsgContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                      ,Dcm_NegativeResponseCodePtrType      ErrorCode                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                      ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Sv19UtiStartReporting(DCM_SVC_19_UPDATE_GET_NXT_FLTRD_FDC
                                  ,(Dcm_MsgLenType)(pRepContext->NumDtc * 4)
                                  ,pRepContext);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity(Dcm_OpStatusType  opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Sv19UtiStartReporting(DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY_WWHOBD
                                  ,(Dcm_MsgLenType)(pRepContext->NumDtc * 5)
                                  ,pRepContext);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdRecord(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  uint32                                lDtc;
  uint8                                 recordNumber;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lStdResult = DCM_E_BUFFERTOOLOW;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  while (pDataContext->AvailLen >= 4u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredRecord)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
        pRepContext->DemClientId,
#  endif
        &lDtc, &recordNumber);                                                                                                                       /* SBSW_DCM_POINTER_FORWARD_STACK */
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_DiagProvideDataAsU24(pDataContext, lDtc);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU8(pDataContext, recordNumber);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending") */
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING)                                                                                    /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  uint32                                lDtc;
  uint8                                 dtcStatus;
  uint8                                 dtcFuncUnit;
  Dem_DTCSeverityType                   dtcSeverity;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lStdResult = DCM_E_BUFFERTOOLOW;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  while (pDataContext->AvailLen >= 6u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTCAndSeverity)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
                                                          pRepContext->DemClientId,
#  endif
                                                          &lDtc
                                                         ,&dtcStatus
                                                         ,&dtcSeverity
                                                         ,&dtcFuncUnit);                                                                             /* SBSW_DCM_POINTER_FORWARD_STACK */
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(&dtcStatus);                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */

      Dcm_DiagProvideDataAsU8(pDataContext, (Dcm_MsgItemType)dtcSeverity);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU8(pDataContext, dtcFuncUnit);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU24(pDataContext, lDtc);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU8(pDataContext, dtcStatus);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending") */
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING) /* signal retry */                                                                 /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdFDC(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  uint32                                lDtc;
  sint8                                 dtcFDC;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lStdResult = DCM_E_BUFFERTOOLOW;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  while (pDataContext->AvailLen >= 4u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTCAndFDC)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
                                                     pRepContext->DemClientId,
#  endif
                                                     &lDtc, &dtcFDC);                                                                                /* SBSW_DCM_POINTER_FORWARD_STACK */
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_DiagProvideDataAsU24(pDataContext, lDtc);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU8(pDataContext, (uint8)dtcFDC);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending") */
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING)                                                                                    /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  uint32                                lDtc;
  uint8                                 dtcStatus;
  uint8                                 dtcFuncUnit;
  Dem_DTCSeverityType                   dtcSeverity;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lStdResult = DCM_E_BUFFERTOOLOW;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  while (pDataContext->AvailLen >= 5u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTCAndSeverity)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
                                                          pRepContext->DemClientId,
#  endif
                                                          &lDtc
                                                         ,&dtcStatus
                                                         ,&dtcSeverity
                                                         ,&dtcFuncUnit);                                                                             /* SBSW_DCM_POINTER_FORWARD_STACK */
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(&dtcStatus);                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */

      Dcm_DiagProvideDataAsU8(pDataContext, (Dcm_MsgItemType)dtcSeverity);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU24(pDataContext, lDtc);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU8(pDataContext, dtcStatus);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending") */
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING)                                                                                    /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdDtc(
                                                                     Dcm_DiagDataContextPtrType           pDataContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  uint32                                lDtc;
  uint8                                 dtcStatus;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lStdResult = DCM_E_BUFFERTOOLOW;

  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  while (pDataContext->AvailLen >= 4u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTC)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
                                               pRepContext->DemClientId,
#  endif
                                               &lDtc, &dtcStatus);                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(&dtcStatus);                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */

      Dcm_DiagProvideDataAsU24(pDataContext, lDtc);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU8(pDataContext, dtcStatus);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
    }

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending") */
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING) /* signal retry */                                                                 /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetExtRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetExtRecord(Dcm_DiagDataContextPtrType  pDataContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType  demResult;
  Std_ReturnType  lStdResult;
  uint16          dcmBufferSize;
  boolean         readNextData = TRUE;

  lStdResult = DCM_E_BUFFERTOOLOW; /* Initialize lStdResult to satisfy MISRA */

  do
  {
    dcmBufferSize = (uint16) pDataContext->AvailLen;

    demResult = Dcm_DemAPI(GetNextExtendedDataRecord)(pRepContext->DemClientId
                                                     ,Dcm_DiagGetDataContextBuffer(pDataContext)                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                     ,&dcmBufferSize);                                                                               /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

    switch (demResult)
    {
    case DCM_DEM_RET_GET_EXT_DATA_REC_OK:
      Dcm_DiagCommitData(pDataContext, dcmBufferSize);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_OK;
      break;
    case DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_NUMBER:
      lStdResult = DCM_E_OK;
      readNextData = FALSE;
      break;
    case DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_BUFFERSIZE:
      lStdResult = DCM_E_BUFFERTOOLOW;
      readNextData = FALSE;
      break;
    case DCM_DEM_RET_GET_EXT_DATA_REC_PENDING:
      lStdResult = DCM_E_PENDING;/* signal retry */
      readNextData = FALSE;
      break;
    default:
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetExtendedDataRecordByDTC);                                             /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      readNextData = FALSE;
      break;
    }
  }
  while (readNextData == TRUE);

  /* If record data processing finished in this call (with or without success), enable DTC record update immediately */
  if((lStdResult == DCM_E_OK) || (lStdResult == DCM_E_NOT_OK))
  {
    (void)Dcm_DemAPI(EnableDTCRecordUpdate)(pRepContext->DemClientId);
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
#  else
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetExtRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetExtRecord(Dcm_DiagDataContextPtrType  pDataContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Dem_ReturnGetExtendedDataRecordByDTCType demResult;
  Std_ReturnType                           lStdResult;
  uint16                                   dcmBufferSize;
  Dcm_Svc19UtiRecordIterResultType         dcmNextRecordResult;

  lStdResult = DCM_E_BUFFERTOOLOW; /* Initialize lStdResult to satisfy MISRA */
  dcmNextRecordResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;

  do
  {
    /* Move one byte up to reserve place for the record number */
    Dcm_DiagCommitData(pDataContext, 1);                                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

    dcmBufferSize = (uint16) pDataContext->AvailLen;

    demResult = Dcm_DemAPI(GetExtendedDataRecordByDTC)(pRepContext->Dtc
                                                      ,pRepContext->Origin
                                                      ,pRepContext->RecordNum
                                                      ,Dcm_DiagGetDataContextBuffer(pDataContext)                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                      ,&dcmBufferSize);                                                                              /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

    /* Move back to original position to write now the data */
    Dcm_DiagRevertData(pDataContext, 1);                                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

    if(demResult == DCM_DEM_RET_GET_EXT_DATA_REC_OK)
    {
      if(dcmBufferSize != 0)/* consider only stored records */
      {
        Dcm_DiagProvideDataAsU8(pDataContext, pRepContext->RecordNum);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DiagCommitData(pDataContext, dcmBufferSize);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      }

      dcmNextRecordResult = Dcm_Svc19UtiRecordIterNext(pRepContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_OK;
    }
    else if(demResult == DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_NUMBER)
    {
      if(pRepContext->RecordNumList == NULL_PTR)/* single record query */
      {
        dcmNextRecordResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetExtendedDataRecordByDTC);                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
      else
      {
        dcmNextRecordResult = Dcm_Svc19UtiRecordIterNext(pRepContext);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdResult = DCM_E_OK;
      }
    }
    else
    {
      dcmNextRecordResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;
      switch (demResult)
      {
      case DCM_DEM_RET_GET_EXT_DATA_REC_WRONG_BUFFERSIZE:
        lStdResult = DCM_E_BUFFERTOOLOW;
        break;
      case DCM_DEM_RET_GET_EXT_DATA_REC_PENDING:
        lStdResult = DCM_E_PENDING;/* signal retry */
        break;
      default:
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetExtendedDataRecordByDTC);                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        break;
      }
    }

    /* If no more records to be reported or current iteration detected an error, stop iteration */
    if(dcmNextRecordResult == DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS)
    {
      break;
    }
  }
  while (pDataContext->AvailLen != 0u);

  if ( (pDataContext->AvailLen == 0u)
     &&(dcmNextRecordResult != DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS) )
  {
    lStdResult = DCM_E_BUFFERTOOLOW;
  }

  /* If record data processing finished in this call (with or without success), enable DTC record update immediately */
  if((lStdResult == DCM_E_OK) || (lStdResult == DCM_E_NOT_OK))
  {
    (void)Dcm_DemAPI(EnableDTCRecordUpdate)();
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
#  endif
# endif

# if (DCM_DEM_API_SELECT_FFR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemSelectFFData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemSelectFFData(
                                                                      Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  (void)Dcm_DemAPI(SelectFreezeFrameData)(pRepContext->DemClientId
                                         ,pRepContext->RecordNum);

  return Dcm_Svc19UtiChainNext(pRepContext);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED == STD_ON)
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetFFRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetFFRecord(Dcm_DiagDataContextPtrType   pDataContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType  demResult;
  Std_ReturnType  lStdResult;
  uint16          dcmBufferSize;
  boolean         readNextData = TRUE;

  lStdResult = DCM_E_BUFFERTOOLOW; /* Initialize lStdResult to satisfy MISRA */

  do
  {
    dcmBufferSize = (uint16)pDataContext->AvailLen;

    demResult =  Dcm_DemAPI(GetNextFreezeFrameData)(pRepContext->DemClientId
                                                   ,Dcm_DiagGetDataContextBuffer(pDataContext)                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                   ,&dcmBufferSize);                                                                                 /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

    switch (demResult)
    {
    case DCM_DEM_RET_FFDATABYDTC_OK:
      if(dcmBufferSize != 0u)/* consider only stored records */
      {
        Dcm_DiagCommitData(pDataContext, dcmBufferSize);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      lStdResult = DCM_E_OK;
      break;
    case DCM_DEM_RET_FFDATABYDTC_W_RNUM:
      lStdResult = DCM_E_OK;
      readNextData = FALSE;
      break;
    case DCM_DEM_RET_FFDATABYDTC_W_BUFSIZE:
      lStdResult = DCM_E_BUFFERTOOLOW;
      readNextData = FALSE;
      break;
    case DCM_DEM_RET_FFDATABYDTC_PENDING:
      lStdResult = DCM_E_PENDING;/* signal retry */
      readNextData = FALSE;
      break;
    default:
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetFreezeFrameDataByDTC);                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;/* finish processing */
      readNextData = FALSE;
      break;
    }
  }
  while (readNextData == TRUE);

  /* If record data processing finished in this call (with or without success), enable DTC record update immediately */
  if((lStdResult == DCM_E_OK) || (lStdResult == DCM_E_NOT_OK))
  {
    (void)Dcm_DemAPI(EnableDTCRecordUpdate)(pRepContext->DemClientId);
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#  else
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetFFRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetFFRecord(Dcm_DiagDataContextPtrType   pDataContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Dem_ReturnGetFreezeFrameDataByDTCType demResult;
  Std_ReturnType                        lStdResult;
  uint16                                dcmBufferSize;
  Dcm_Svc19UtiRecordIterResultType      dcmNextRecordResult;

  lStdResult = DCM_E_BUFFERTOOLOW; /* Initialize lStdResult to satisfy MISRA */
  dcmNextRecordResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;

  do
  {
    dcmBufferSize = (uint16)pDataContext->AvailLen;

    demResult =  Dcm_DemAPI(GetFreezeFrameDataByDTC)(pRepContext->Dtc
                                                    ,pRepContext->Origin
                                                    ,pRepContext->RecordNum
                                                    ,Dcm_DiagGetDataContextBuffer(pDataContext)                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                    ,&dcmBufferSize);                                                                                /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    if(demResult == DCM_DEM_RET_FFDATABYDTC_OK)
    {
      Dcm_DiagCommitData(pDataContext, dcmBufferSize);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      dcmNextRecordResult = Dcm_Svc19UtiRecordIterNext(pRepContext);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_OK;
    }
    else if(demResult == DCM_DEM_RET_FFDATABYDTC_W_RNUM)
    {
      if(pRepContext->RecordNumList == NULL_PTR)/* single record query */
      {
        dcmNextRecordResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetFreezeFrameDataByDTC);                                              /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
      else
      {
        dcmNextRecordResult = Dcm_Svc19UtiRecordIterNext(pRepContext);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdResult = DCM_E_OK;
      }
    }
    else
    {
      switch (demResult)
      {
      case DCM_DEM_RET_FFDATABYDTC_W_BUFSIZE:
        lStdResult = DCM_E_BUFFERTOOLOW;
        break;
      case DCM_DEM_RET_FFDATABYDTC_PENDING:
        lStdResult = DCM_E_PENDING;/* signal retry */
        break;
      default:
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetFreezeFrameDataByDTC);                                              /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;/* finish processing */
        break;
      }
      /* Finished for this cycle or error occurred */
      dcmNextRecordResult = DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS;
    }

    if(dcmNextRecordResult == DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS)
    {
      break;
    }
  }
  while(pDataContext->AvailLen != 0);

  if( (pDataContext->AvailLen == 0u)
    &&(dcmNextRecordResult != DCM_SVC19_UTI_REC_ITER_RSLT_NO_MORE_RECORDS) )
  {
    lStdResult = DCM_E_BUFFERTOOLOW;
  }

  /* If record data processing finished in this call (with or without success), enable DTC record update immediately */
  if((lStdResult == DCM_E_OK) || (lStdResult == DCM_E_NOT_OK))
  {
    (void)Dcm_DemAPI(EnableDTCRecordUpdate)();
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#  endif
# endif

# if (DCM_SVC_19_REPORT_VIA_SUBUPDATER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19UtiCopyData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service19UtiCopyData(Dcm_DiagDataContextPtrType           pDataContext
                                                                        ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                        ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;

  switch(pRepContext->SubUpdater)
  {
#  if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_DTC:
      lStdResult = Dcm_Svc19UtiCpyDemGetNxtFltrdDtc(pDataContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_RECORD:
      lStdResult = Dcm_Svc19UtiCpyDemGetNxtFltrdRecord(pDataContext, ErrorCode, pRepContext);                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_FDC:
      lStdResult = Dcm_Svc19UtiCpyDemGetNxtFltrdFDC(pDataContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY:
      lStdResult = Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity(pDataContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_NXT_FLTRD_SEVERITY_WWHOBD:
      lStdResult = Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity(pDataContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_EXT_RECORD:
      lStdResult = Dcm_Svc19UtiCpyDemGetExtRecord(pDataContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
#  if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED == STD_ON)
    case DCM_SVC_19_UPDATE_GET_FF_RECORD:
      lStdResult = Dcm_Svc19UtiCpyDemGetFFRecord(pDataContext, ErrorCode, pRepContext);                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      break;
#  endif
    default:
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)
      break;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
# endif

# if (DCM_SVC_19_COPY_LINEAR_DATA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyLinearData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyLinearData(Dcm_OpStatusType                 opStatus
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType           lStdResult;
  Dcm_DiagDataContextType  lDataContext;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagInitDataContext(&lDataContext, Dcm_DiagGetResData(pMsgContext), pMsgContext->resMaxDataLen);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

  lStdResult = Dcm_Service19UtiCopyData(&lDataContext, ErrorCode, pRepContext);                                                                      /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */

  /* Commit copied data */
  Dcm_DiagProvideResData(pMsgContext, lDataContext.Usage);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(  (lStdResult != DCM_E_PENDING)
    && (lStdResult != DCM_E_NOT_OK))
  {
    if(lStdResult == DCM_E_BUFFERTOOLOW)
    {
      *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else
    {
      lStdResult = DCM_E_OK;
    }
  }
  return lStdResult;
}
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc22Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext)                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
    Std_ReturnType                lStdResult;

    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Min Length already checked in DiagDispatcher and expected to be 2 !!! */
  /* Check if the length is multiple of 2, since each DID is 2 Byte */
  if( ((pMsgContext->reqDataLen & 0x01u) == 0) /* length is an odd (wrong) or even (right) number */
    &&(pMsgContext->reqDataLen <= (Dcm_MsgLenType)(DCM_SVC_22_MAX_DID_LIST_LEN * 2)) )    /* Also the capacity of the ECU shall not be exceeded */
  {

    pRepContext->DidInfoContextPtr = &(pRepContext->DidInfoContextList[0]);
    pRepContext->NumDids = 0u;
    pRepContext->DidIter = 0u;
    pRepContext->TotalLength = 0u;

    Dcm_RepeaterNextStep(DCM_SVC22_PROGRESS_DIDLOOKUP);
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

# if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *   Dcm_Svc22IsDidAccessible()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc22IsDidAccessible(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext)                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  boolean lResult;

  /* #10 Check whether the DID is used by service 0x2A or 0x2C */
  if( (pDidInfoContext->Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadPeriodic)
#  if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
    ||(pDidInfoContext->Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic )
#  endif
    /* no periodic DID is a writeable or IO DID -> no need to check for race conditions! */
    )
  {
    lResult = FALSE;
  }
  else
  {
    lResult = TRUE;
  }

  return lResult;
}
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_Svc22CopyLinearData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CopyLinearData(Dcm_OpStatusType opStatus
                                                                       ,Dcm_MsgContextPtrType pMsgContext                                            /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                       ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                       ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
  if(opStatus == DCM_INITIAL)
#  endif
  {
    /* #10 Copy the ID of the DID to the buffer */
    Dcm_DiagProvideResDataAsU16(pMsgContext, pRepContext->DidInfoContextPtr->Did);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

    Dcm_DidMgrGetOpClassInfo(pRepContext->DidInfoContextPtr, DCM_DIDMGR_OPTYPE_READ);
  }

  {
    Dcm_DiagDataContextType lDataContext;

    /* Pass buffer control from MsgContext to DataContext */
    Dcm_DiagInitDataContext(&lDataContext, Dcm_DiagGetResData(pMsgContext), pMsgContext->resMaxDataLen);

    /* #20 Try to read the DID */
    lStdResult = Dcm_DidMgrReadDid(opStatus
                                  ,&lDataContext
                                  ,pRepContext->DidInfoContextPtr
                                  ,&(pRepContext->DidOpTypeContext)
                                  ,ErrorCode);

    switch(lStdResult)
    {
#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
      case DCM_E_PENDING:
        /* #40 Try it the next task cycle */
        break;
#  endif
#  if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
      case DCM_E_FORCE_RCRRP:
        /* #60 Send NRC 0x78 */
        break;
#  endif
      case DCM_E_OK:
#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
        Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce = 0u;
#  endif
        /* #110 Move to the next DID data position (the whole DID should be committed now) */
        Dcm_DiagProvideResData(pMsgContext, lDataContext.Usage);                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

        --(pRepContext->NumDids);
        /* #120 If all DIDs were read: */
        if(pRepContext->NumDids != 0)
        {
          /* #140 Otherwise start over reading the next DID */
          Dcm_UtiNextItemByPtr(pRepContext->DidInfoContextPtr, 1u);

#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
          Dcm_RepeaterNextStep(DCM_SVC22_PROGRESS_CHECKACCESS);
#  endif
          lStdResult = DCM_E_LOOP;
        }
        break;
    default:/* DCM_E_NOT_OK */
#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
      Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce = 0u;
#  endif
      /* #100 Finish service processing immediately by sending the appropriate NRC */
      break;
    }
  }

  return lStdResult; /* Speed up processing */
}                                                                                                                                                    /* PRQA S 6030 */ /* MD_MSR_STCYC */
# endif /* (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_OFF) */

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CopyPagedDataInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CopyPagedDataInit(Dcm_DiagDataContextPtrType     pDataContext
                                                                    ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lResult = DCM_E_BUFFERTOOLOW;

#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
  /* #10 If this DID is currently used by another service: */
  boolean  lIsAccessible;
  lIsAccessible = Dcm_Svc22IsDidAccessible(pRepContext->DidInfoContextPtr);

  if(lIsAccessible == FALSE)
  {
    /* #20 Try to read the DID the next task cycle */
    lResult = DCM_E_PENDING;
  }
  else
#  endif
  {
#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
    Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce = pRepContext->DidInfoContextPtr->Did;
#  endif
    /* #40 If there is enough buffer space available to copy the ID of the DID: */
    if(pDataContext->AvailLen >= 2u)
    {
      /* #50 Copy the ID */
      Dcm_DiagProvideDataAsU8(pDataContext, Dcm_UtiGetHiByte(pRepContext->DidInfoContextPtr->Did));                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU8(pDataContext, Dcm_UtiGetLoByte(pRepContext->DidInfoContextPtr->Did));                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_DidMgrGetOpClassInfo(pRepContext->DidInfoContextPtr, DCM_DIDMGR_OPTYPE_READ);
      lResult = DCM_E_OK;
    }
  }

  return lResult;
}
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22ReadDidPaged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadDidPaged(Dcm_DiagDataContextPtrType pDataContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lResult;

  /* #10 Try to read the DID data */
  lResult = Dcm_DidMgrReadDid(pRepContext->OpStatus
                             ,pDataContext
                             ,pRepContext->DidInfoContextPtr
                             ,&(pRepContext->DidOpTypeContext)
                             ,ErrorCode);
  switch(lResult)
  {
  case DCM_E_PENDING:
    /* #30 Try it the next task cycle */
    pRepContext->OpStatus = DCM_PENDING;
    /* Do not commit any data */
    break;
  case DCM_E_BUFFERTOOLOW:
    /* #50 Notify the page buffer and try it later */
    pRepContext->OpStatus = DCM_PENDING;
    break;
  case DCM_E_OK:
    /* #70 Go on with next DID */
    pRepContext->OpStatus = DCM_INITIAL;
#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
    Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce = 0u;
#  endif
    break;
  default: /* DCM_E_NOT_OK */
    /* #90 Finish service processing immediately by sending the appropriate NRC */
#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
    Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce = 0u;
#  endif
    /* NRC will be set in the outer level DCM callout handler (e.g. Dcm_DidMgrReadSignal()) */
    break;
  }

  return lResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc22DidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22DidLookUp(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;
  boolean doProcessDid = TRUE;

  if(opStatus == DCM_INITIAL)
  {
    /* If still at least one DID to be processed: */
    if(pMsgContext->reqDataLen != 0u)
    {
      Dcm_DiagConsumeReqDataAsU16(pMsgContext, &(pRepContext->DidInfoContextPtr->Did));                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      doProcessDid = FALSE;
    }
  }

  if(doProcessDid == TRUE)
  {
    lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                     ,pRepContext->DidInfoContextPtr
                                     ,&(pRepContext->DidOpTypeContext)
                                     ,DCM_DIDMGR_OP_READ);
    if(lStdReturn == DCM_E_OK)
    {
      ++(pRepContext->NumDids); /* register a supported DID */

      lStdReturn = Dcm_DidMgrDynDidStateCheck(pRepContext->DidInfoContextPtr, ErrorCode);
      if (lStdReturn == DCM_E_OK)
      {
        Dcm_UtiNextItemByPtr(pRepContext->DidInfoContextPtr, 1u);/* next info storage */
        lStdReturn = DCM_E_LOOP; /* proceed with next DID */
      } /* else DCM_E_NOT_OK (ErrorCode already set) */
    }
    else if(lStdReturn == DCM_E_PENDING)
    {
      /* already set */
    }
    else
    {
      /* Just skip this DID - DCM_E_NOT_OK - request a new look-up loop */
      lStdReturn = DCM_E_LOOP;
    }
  }
  else
  {
    /* empty run loop ended without any DID to be processed (for this activation of the repeater proxy) */
    /* all DIDs processed */
    if(pRepContext->NumDids != 0u)/* any DID to process? */
    {
      pRepContext->DidIter = pRepContext->NumDids;
      pRepContext->DidInfoContextPtr = &(pRepContext->DidInfoContextList[0]);/* start over the list */

# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
      Dcm_RepeaterNextStep(DCM_SVC22_PROGRESS_CHECKCONDITION); /* delegate job */
# else
      Dcm_RepeaterNextStep(DCM_SVC22_PROGRESS_GETLENGTH); /* delegate job */
# endif
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    }
    else
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
  }

  return lStdReturn;
}

# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CheckCondition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CheckCondition(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext)
{
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ALL_ENABLED == STD_OFF)
  if(Dcm_DidMgrIsOpTypeSupported(pRepContext->DidInfoContextPtr->Descriptor.DidOpInfoPtr, DCM_DIDMGR_OPTYPE_READCHKCOND))
#  endif
  {
    Std_ReturnType               lStdResult;

    Dcm_DidMgrGetOpClassInfo(pRepContext->DidInfoContextPtr, DCM_DIDMGR_OPTYPE_READCHKCOND);

    /* check condition */
    lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                        ,pRepContext->DidInfoContextPtr
                                        ,&(pRepContext->DidOpTypeContext)
                                        ,ErrorCode);
    if(lStdResult == DCM_E_OK)
    {
      /* DCM_E_OK - go on with next DID */
    }
    else
#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    if(lStdResult == DCM_E_PENDING)
    {
      return DCM_E_PENDING;
    }
    else
#  endif
    {
      /* DCM_E_NOT_OK */
      return DCM_E_NOT_OK; /* finish service processing immediately */
    }
  }/* else - not supported operation - go on with getLength */
  Dcm_RepeaterNextStep(DCM_SVC22_PROGRESS_GETLENGTH); /* next job */
  return DCM_E_LOOP;
}                                                                                                                                                    /* PRQA S 2006 */ /* MD_Dcm_Optimize_2006 */
# endif

/**********************************************************************************************************************
 *  Dcm_Svc22GetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22GetLength(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DIDMGR_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
  /* read length */
  {
    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,pRepContext->DidInfoContextPtr
                                     ,ErrorCode);
  }/* else - static length */

  if(lStdReturn == DCM_E_OK)
# endif
  {
    /* DCM_E_OK - go on with next DID */
    /* On DID ranges, the maximum configured theoretical length will be used as a final length! This is because the concrete length is first acquired with the ReadDidData service call */
    pRepContext->TotalLength += pRepContext->DidInfoContextPtr->DidLength;
    pRepContext->TotalLength += 2; /* cumulate DID length + DID itself */

    /* check for buffer overrun */
# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
    /* Note: '<' because MaxLength includes the SID */
    if(pRepContext->TotalLength < Dcm_NetGetProtObjOfTranspObj(Dcm_DiagGetTranspObj())->MaxLength)
# else
    /* Note: '<=' because pMsgContext->resMaxDataLen excludes the SID */
    if(pRepContext->TotalLength <= pMsgContext->resMaxDataLen)
# endif
    {
      --(pRepContext->DidIter);
      if(pRepContext->DidIter == 0)
      {
        /* All DIDs processed without any errors. Prepare for reading */
        /* Now pRepContext->NumDids will be used as counter -> didIter not needed any more!
         *pRepContext->DidIter = pRepContext->NumDids;
         */
        pRepContext->DidInfoContextPtr = &(pRepContext->DidInfoContextList[0]);

# if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
        Dcm_RepeaterNextStep(DCM_SVC22_PROGRESS_CHECKACCESS); /* delegate job */
# else
        Dcm_RepeaterNextStep(DCM_SVC22_PROGRESS_READDATA); /* delegate job */
# endif
      }
      else
      {
        Dcm_UtiNextItemByPtr(pRepContext->DidInfoContextPtr, 1u);/* next DID */
# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
        Dcm_RepeaterNextStep(DCM_SVC22_PROGRESS_CHECKCONDITION); /* start again with next DID  */
# else
        /* already added */
# endif
      }
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    }
    else
    {
      *ErrorCode = DCM_E_RESPONSETOOLONG;/* the configured buffer will not be able to hold all of the data -> notify the client */                   /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    }
  }/* else - DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}

# if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CheckAccess(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lResult = DCM_E_LOOP;
  boolean lIsAccessible;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lIsAccessible =  Dcm_Svc22IsDidAccessible(pRepContext->DidInfoContextPtr);

 /* #10 If the DID isn't currently in use by another service: */
  if(lIsAccessible == TRUE)
  {
    /* #20 Reserve the DID for service 0x22 and read it out */
    Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce = pRepContext->DidInfoContextPtr->Did;

    Dcm_RepeaterNextStep(DCM_SVC22_PROGRESS_READDATA);
  }
  else
  {
    /* #30 Otherwise try it later */
    lResult = DCM_E_PENDING;
  }

  return lResult;/* speed up processing */
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc22ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadData(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                 ,Dcm_Svc22RepeaterProxyContextPtrType pRepContext)
{
# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DebugAssert((pMsgContext->resDataLen == 0), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */

  pRepContext->OpStatus = DCM_INITIAL;

  /* #20 Start the paged-buffer to copy the DID data */
  Dcm_PagedBufferStart(pRepContext->TotalLength);
  return DCM_E_STOP_REPEATER;
# else
  /* #30 Otherwise copy the DID data using the linear buffer */
  return Dcm_Svc22CopyLinearData(opStatus, pMsgContext, ErrorCode, pRepContext);
# endif
}
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc23Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc23RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  uint8          lAlfid;
  uint8          lBlockLength;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* dispatcher guarantees for minimum length of 3 bytes (ALFID + MEM + SIZE) available */
  *ErrorCode = Dcm_MemMgrValidateAlfid(pMsgContext, &lAlfid, &lBlockLength);                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  if(*ErrorCode == DCM_E_POSITIVERESPONSE)
  {
    /* check for exact length match */
    if(pMsgContext->reqDataLen == lBlockLength)
    {
      Dcm_MemMgrParseMemStream(lAlfid
                              ,pMsgContext
                              ,&pRepContext->MemBlock);

      lStdResult = Dcm_MemMgrCheckMemBlock(&pRepContext->MemBlock, DCM_MEMMGR_OP_READ, ErrorCode);
      if(lStdResult == DCM_E_OK)
      {
        /* Check for overflow */
        if(pRepContext->MemBlock.Length <= pMsgContext->resMaxDataLen)
        {
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
          Dcm_RepeaterNextStep(DCM_SVC23_PROGRESS_CHECKACCESS);
# else
          Dcm_RepeaterNextStep(DCM_SVC23_PROGRESS_READMEMORY);
# endif
          lStdResult = DCM_E_LOOP;/* speed up processing */
        }
        else
        {
          *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      } /* else DCM_E_NOT_OK - ErrorCode is already set */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }
  else
  { /* else - ErrorCode is already set */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc23CheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23CheckAccess(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_Svc23RepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_InstanceContext.MemMgr.LockedByClient != DCM_MEMMGR_ACCESS_NONE)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
  {
    Dcm_InstanceContext.MemMgr.LockedByClient = DCM_MEMMGR_ACCESS_REQ_EXT;
    Dcm_RepeaterNextStep(DCM_SVC23_PROGRESS_READMEMORY); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc23ReadMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23ReadMemory(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext                                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                   ,Dcm_Svc23RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_MemMgrReadMemory(opStatus
                                   ,&pRepContext->MemBlock
                                   ,Dcm_DiagGetResData(pMsgContext)
                                   ,ErrorCode);

  if(lStdResult == DCM_E_OK)
  {
    Dcm_DiagProvideResData(pMsgContext, pRepContext->MemBlock.Length);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  /*  Otherwise - any other result to be delegated to the core
   *  No DET monitoring needed since the Dcm_MemMgrReadMemory has already one!
   */
  return lStdResult;
}
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc24Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc24RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType                lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* If valid service request length: */
  if(pMsgContext->reqDataLen == 2u)
  {
    /* Prepare for DID look up */
    Dcm_DiagConsumeReqDataAsU16(pMsgContext, &(pRepContext->DidInfoContext.Did));                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Initialize DID look up */
    Dcm_RepeaterNextStep(DCM_SVC24_PROGRESS_DIDLOOKUP);
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    /* Invalid length detected -> send NRC 0x13 */
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  /* Return control to DCM core */
  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc24ExecuteOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24ExecuteOp(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc24RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType               lStdResult;

  lStdResult = Dcm_DidMgrGetScalingInfo(opStatus
                                      ,pMsgContext
                                      ,&(pRepContext->DidInfoContext)
                                      ,&(pRepContext->DidOpTypeContext)
                                      ,ErrorCode);

# if (DCM_DIDMGR_ASYNC_SCALINGDID_SUPPORT_ENABLED == STD_ON)
  if(lStdResult == DCM_E_PENDING)
  {
    /* return DCM_E_PENDING */
  }
  else
# endif
  {
    if(lStdResult != DCM_E_OK)
    {
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc24DidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24DidLookUp(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc24RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pRepContext->DidInfoContext)
                                   ,&(pRepContext->DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_SCALINGINFO);
  if(lStdReturn == DCM_E_OK)
  {
    /* Currently no state checks are possible on scaling DIDs in AR 4.x */
    /*
    lStdReturn = Dcm_DidMgrStaticDidStateCheck(pRepContext->DidInfoContext.Descriptor.DidOpInfoPtr->ExecCondRef, ErrorCode);
    if(lStdReturn == DCM_E_OK)
    */
    {
      Dcm_DiagProvideResData(pMsgContext, 2);    /* commit the DID only. The scaling record size will be calculated on the fly */                    /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_DidMgrGetOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_GETSCALING);
      Dcm_RepeaterNextStep(DCM_SVC24_PROGRESS_EXECUTEOP); /* delegate job */
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    }/* else - ErrorCode already assigned */
  }
  else if(lStdReturn == DCM_E_PENDING)
  {
    /* DID verification takes longer -> retry later */
  }
  else
  {
    /* DID is not supported -> send NRC 0x31 */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }

  return lStdReturn; /* finish service processing immediately */
}
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc27SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc27SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc27SubFuncInfoGetEntryOrNull(
                                                                                Dcm_DiagSubServiceRefOptType SubSvcRef)
{
  Dcm_CfgSvc27SubFuncInfoPtrType lSubFuncInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SubSvcRef >= DCM_CFGSVC27SUBFUNCINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC27SUBFUNCINFOGETENTRY);
    lSubFuncInfo = NULL_PTR;
  }
  else
# endif
  {
    lSubFuncInfo = &Dcm_CfgSvc27SubFuncInfo[SubSvcRef];
  }

  return lSubFuncInfo;
}

/**********************************************************************************************************************
 *  Dcm_CfgSvc27SecLevelInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc27SecLevelInfoPtrType, DCM_CODE) Dcm_CfgSvc27SecLevelInfoGetEntryOrNull(
                                                                                                   uint8_least secLev)
{
  Dcm_CfgSvc27SecLevelInfoPtrType lSecLevelInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (secLev >= DCM_CFGSVC27SECLEVELINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC27SECLEVELINFOGETENTRY);
    lSecLevelInfo = NULL_PTR;
  }
  else
# endif
  {
    lSecLevelInfo = &Dcm_CfgSvc27SecLevelInfo[secLev];
  }

  return lSecLevelInfo;
}

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27CounterSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterSet(uint8_least secLev, uint8 value)
{
  uint8_least lCounterIdx = Dcm_Svc27GetCounterIdx(secLev);

  DCM_IGNORE_UNREF_PARAM(secLev);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_SVC_27_MULTI_ATTEMPT_COUNTER_ENABLED == STD_ON)
#   if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                            /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (lCounterIdx >= DCM_SVC_27_NUM_ATTEMPT_COUNTERS)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_SVC27COUNTERSET);
  }
  else
#   endif
#  endif
  {
    Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[lCounterIdx] = value;                                                                       /* SBSW_DCM_POINTER_WRITE_ATTEMPTCOUNT */
  }
}
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27CounterInc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterInc(uint8_least secLev)
{
  uint8 lValue = Dcm_Svc27CounterGet(secLev);

  if(lValue < Dcm_UtiMaxValueOfUintType(uint8))
  {
    Dcm_Svc27CounterSet(secLev, (uint8)(lValue + 1u));
  }
}
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27TimerSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27TimerSet(uint8_least secLev, Dcm_Svc27TimerType value)
{
  uint8_least lTimerIdx = Dcm_Svc27GetTimerIdx(secLev);

  DCM_IGNORE_UNREF_PARAM(secLev);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_SVC_27_MULTI_DELAY_TIMER_ENABLED == STD_ON)
#   if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                            /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(lTimerIdx >= DCM_SVC_27_NUM_DELAY_TIMERS)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_SVC27TIMERSET);
  }
  else
#   endif
#  endif
  {
    /* Enter critical section (Reason: Avoid interrupt from Dcm_OnTimeoutSecurityAccess) */
    Dcm_SplitTaskEnterCS();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/

    Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[lTimerIdx] = value;                                                                            /* SBSW_DCM_POINTER_WRITE_DELAYTIME */

    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_SplitTaskLeaveCS();
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc27Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc27Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc27SubFuncLookUpTable
                                                   ,Dcm_CfgSvc27SubFuncExecPrecondTable
                                                   ,Dcm_Svc27ReqLengthGetter
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_CALL_VERIFY_SERVICE_WITH_SUBFUNCTION */

  /* Initialize service processor context for further processing */
  pRepContext->ErrorCode = DCM_E_POSITIVERESPONSE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)(lSubSvcRef);/* Store working sub-function reference (also in negative response cases) */   /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->SecLvlRef = Dcm_Svc27GetSecLvlRef(lSubSvcRef);                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */

  if(lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(DCM_SVC27_PROGRESS_SUBFUNCTION);
    lStdResult = DCM_E_LOOP; /* Speed up processing */
  }
  else
# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
  /* If the requested key has wrong length (if security retry is enabled): */
  if(*ErrorCode == DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT)
  {
    if( (Dcm_Svc27IsKeyRequest(pRepContext->SubSvcRef)) /* wrong length key is an invalid key! */
      &&(Dcm_Svc27IsKeyRequestExpected()) )
    {
      Dcm_Svc27CounterInc(pRepContext->SecLvlRef);                                                                                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
      Dcm_RepeaterNextStep(DCM_SVC27_PROGRESS_SETATTEMPTCNTR);
      pRepContext->ErrorCode = *ErrorCode; /* used in next step */                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_LOOP;/* Speed up processing */
#  endif
    }
    /* Send prepared NRC immediately */
  }
  else
# endif
  {
    /* Send prepared NRC immediately */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc27SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc27SubFuncHandler(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_CfgSvc27SubFuncInfoPtrType pSubFuncInfo;

  pSubFuncInfo = Dcm_CfgSvc27SubFuncInfoGetEntryOrNull(pRepContext->SubSvcRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSubFuncInfo == NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(opStatus, pMsgContext, ErrorCode);                                                                         /* SBSW_DCM_CALL_FUNCPTR_SVC27SUBFUNC */
  }

  return lStdResult;
}

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiGetAttemptCntr()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27UtiGetAttemptCntr(Dcm_OpStatusType opStatus
                                                                ,P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask)
{
  Std_ReturnType  lResult;
  uint8           lAttemptCount;
  uint8_least     lSecLvlIter = 0u;
  uint32          lMask = *levelMask;

  /* #10 For each security level: */
  DCM_UTI_LOOP_BIT_SCAN(lMask)
  {
    /* #20 If the attempt counter for that specific security level is not already read: */
    if(Dcm_TskIsLocalEventSet(lMask, 0x01u))
    {
      Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;

      pSecLevelInfo = Dcm_CfgSvc27SecLevelInfoGetEntryOrNull(lSecLvlIter);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if (pSecLevelInfo == NULL_PTR)                                                                                                                 /* COV_DCM_RTM_RUNTIME_CHECK XF */
      {
        break;
      }
      else
#  endif
      {
        /* #30 Try to read the attempt counter from the application */
        lResult = pSecLevelInfo->GetAttemptCntrFunc(opStatus, &lAttemptCount);                                                                       /* SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL */

        /* #40 If everything was ok: */
        if(lResult == DCM_E_OK)
        {
          /*
           * Note: Using critical sections is not necessary here because the features "power on delay" and
           *       "external attempt counter storage" are used mutually exclusive per security level.
           */

          /* #50 Mark the security level to prevent that this API is called again */
          Dcm_UtiBitOpClr(uint32, *levelMask, Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter));                                                          /* SBSW_DCM_PARAM_PTR_WRITE */

          /* #60 If the already initialized attempt counter has to be updated: */
          if(lAttemptCount != 0)
          {
            /* #70 Store the attempt counter */
            Dcm_Svc27CounterSet(lSecLvlIter, lAttemptCount);

            /* #80 If the current attempt counter value exceeded the maximum number of allowed attempts: */
            if(lAttemptCount >= Dcm_CfgStateSecurityInfo[lSecLvlIter].NumAttempts)
            {
              /* #90 Set the delay timer value. The timer will be started later with that value */
              Dcm_Svc27TimerSet(lSecLvlIter, Dcm_CfgStateSecurityInfo[lSecLvlIter].DelayTimeInvKey);                                                 /* PRQA S 3109 */ /* MD_MSR_14.3 */
            }
          }
        }/* #91 If more time needed: */
        else if (lResult == DCM_E_PENDING)
        {
          /* #92 Try it later */
        }
        else /* #100 If something went wrong: */
        {
          Dcm_DebugApiCheckRte((lResult == DCM_E_NOT_OK), DCM_SID_GETSECURITYATTEMPTCOUNTER, DCM_E_INTERFACE_RETURN_VALUE)

          /* #110 Mark the security level to prevent that this API is called again */
          Dcm_UtiBitOpClr(uint32, *levelMask, Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter));                                                          /* SBSW_DCM_PARAM_PTR_WRITE */

          /* #120 Reset the attempt counter */
          Dcm_Svc27CounterReset(lSecLvlIter);

#  if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
          /* #130 If delay time on failed read of attempt counter is enabled: */
          if(Dcm_CfgStateSecurityInfo[lSecLvlIter].ReloadOnZeroDelay == TRUE)
          {
            /* #140 If the configured delay time is zero: */
            if(Dcm_CfgStateSecurityInfo[lSecLvlIter].ReloadTime == 0u)
            {
              /* #150 Set the delay timer value to infinity */
              Dcm_Svc27ReloadReadFailedSet(lSecLvlIter);
              Dcm_Svc27TimerSet(lSecLvlIter, 1u);                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
            }
            else
            {
              /* #160 Otherwise set the configured delay timer value */
              Dcm_Svc27TimerSet(lSecLvlIter, Dcm_CfgStateSecurityInfo[lSecLvlIter].ReloadTime);                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
            }
          }
#  endif
        }
      }
    }
    ++lSecLvlIter;
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27ReadAttemptCounter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_Svc27ReadAttemptCounter(Dcm_TskTaskEvOptType ev
                                                                                 ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  /* #10 Restore the attempt counter values from the application */
  Dcm_Svc27UtiGetAttemptCntr(Dcm_InstanceContext.Diag.Services.Svc27.GetAttOpStatus
                            ,&Dcm_InstanceContext.Diag.Services.Svc27.GetAttCntrEventMask);                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  /* #20 If all attempt counters were read */
  if(Dcm_InstanceContext.Diag.Services.Svc27.GetAttCntrEventMask == 0u)
  {
    uint8_least lTmrIter;

    for(lTmrIter = 0; lTmrIter < DCM_SVC_27_NUM_DELAY_TIMERS; ++lTmrIter)
    {
      /* #30 If the corresponding security timer value is not zero: */
      if(Dcm_Svc27TimerGet(lTmrIter) != 0u)
      {
        /* #40 Start the appropriate security timer */
        Dcm_Svc27TimerStart(lTmrIter);                                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
      }
    }
    /* Reset operation status */
    Dcm_InstanceContext.Diag.Services.Svc27.GetAttOpStatus = DCM_INITIAL;
  }
  else
  {
    /* #50 Otherwise resume the job next task cycle */
    Dcm_TskSetLocalEvent(*pPostEv, ev);                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_InstanceContext.Diag.Services.Svc27.GetAttOpStatus = DCM_PENDING;
  }

  return lResultEv;
}
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27WriteAttemptCounter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_Svc27WriteAttemptCounter(Dcm_TskTaskEvOptType ev
                                                                                  ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  /* #10 Notify the application about changed attempt counters */
  Dcm_Svc27UtiSetAttemptCntr(Dcm_InstanceContext.Diag.Services.Svc27.SetAttOpStatus
                            ,&Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask);                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  /* #20 If all attempt counters were written: */
  if(Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask == 0u)
  {
    /* #30 Finish the job and reset the opStatus for next write cycle */
    Dcm_InstanceContext.Diag.Services.Svc27.SetAttOpStatus = DCM_INITIAL;
  }
  else
  {
    /* #40 Otherwise resume the job next task cycle and notify application for the subsequent call via opStatus parameter */
    Dcm_TskSetLocalEvent(*pPostEv, ev);                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_InstanceContext.Diag.Services.Svc27.SetAttOpStatus = DCM_PENDING;
  }

  return lResultEv;
}
# endif

# if (DCM_SVC_27_SUBFUNC_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SeedRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SeedRepeater(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lResult;
  Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;

  pSecLevelInfo = Dcm_CfgSvc27SecLevelInfoGetEntryOrNull(pRepContext->SecLvlRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if( (pSecLevelInfo == NULL_PTR)                                                                                                                    /* PRQA S 3415 */ /* MD_Dcm_3415 */
    ||(Dcm_DiagCheckResBuffer(pMsgContext, pSecLevelInfo->SeedResLength) == FALSE) )                                                                 /* COV_DCM_RTM_RUNTIME_CHECK TF xf xf */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
#  endif
  {
    /* Read the seed of the appropriate security level */
    switch(pSecLevelInfo->GetSeedFuncClass)
    {
    case DCM_SVC27_OPCLS_SEED_WITHOUT_ADR:
      lResult = ((Dcm_Svc27OpFuncSeedWoAdr)pSecLevelInfo->GetSeedFunc)(opStatus                                                                      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                      ,Dcm_DiagGetResData(pMsgContext)                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                      ,ErrorCode);                                                                   /* SBSW_DCM_CALL_FUNCPTR_SVC27GETSEED */
      break;
    case DCM_SVC27_OPCLS_SEED_WITH_ADR:
      lResult = ((Dcm_Svc27OpFuncSeedWAdr)pSecLevelInfo->GetSeedFunc)(Dcm_DiagGetReqData(pMsgContext)                                                /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                     ,opStatus
                                                                     ,Dcm_DiagGetResData(pMsgContext)                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                     ,ErrorCode);                                                                    /* SBSW_DCM_CALL_FUNCPTR_SVC27GETSEED */
      break;
    default:                                                                                                                                         /* COV_DCM_RTM_UNREACHABLE X */
      DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */

      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = DCM_E_NOT_OK;
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      break;
    }

    switch(lResult)
    {
      case DCM_E_OK:
        /* Send response */
        Dcm_DiagProvideResData(pMsgContext, pSecLevelInfo->SeedResLength);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
        break;
      case DCM_E_PENDING:
        /* Retry later */
        break;
      case DCM_E_NOT_OK:
        Dcm_DiagHandleApplNrc(lResult, ErrorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
        break;
      default:
        Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = DCM_E_NOT_OK;
        break;
    }
  }

  return lResult;
}
# endif

# if (DCM_SVC_27_SUBFUNC_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27KeyRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27KeyRepeater(Dcm_OpStatusType opStatus
                                                                     ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType                  lResult;
  Dcm_NegativeResponseCodeType    lNrc = DCM_E_POSITIVERESPONSE;
  Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;

  pSecLevelInfo = Dcm_CfgSvc27SecLevelInfoGetEntryOrNull(pRepContext->SecLvlRef);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSecLevelInfo == NULL_PTR)                                                                                                                     /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
#  endif
  {
    /* Let the application compare the given key data */
    lResult = pSecLevelInfo->CompareKeyFunc(Dcm_DiagGetReqData(pMsgContext)                                                                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                           ,opStatus
#  if (DCM_DCM_AR_VERSION != DCM_DCM_AR_VERSION_403)
                                           ,&lNrc
#  endif
                                           );                                                                                                        /* SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL */

    switch(lResult)
    {
      /*---------------------------*/
      case DCM_E_OK:
      /*---------------------------*/
        /* Reset the attempt counter of this security level */
        Dcm_Svc27CounterReset(pRepContext->SecLvlRef);

#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
        /* Notify application about new attempt counter */
        Dcm_RepeaterNextStep(DCM_SVC27_PROGRESS_SETATTEMPTCNTR);
        lResult = DCM_E_LOOP;
#  endif
        break;
      /*---------------------------*/
      case DCM_E_PENDING:
      /*---------------------------*/
        /* Try later */
        break;
      /*---------------------------*/
      case DCM_E_NOT_OK:
      /*---------------------------*/
        /* If an error occurred set the NRC given by the application */
#  if (DCM_DCM_AR_VERSION != DCM_DCM_AR_VERSION_403)
        Dcm_DiagHandleApplNrc(lResult, &lNrc, DCM_E_CONDITIONSNOTCORRECT);                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif
        /* fall through */
      case DCM_E_COMPARE_KEY_FAILED:                                                                                                                 /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
#  if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
        /* Increment the attempt counter */
        Dcm_Svc27CounterInc(pRepContext->SecLvlRef);                                                                                                 /* PRQA S 3109 */ /* MD_MSR_14.3 */

        /* Notify application about new attempt counter */
        Dcm_RepeaterNextStep(DCM_SVC27_PROGRESS_CHECKATTEMPTSEXCEEDED);
        pRepContext->ErrorCode = lNrc; /* will be used in next step */                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = DCM_E_LOOP;
#  else
        /* This NRC will be ignored if compare key function returned DCM_E_NOT_OK and therefore a NRC was already set */
#   if (DCM_DCM_AR_VERSION != DCM_DCM_AR_VERSION_403)
        if (lNrc == DCM_E_POSITIVERESPONSE)
#   endif
        {
          lNrc = DCM_E_INVALIDKEY;
        }
        *ErrorCode = lNrc;                                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = DCM_E_NOT_OK;
#  endif
        break;
      /*---------------------------*/
      default:
      /*---------------------------*/
        Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = DCM_E_NOT_OK;
        break;
    }
  }

  return lResult;
}
# endif

# if (DCM_SVC_27_SUBFUNC_SUPPORT_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27CheckAttemptsExceededRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27CheckAttemptsExceededRepeater(Dcm_OpStatusType opStatus
                                                                     ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType  lResult;
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  uint32          lMask = Dcm_UtiGetBitFromIndex(uint32, pRepContext->SecLvlRef);
#  endif

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  /* #10 Notify the application about the new attempt counter value */
  Dcm_Svc27UtiSetAttemptCntr(opStatus, &lMask);                                                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

  /* #20 If the setting of the attempt counter was not successful: */
  if(lMask != 0)
  {
    /* #30 Try it later */
    lResult = DCM_E_PENDING;
  }
  else /* #40 Otherwise: */
#  endif
  {
    /* #50 If the number of allowed attempt were exceeded: */
    if( (Dcm_CfgStateSecurityInfo[pRepContext->SecLvlRef].NumAttempts != 0) /* Consider only levels with attempt monitoring */
      && (Dcm_Svc27CounterGet(pRepContext->SecLvlRef) >= Dcm_CfgStateSecurityInfo[pRepContext->SecLvlRef].NumAttempts))
    {
      /* #60 Set NRC 0x36 if not already set and start the timer */
      /* This NRC will be ignored if ErrorCode is already set due to failed compare key function */
      *ErrorCode = DCM_E_EXCEEDNUMBEROFATTEMPTS;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */

      Dcm_Svc27TimerSet(pRepContext->SecLvlRef, Dcm_CfgStateSecurityInfo[pRepContext->SecLvlRef].DelayTimeInvKey);                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */
      Dcm_Svc27TimerStart(pRepContext->SecLvlRef);                                                                                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */
    }
    else
    {
      /* #70 Otherwise set NRC 0x35 if not already set */
      /* This NRC will be ignored if ErrorCode is already set due to failed compare key function */
      *ErrorCode = DCM_E_INVALIDKEY;                                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    if (pRepContext->ErrorCode != DCM_E_POSITIVERESPONSE)
    {
      /* Use previously set ErrorCode if available */
      *ErrorCode = pRepContext->ErrorCode;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    lResult = DCM_E_NOT_OK;
  }

  return lResult;
}
# endif

# if (DCM_SVC_27_SUBFUNC_SUPPORT_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SetAttemptCntrRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SetAttemptCntrRepeater(Dcm_OpStatusType opStatus
                                                                     ,Dcm_ReadOnlyMsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc27RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType  lResult;
  uint32          lMask = Dcm_UtiGetBitFromIndex(uint32, pRepContext->SecLvlRef);

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Notify the application about the new attempt counter value */
  Dcm_Svc27UtiSetAttemptCntr(opStatus, &lMask);                                                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

  /* If the setting of the attempt counter was successful: */
  if(lMask == 0)
  {
    /* Finish the job */
    if (pRepContext->ErrorCode == DCM_E_POSITIVERESPONSE)
    {
      lResult = DCM_E_OK;
    }
    else
    {
      *ErrorCode = pRepContext->ErrorCode;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = DCM_E_NOT_OK;
    }
  }
  else
  {
    /* Otherwise try it later */
    lResult = DCM_E_PENDING;
  }

  return lResult;
}
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc28SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc28SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc28SubFuncInfoGetEntryOrNull(
                                                                                Dcm_DiagSubServiceRefOptType SubSvcRef)
{
  Dcm_CfgSvc28SubFuncInfoPtrType lSubFuncInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SubSvcRef >= DCM_CFGSVC28SUBFUNCINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC28SUBFUNCINFOGETENTRY);
    lSubFuncInfo = NULL_PTR;
  }
  else
# endif
  {
    lSubFuncInfo = &Dcm_CfgSvc28SubFuncInfo[SubSvcRef];
  }

  return lSubFuncInfo;
}

/**********************************************************************************************************************
 *  Dcm_Svc28Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc28Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc28RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Prepare all generic part (independently of the SF validation result!) */
# if (DCM_SVC_28_USER_ENABLED == STD_ON)
  pRepContext->IsInternallyProcessed = FALSE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
# endif
  pRepContext->SubServiceId = Dcm_DiagGetReqDataAsU8(pMsgContext);                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                            ,Dcm_CfgSvc28SubFuncLookUpTable
                                            ,Dcm_CfgSvc28SubFuncExecPrecondTable
                                            ,Dcm_Svc28ReqLengthGetter
                                            ,&lSubSvcRef                                                                                             /* SBSW_DCM_CALL_VERIFY_SERVICE_WITH_SUBFUNCTION */
                                            ,ErrorCode);

  pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)(lSubSvcRef);                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

  if (lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(DCM_SVC28_PROGRESS_SUBFUNCTION); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc28SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc28SubFuncHandler(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc28RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_CfgSvc28SubFuncInfoPtrType pSubFuncInfo;

  pSubFuncInfo = Dcm_CfgSvc28SubFuncInfoGetEntryOrNull(pRepContext->SubSvcRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSubFuncInfo == NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(opStatus, pMsgContext, ErrorCode);                                                                         /* SBSW_DCM_CALL_FUNCPTR_SVC28SUBFUNC */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc28ApplyCommControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc28ApplyCommControl(Dcm_CfgNetNetIdRefMemType networkRef
                                                               ,Dcm_CommunicationModeType mode)
{
  DCM_IGNORE_UNREF_PARAM(networkRef);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if ((DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_28_SUBNET_SUPPORT_ENABLED == STD_ON) ) && \
     (DCM_NET_COMCTRL_ALLNET_SUPPORT_ENABLED == STD_ON)                                                                                              /* COV_DCM_SUPPORT_PARTIALLY TF tf xf tf */
  if(networkRef == DCM_SVC_28_NETWORK_ALL)
# endif
  {
# if (DCM_NET_COMCTRL_ALLNET_SUPPORT_ENABLED == STD_ON)
    uint8_least lChannelIter;

    for(lChannelIter = Dcm_PbCfgNetComCtrlChannelListAll[0]; lChannelIter != 0; --lChannelIter)
    {
      Dcm_ModeSwitchCommControl(Dcm_PbCfgNetComCtrlChannelListAll[lChannelIter], mode);
    }
# endif
  }
# if ((DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_28_SUBNET_SUPPORT_ENABLED == STD_ON) ) && \
     (DCM_NET_COMCTRL_ALLNET_SUPPORT_ENABLED == STD_ON)                                                                                              /* COV_DCM_SUPPORT_PARTIALLY TF tf xf tf */
  else
# endif
  {
# if (DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_28_SUBNET_SUPPORT_ENABLED == STD_ON)                                                                                                   /* COV_DCM_SUPPORT_PARTIALLY TF tf xf */
    Dcm_ModeSwitchCommControl(networkRef, mode);
# endif
  }
}
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdNextEntryIdxInc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdNextEntryIdxInc(void)
{
# if (DCM_SVC_2A_SCHEDULER_SIZE_CONST > 1)
  ++Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NextEntryIdx;
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NextEntryIdx >= DCM_SVC_2A_SCHEDULER_SIZE)
# endif
  {
    /* Write always zero (also when only one scheduler element exists, to keep the safe aspect when the wrap-around is detected */
    Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NextEntryIdx = 0u;
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdUpdateTimers()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdUpdateTimers(void)
{
  boolean doActivateProcessorTask = FALSE;
  Dcm_Svc2ASchdItemHandleOptType schdIter;
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  Dcm_Svc2ASchedRateOptType lFastestRate = 0;
# endif

  for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
  {
    if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Timer != 0u)
    {
      --Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Timer;
      if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Timer == 0u)
      {
        if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate < DCM_SVC2A_RATE_TYPE_STOPPED) /* is it scheduled ? */
        {
          doActivateProcessorTask = TRUE;
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
          if (Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate > lFastestRate)
          {
            lFastestRate = Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate;
          }
# endif
        }
      }
    }
  }
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  Dcm_NetPeriodicMsgSetFastestRate(lFastestRate);
# endif
  return doActivateProcessorTask;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFindFreeOrInUseItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint16_least, DCM_CODE) Dcm_Svc2ASchdFindFreeOrInUseItemByDid(uint16 did)
{
  Dcm_Svc2ASchdItemHandleOptType schdIter;
  sint16_least firstFreePos = -1;

  for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
  {
    if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate == DCM_SVC2A_RATE_TYPE_STOPPED)
    {
      if(firstFreePos < 0)
      {
        firstFreePos = (sint16_least)schdIter;      /* reserve first found free slot */
      }/* else - already set */
    }
    else if(did == Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].DidContext.Did)
    {
      firstFreePos = (sint16_least)schdIter; /* found already in used or just reserved DID -> use the same slot */
      break;
    }
    else
    {
      /* do nothing */
    }
  }
  return firstFreePos;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdProcessEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdProcessEntry(Dcm_Svc2ASchdEntryPtrType pSchedTableEntry)
{
  boolean doSendData = FALSE;

  /* allocate buffer for response data */
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle == DCM_NET_INVALID_PTXOBJ_HANDLE)/* still nothing reserved for this DID ? */
  {
    Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle = Dcm_NetPeriodicMsgAllocate(pSchedTableEntry->DidContext.Did);
    if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle == DCM_NET_INVALID_PTXOBJ_HANDLE)
    {
      /* no free message buffer try again later */
      return DCM_E_PENDING; /* exit loop and task */
    }
  }

  /* Allocate DID manager resource */
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr == NULL_PTR)
  {
# if (DCM_DIDMGR_2A_ACCESS_LOCK_ENABLED == STD_ON)
    uint16 lDid = pSchedTableEntry->DidContext.Did;

    if( (lDid == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce)
#  if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
      ||(lDid == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic)
#  endif
#  if (DCM_DIDMGR_PERIODICWRITEDID_ENABLED == STD_ON)
      ||(lDid == Dcm_InstanceContext.DidMgr.DidRsrcContext.Write)
#  endif
#  if (DCM_DIDMGR_PERIODICIODID_ENABLED == STD_ON)
      ||(lDid == Dcm_InstanceContext.DidMgr.DidRsrcContext.Io)
#  endif
      )
    {
      /* DID is currently locked - try again later */
      return DCM_E_PENDING; /* exit loop and task */
    }
    Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadPeriodic = lDid;
# endif
    Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr = &(pSchedTableEntry->DidContext);
    /* prepare first time reading */
# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.OpStatus = DCM_INITIAL;
# endif

    Dcm_NetPeriodicMsgGetTxBuffer(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle)[0] =
      Dcm_UtiGetLoByte(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr->Did); /* copy did header */                                  /* PRQA S 0504 */ /* MD_Dcm_QacIssue_0504 */
  }

  /* read the response data */
  {
    Std_ReturnType               lStdResult;
    Dcm_NegativeResponseCodeType lNrc; /* unused since no NR possible */
    Dcm_DiagDataContextType      lDataContext;

    Dcm_DiagInitDataContext(&lDataContext
                           ,&Dcm_NetPeriodicMsgGetTxBuffer(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle)[1]
                           ,(Dcm_MsgLenType)(DCM_NET_PERIODIC_BUFFER_SIZE - 1u));

    lStdResult = Dcm_DidMgrReadDid(Dcm_DidMgrWrapAsyncDidOpStatus(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.OpStatus)
                                  ,&lDataContext
                                  ,Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr
                                  ,&(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidOpTypeContext)
                                  ,&lNrc);
    if(lStdResult == DCM_E_OK)
    {
      doSendData = TRUE; /* now the response can be sent */
    }
    else
# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    if(lStdResult == DCM_E_PENDING)
    {
      Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.OpStatus = DCM_PENDING; /* prepare for next call */
      return DCM_E_PENDING;
    }
    else
# endif
    {
      /* DCM_E_NOT_OK */
      /* something went wrong - skip this DID */
    }
  }

  /* reload the period timer from now on (see ISO14229-1 SID 0x2A scheduler example) */
  /*
   * No critical section for split tasks needed since:
   * - The timer that just has been processed is already stopped and will not be decrement in the Dcm_Svc2ASchdUpdateTimers utility.
   * - This tasks is a low-priority one and cannot interrupt the timer task (Dcm_OnTimeoutSvc2AScheduler). So setting a non-zero value will not be an issue.
   */
  pSchedTableEntry->Timer = Dcm_Svc2AGetSchedulingTimeOfEntry(pSchedTableEntry);

  /* Finish scheduled job */
  Dcm_Svc2ASchdFinishEntryProcessing(doSendData);

  return DCM_E_OK;
}                                                                                                                                                    /* PRQA S 2006 */ /* MD_Dcm_Optimize_2006 */
/**********************************************************************************************************************
 *  Dcm_Service2ASchedulerInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Service2ASchedulerInit(void)
{
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr = NULL_PTR;
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries = 0u;
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NextEntryIdx = 0u;
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle = DCM_NET_INVALID_PTXOBJ_HANDLE;

  {
    Dcm_Svc2ASchdItemHandleOptType schdIter;

    for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
    {
      Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Timer = 0u;
      Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate = DCM_SVC2A_RATE_TYPE_STOPPED;
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdAddItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdAddItemByDid(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext)                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  sint16_least schdHandle;
  schdHandle = Dcm_Svc2ASchdFindFreeOrInUseItemByDid(pDidInfoContext->Did);
  /* there shall always be free room when this function is called, otherwise check the SID 0x2A processor */
  Dcm_DebugAssert((schdHandle >=0), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                           /* COV_DCM_RTM_DEV_DEBUG XF */

  Dcm_UtiAssignStruct(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdHandle].DidContext                                                 /* PRQA S 0310 */ /* MD_Dcm_GenericStructAssign_0310 */
                     ,*pDidInfoContext);                                                                                                             /* PRQA S 3109 */ /* MD_Dcm_CfgDepend_3109 */
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdHandle].Rate |= DCM_SVC2A_RATE_TYPE_RESERVED;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCommit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdCommit(Dcm_Svc2ASchedRateMemType rate)
{
  Dcm_Svc2ASchdItemHandleOptType schdIter;

  Dcm_SplitTaskEnterCS();/* protect against timer task update */                                                                                     /* PRQA S 3109 */ /* MD_MSR_14.3 */

  for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
  {
    if((Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate & DCM_SVC2A_RATE_TYPE_RESERVED) != 0)
    {
      if((Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate & DCM_SVC2A_RATE_TYPE_STOPPED) != 0)
      {
        ++Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries; /* update statistic of first activation of this DID */
      }
      /* must not exceed the scheduler size */
      Dcm_DebugAssert((Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries <= DCM_SVC_2A_SCHEDULER_SIZE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE) /* COV_DCM_RTM_DEV_DEBUG XF */
      Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate = rate; /* set the new rate */
      Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Timer = 0u; /* enforce immediate timeout */
    }
  }
  Dcm_SplitTaskLeaveCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
# if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
    Dcm_TmrStartTimer(DCM_TMR_ID_SVC2A_SCHEDULER, 1u);/* start timer updater */
# endif
    Dcm_TskSetEvent(DCM_TSK_ID_SVC2A_SCHEDULER, (Dcm_TskTaskEvMemType)(DCM_TSK_EV_SVC2A_SCHEDULER_TMR_UPD|DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS));/* start updating the timers/processing new DIDs */
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdDiscard()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdDiscard(void)
{
  Dcm_Svc2ASchdItemHandleOptType schdIter;

  for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
  {
    Dcm_UtiBitOpClr(Dcm_Svc2ASchedRateMemType, Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate, DCM_SVC2A_RATE_TYPE_RESERVED); /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
  }
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2AStoppedDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStoppedDidLookUp(Dcm_OpStatusType      opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  lStdReturn = Dcm_Svc2ADidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);

  if(lStdReturn == DCM_E_OK)
  {
    Dcm_Svc2ASchdStopItemByDid(pRepContext->DidInfoContext.Did);
    lStdReturn = DCM_E_LOOP;/* go on with the next DID  */
  }
  else if (lStdReturn == DCM_E_PROCESSINGDONE)
  {
    lStdReturn = DCM_E_OK;
  }
  else
  {
    /* DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set), DCM_E_LOOP */
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AScheduledDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AScheduledDidLookUp(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  lStdReturn = Dcm_Svc2ADidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);

  if(lStdReturn == DCM_E_OK)
  {
    lStdReturn = Dcm_DidMgrDynDidStateCheck(&(pRepContext->DidInfoContext), ErrorCode);
    if (lStdReturn == DCM_E_OK)
    {
      /* Proceed with next validation step */
# if (DCM_DIDMGR_PERIODICDID_CHK_COND_ENABLED == STD_ON)
      Dcm_RepeaterNextStep(DCM_SVC2A_PROGRESS_DID_CHECKCONDITION); /* next job */
# else
      Dcm_RepeaterNextStep(DCM_SVC2A_PROGRESS_DID_GETLENGTH); /* next job */
# endif
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    } /* else DCM_E_NOT_OK (ErrorCode already set) */
  }
  else if (lStdReturn == DCM_E_PROCESSINGDONE)
  {
    lStdReturn = DCM_E_OK;
  }
  else
  {
    /* DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set), DCM_E_LOOP */
  }

  return lStdReturn;
}

# if (DCM_DIDMGR_PERIODICDID_CHK_COND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ADidCheckCondition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidCheckCondition(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
#  if (DCM_DIDMGR_PERIODICDID_CHK_COND_ALL_ENABLED == STD_OFF)
  if(Dcm_DidMgrIsOpTypeSupported(pRepContext->DidInfoContext.Descriptor.DidOpInfoPtr, DCM_DIDMGR_OPTYPE_READCHKCOND))
#  endif
  {
    Std_ReturnType               lStdResult;

    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_Dcm_3112 */

    /* check condition on this DID */
    Dcm_DidMgrGetOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READCHKCOND);
    lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                        ,&(pRepContext->DidInfoContext)
                                        ,&(pRepContext->DidOpTypeContext)
                                        ,ErrorCode);

    if(lStdResult == DCM_E_OK)
    {
      /* DCM_E_OK - go on with next DID */
    }
    else
#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    if(lStdResult == DCM_E_PENDING)
    {
      return DCM_E_PENDING;
    }
    else
#  endif
    {
      /* DCM_E_NOT_OK */
      return DCM_E_NOT_OK; /* finish service processing immediately */
    }
  }/* else - not supported operation - go on with getLength */

  Dcm_RepeaterNextStep(DCM_SVC2A_PROGRESS_DID_GETLENGTH);
  return DCM_E_LOOP;/* speed up processing */
}                                                                                                                                                    /* PRQA S 2006 */ /* MD_Dcm_Optimize_2006 */
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ADidGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidGetLength(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* calculate DID data length */
# if (DCM_DIDMGR_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
  /* read length */
  {
    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,&(pRepContext->DidInfoContext)
                                     ,ErrorCode);
  }/* else - static length */

  if(lStdReturn == DCM_E_OK)
# endif
  {
    /* check for buffer overrun */
    if (pRepContext->DidInfoContext.DidLength > DCM_SVC2A_MAX_RESPONSE_LEN) /* the buffer shall accept the periodic DID + data */
    {
      *ErrorCode = DCM_E_RESPONSETOOLONG; /* the configured buffer will not be able to hold all of the data -> notify the client */                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    }
    else
    {
      /* Add scheduler job */
      Dcm_DidMgrGetOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READ);/* set the operation now since not changed later */

      Dcm_Svc2ASchdAddItemByDid(&pRepContext->DidInfoContext);

      Dcm_RepeaterNextStep(DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP);
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    }
  }/* else - DCM_E_PENDING, DCM_E_NOT_OK */

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AStopScheduledDids()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStopScheduledDids(Dcm_MsgContextPtrType pMsgContext)                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdReturn = DCM_E_OK;
  if(pMsgContext->reqDataLen == 0u)
  {
    Dcm_Svc2ASchdStopAll();
  }
  else
  {
    Dcm_RepeaterNextStep(DCM_SVC2A_PROGRESS_STOPPED_DID_LOOKUP); /* delegate job */
    lStdReturn = DCM_E_LOOP;/* speed up processing */
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ADoScheduleDids()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADoScheduleDids(Dcm_MsgContextPtrType pMsgContext                                            /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                       ,Dcm_NegativeResponseCodePtrType ErrorCode)                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdReturn = DCM_E_NOT_OK;

  if(pMsgContext->reqDataLen == 0) /* no DID available in the request */
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else if(pMsgContext->reqDataLen > Dcm_Svc2ASchdGetFreeSpace())  /* not enough room in the scheduler table (don't consider duplicates and unsupported DIDs in the request -> apply KISS) */
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    Dcm_RepeaterNextStep(DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP); /* delegate job */
    lStdReturn = DCM_E_LOOP;/* speed up processing */
  }

  /* Reaching this point means diagnostic error was found */
  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pRepContext->ConnId = Dcm_DiagGetTranspObj()->ConnId;

# if(DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  /* protected by the session connection ownership */
# else
  if ((Dcm_NetPeriodicMsgGetConnection() != DCM_NET_INVALID_CONNID)
    && (pRepContext->ConnId != Dcm_NetPeriodicMsgGetConnection()))
  {
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT; /* the 2A service is currently in use by another client */                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
# if (DCM_NET_PERIODIC_TX_CONN_SPECIFIC_NUM_TX_OBJ_ENABLED == STD_ON)
    if (!Dcm_NetPeriodicMsgSupportedFor(Dcm_DiagGetTranspObj()->ConnId))
    {
      *ErrorCode = DCM_E_PANIC_NRC; /* current client does not support periodic messages */                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
# endif
    {
      pRepContext->HasAnySupportedDids = FALSE;
      Dcm_DiagConsumeReqDataAsU8(pMsgContext, &(pRepContext->UdsRate));                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */

      if (pMsgContext->reqDataLen <= DCM_SVC_2A_MAX_DID_LIST_LEN)
      {
        if ((pRepContext->UdsRate <= 4u)
          && ((DCM_SVC_2A_SUPPORTED_RATES & Dcm_UtiGetBitFromIndex(uint8, pRepContext->UdsRate)) != 0))
        {
          if (pRepContext->UdsRate != 4u)
          {
            lStdReturn = Dcm_Svc2ADoScheduleDids(pMsgContext, ErrorCode);
          }
          else
          {
            lStdReturn = Dcm_Svc2AStopScheduledDids(pMsgContext);
          }
        }
        else
        {
          *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdReturn = DCM_E_NOT_OK;
        }
      }
      else
      {
        *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdReturn = DCM_E_NOT_OK;
      }
    }

  return lStdReturn;
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrInit(void)
{
  Dcm_CfgDidMgrDynDidHandleOptType dynDidIter;

  for(dynDidIter = 0; dynDidIter < DCM_NUM_DYNDIDS; ++dynDidIter)
  {
    Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidIter].Length = 0u;
    Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidIter].Count  = 0u;
  }

# if (DCM_DIDMGR_DYNDID_ASYNC_SUPPORT_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse = DCM_SVC2C_INVALID_DYNDID_HDL;
# endif
# if(DCM_DEV_ERROR_REPORT == STD_ON)
  Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer[DCM_SVC_2C_READ_BUFFER_SIZE + 0] = Dcm_UtiGetHiByte(DCM_DEBUG_BUFFEROVFLPATTERN);
  Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer[DCM_SVC_2C_READ_BUFFER_SIZE + 1] = Dcm_UtiGetLoByte(DCM_DEBUG_BUFFEROVFLPATTERN);
# endif
}

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01DefMgrRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01DefMgrRead(Dcm_OpStatusType opStatus
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyOffset
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyLength)
{
  Std_ReturnType lStdResult;

#  if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
  lStdResult = DCM_E_OK;

  if(Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic == 0u)
  {
#   if (DCM_SVC_2C_CANCELOP_READ_ENABLED == STD_ON)
    if(opStatus == DCM_CANCEL)
    {
      /* we have waited for too long to get access to the DID reader, but it was canceled -> Stop here since no reading has been started yet */
      lStdResult = DCM_E_NOT_OK;
    }
    else
#   endif
    /* Check for access rights (avoids race conditions) */
    if( (Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.DidContext.Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadPeriodic)
#   if (DCM_DIDMGR_2E_ACCESS_LOCK_ENABLED == STD_ON)
      ||(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.DidContext.Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.Write )
#   endif
#   if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
      ||(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.DidContext.Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce )
#   endif
#   if (DCM_DIDMGR_2F_ACCESS_LOCK_ENABLED == STD_ON)
      ||(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.DidContext.Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.Io )
#   endif
      /* no periodic DID is a writable or IO DID -> no need to check for race conditions! */
      )
    {
      lStdResult = DCM_E_PENDING;
    }
    else
    {
      /* Continue processing of source item */
      Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic = Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.DidContext.Did;
      opStatus = DCM_INITIAL; /* prepare for first reading */
    }
  }

  if(lStdResult == DCM_E_OK)
#  endif
  {
    Dcm_NegativeResponseCodeType lNrc;
    Dcm_DiagDataContextType      lDataContext;

    Dcm_DidMgrGetOpClassInfo(&(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.DidContext)
                            ,DCM_DIDMGR_OPTYPE_READ);

    Dcm_DiagInitDataContext(&lDataContext
                           ,Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer
                           ,DCM_SVC_2C_READ_BUFFER_SIZE);

    lStdResult = Dcm_DidMgrReadDid(opStatus
                                  ,&lDataContext
                                  ,&(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.DidContext)
                                  ,&(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].DidOpTypeContext)
                                  ,&lNrc);

    Dcm_DebugAssert((  (Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer[DCM_SVC_2C_READ_BUFFER_SIZE + 0] == Dcm_UtiGetHiByte(DCM_DEBUG_BUFFEROVFLPATTERN))
                     &&(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer[DCM_SVC_2C_READ_BUFFER_SIZE + 1] == Dcm_UtiGetLoByte(DCM_DEBUG_BUFFEROVFLPATTERN)) )
                    ,DCM_SID_SVCPORT_DATASVCS_OP_READDATA_ASYNC
                    ,DCM_E_ILLEGAL_STATE)                                                        /* no data has been overwritten */

    /* Finished processing a DIDSrcItem */
    if(lStdResult != DCM_E_PENDING)
    {
      *pCopyOffset = Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.Offset;
      *pCopyLength = Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.Size;
#  if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
      Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic = 0u;
#  endif
    }
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C02DefMgrRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C02DefMgrRead(Dcm_OpStatusType opStatus
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyOffset
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyLength)
{
  Std_ReturnType lStdResult;

#  if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  lStdResult = DCM_E_OK;

  if(Dcm_InstanceContext.MemMgr.LockedByClient == DCM_MEMMGR_ACCESS_REQ_INT)
  {
    /* Proceed with reading */
  }
  else
  {
    /* Still in process getting access! */
#   if (DCM_SVC_2C_CANCELOP_READ_ENABLED == STD_ON)
    if(opStatus == DCM_CANCEL)
    {
      lStdResult = DCM_E_NOT_OK;/* we have waited for too long to get access to the memory reader, but it was canceled -> Stop here since no reading has been started yet */
    }
    else
#   endif
    {
      if(Dcm_InstanceContext.MemMgr.LockedByClient == DCM_MEMMGR_ACCESS_NONE)
      {
        Dcm_InstanceContext.MemMgr.LockedByClient = DCM_MEMMGR_ACCESS_REQ_INT;
        opStatus = DCM_INITIAL; /* prepare for first reading */
      }
      else /* DCM_MEMMGR_ACCESS_REQ_EXT */
      {
        lStdResult = DCM_E_PENDING;
      }
    }
  }

  if(lStdResult == DCM_E_OK)
#  endif
  {
    Dcm_NegativeResponseCodeType lNrc;

    lStdResult = Dcm_MemMgrReadMemory(opStatus
                                    ,&(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].MemDescriptor.MemBlock)
                                    ,Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer
                                    ,&lNrc);

    if( (lStdResult != DCM_E_PENDING)
      &&(lStdResult != DCM_E_FORCE_RCRRP))
    {
      /* OK/NOT_OK -> proceed */
      *pCopyOffset = 0u;
      *pCopyLength = (Dcm_CfgNetBufferSizeOptType)Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].MemDescriptor.MemBlock.Length; /* safe cast sin the code has already checked for overflows at DID definition time */
    }
    DCM_IGNORE_UNREF_PARAM(lNrc);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadSrcItems()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadSrcItems(Dcm_OpStatusType opStatus)
{
  Std_ReturnType lStdReturn;

  Dcm_CfgNetBufferSizeOptType copyOffset = 0;
  Dcm_CfgNetBufferSizeOptType copyLength = 0;

  do
  {
# if (DCM_SVC_2C_HYBRID_MODE_ENABLED == STD_ON)
    if(Dcm_Svc2CIsDidSrcItem(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress))
# endif
    {
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
     /*-----------------------------------------------*
      * DID source item processing
      *-----------------------------------------------*/
      lStdReturn = Dcm_Svc2C01DefMgrRead(opStatus, &copyOffset, &copyLength);
# endif
    }
# if (DCM_SVC_2C_HYBRID_MODE_ENABLED == STD_ON)
    else
# endif
    {
# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
      /*-----------------------------------------------*
       * Memory source item processing
       *-----------------------------------------------*/
      lStdReturn = Dcm_Svc2C02DefMgrRead(opStatus, &copyOffset, &copyLength);
# endif
    }

    /*-----------------------------------------------*
     * Common source item processing
     *-----------------------------------------------*/
    if(lStdReturn == DCM_E_OK)
    {
      /* extract and place data */
      Dcm_UtiMemCopy(&Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer[copyOffset]
                     ,Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ResData
                     ,copyLength);                                                                                                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */

      /* prepare for next portion */
      Dcm_UtiNextItemByPtr(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ResData, copyLength);

      /*-----------------------------------------------*
       * Loop end condition
       *-----------------------------------------------*/
      ++Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress;
      if(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress >= Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemToStop)
      {
        break;
      }
      /* prepare for next item */
      opStatus = DCM_INITIAL;
    }/* else just delegate the return value */
  }
  while(lStdReturn == DCM_E_OK);

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadCheckAccessAndInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadCheckAccessAndInit(
                                                              Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
                                                             ,P2VAR(Dcm_OpStatusType, AUTOMATIC, AUTOMATIC) pOpStatus)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(dynDidHandle);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pOpStatus);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /*-----------------------------------------------*
   * DynDID usage check and initialization
   *-----------------------------------------------*/
# if (DCM_DIDMGR_DYNDID_ASYNC_SUPPORT_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse == DCM_SVC2C_INVALID_DYNDID_HDL)
  {
#  if (DCM_SVC_2C_CANCELOP_READ_ENABLED == STD_ON)
    if(*pOpStatus == DCM_CANCEL)
    {
      lStdResult = DCM_E_NOT_OK;/* we have waited for too long to get access to the DynDID reader, but it was canceled -> Stop here since no reading has been started yet */
    }
    else
#  endif
    {
      *pOpStatus = DCM_INITIAL;/* Reset opStatus in case some DCM_E_PENDING had to be returned due to concurrent access (i.e. 0x22 and 0x2A for different DDDIDs) */
    }
  }
  else
  {
#  if (DCM_SVC_2C_RACE_CONDITION_READ_ENABLED == STD_ON)
    if(dynDidHandle != Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse)
    {
      lStdResult = DCM_E_PENDING;
    }/* else - same handle -> process it */
#  endif
  }
# endif
  return lStdResult;
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_CfgSvc2CSubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc2CSubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc2CSubFuncInfoGetEntryOrNull(
                                                                               Dcm_DiagSubServiceRefOptType SubSvcRef)
{
  Dcm_CfgSvc2CSubFuncInfoPtrType lSubFuncInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SubSvcRef >= DCM_CFGSVC2CSUBFUNCINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC2CSUBFUNCINFOGETENTRY);
    lSubFuncInfo = NULL_PTR;
  }
  else
# endif
  {
    lSubFuncInfo = &Dcm_CfgSvc2CSubFuncInfo[SubSvcRef];
  }

  return lSubFuncInfo;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc2CSubFuncLookUpTable
                                                   ,Dcm_CfgSvc2CSubFuncExecPrecondTable
                                                   ,Dcm_Svc2CReqLengthGetter
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)(lSubSvcRef);

    /* Perform SID specific checks */
    if (Dcm_CfgSvc2CSubFuncInfo[(pRepContext->SubSvcRef)].MinReqLength <= pMsgContext->reqDataLen) /* min length = (DDID, (MEMdef|DIDdef))?  */
    {
      Dcm_RepeaterNextStep(DCM_SVC2C_PROGRESS_SUBFUNCTION); /* delegate job */
      lStdResult = DCM_E_LOOP;/* speed up processing */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }  /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CSubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CSubFuncHandler(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_CfgSvc2CSubFuncInfoPtrType pSubFuncInfo;

  pSubFuncInfo = Dcm_CfgSvc2CSubFuncInfoGetEntryOrNull(pRepContext->SubSvcRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSubFuncInfo == NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(opStatus, pMsgContext, ErrorCode);
  }

  return lStdResult;
}

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidLookUp(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  if(opStatus == DCM_INITIAL)
  {
     /* Extract source DID */
    Dcm_DiagConsumeReqDataAsU16(pMsgContext, &(pRepContext->SrcItemPtr->DidDescriptor.DidContext.Did));                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pRepContext->SrcItemPtr->DidDescriptor.DidContext)
                                   ,&(pRepContext->DynDidOpTypeContext) /* Use OpTypeContext of DynDID since no more needed at this time! */
                                   ,DCM_DIDMGR_OP_READ);

  if(lStdReturn == DCM_E_OK)
  {
    if(!Dcm_DidMgrIsOpSupported(pRepContext->SrcItemPtr->DidDescriptor.DidContext.Descriptor.DidInfoPtr, DCM_DIDMGR_OP_DEFINE))
    {
      lStdReturn = Dcm_StateCheck(pRepContext->SrcItemPtr->DidDescriptor.DidContext.Descriptor.DidOpInfoPtr->ExecCondRef, DCM_DIAG_CHK_LVL_PARAMETER, ErrorCode);
      if(lStdReturn == DCM_E_OK)
      {
#  if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
        Dcm_RepeaterNextStep(DCM_SVC2C_PROGRESS_01SRC_DIDCHECKCONDITIONS); /* next job */
#  else
        Dcm_RepeaterNextStep(DCM_SVC2C_PROGRESS_01SRC_DIDGETLENGTH); /* next job */
#  endif
        lStdReturn = DCM_E_LOOP;
      }
      else
      {
        /* else - at least one source DID fails under current ECU conditions - ErrorCode already set */
        lStdReturn = DCM_E_NOT_OK;
      }
    }
    else
    {
      /* else - no DynDID may be referenced! */
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
  }
  else if(lStdReturn == DCM_E_PENDING)
  {
    /* lStdReturn is already set */
  }
  else
  {
    /* else - source DID is not supported */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }

  return lStdReturn;
}
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON) && \
     (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidCheckCondition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidCheckCondition(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
#  if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ALL_ENABLED == STD_OFF)
  if (Dcm_DidMgrIsOpTypeSupported(pRepContext->SrcItemPtr->DidDescriptor.DidContext.Descriptor.DidOpInfoPtr, DCM_DIDMGR_OPTYPE_READCHKCOND))
#  endif
  {
    Std_ReturnType               lStdResult;

    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_Dcm_3112 */

    /* check condition on this DID */
    Dcm_DidMgrGetOpClassInfo(&(pRepContext->SrcItemPtr->DidDescriptor.DidContext), DCM_DIDMGR_OPTYPE_READCHKCOND);
    lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                        ,&(pRepContext->SrcItemPtr->DidDescriptor.DidContext)
                                        ,&(pRepContext->DynDidOpTypeContext)  /* Use OpTypeContext of DynDID since no more needed at this time! */
                                        ,ErrorCode);

    if(lStdResult == DCM_E_OK)
    {
      /* DCM_E_OK - go on with next operation */
    }
    else
#  if (DCM_DIDMGR_STATIC_DID_ASYNC_SUPPORT_ENABLED == STD_ON)
    if(lStdResult == DCM_E_PENDING)
    {
      return DCM_E_PENDING;
    }
    else
#  endif
    {
      return DCM_E_NOT_OK; /* finish service processing immediately */
    }
  }/* else - not supported operation - go on with getLength */

  Dcm_RepeaterNextStep(DCM_SVC2C_PROGRESS_01SRC_DIDGETLENGTH); /* next job */
  return DCM_E_LOOP;/* speed up processing */
}                                                                                                                                                    /* PRQA S 2006 */ /* MD_Dcm_Optimize_2006 */
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidGetLength(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* calculate DID data length */
#  if (DCM_DIDMGR_STATIC_DID_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
  /* read length */
  {
    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,&(pRepContext->SrcItemPtr->DidDescriptor.DidContext)
                                     ,ErrorCode);

   /* DCM_E_PENDING, DCM_E_OK or DCM_E_NOT_OK (ErrorCode already set) */
  }/* else - static length */

  if(lStdReturn == DCM_E_OK)
#  endif
  {
    uint8 srcDidPos;
    uint8 srcDidSize;

    Dcm_DiagConsumeReqDataAsU8(pMsgContext, &srcDidPos);                                                                                             /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    Dcm_DiagConsumeReqDataAsU8(pMsgContext, &srcDidSize);                                                                                            /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

    /* else - check for definition length overflow */
#  if (DCM_SVC_2C_READ_BUFFER_SIZE < 255u)
    if(srcDidSize > DCM_SVC_2C_READ_BUFFER_SIZE)
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;/* too much data referenced for temporary read buffer */                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    }
    else
#  endif
    if ((srcDidPos == 0u)
      ||((srcDidPos + srcDidSize - 1u) > pRepContext->SrcItemPtr->DidDescriptor.DidContext.DidLength) )
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;/* source DID referenced data out of boundary  */                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    }/* check for possible read buffer or response overflow */
    else if ((!Dcm_UtiIsAdditionSafe(uint16, pRepContext->DynDidLength, srcDidSize))
      || (Dcm_UtiPromotedSum(uint16, pRepContext->DynDidLength, srcDidSize) > pRepContext->MaxAllowedLength))
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;/* too much data referenced  */                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    }
    else/* Add this DID to the definition */
    {
      /* update total length of the DynDID for commitment */
      pRepContext->DynDidLength += srcDidSize;

      /* store referenced data */
      pRepContext->SrcItemPtr->DidDescriptor.Offset = (uint8)(srcDidPos - 1u);
      pRepContext->SrcItemPtr->DidDescriptor.Size = srcDidSize;
      Dcm_Svc2CSetDidSrcItem(pRepContext->SrcItemIndex); /* set the type of the source item to DID */

      Dcm_UtiNextItemByPtr(pRepContext->SrcItemPtr, 1u); /* next item ref */
      ++(pRepContext->SrcItemIndex); /* next item to be configured */
      ++(pRepContext->DynDidItemCount); /* update number of items for commitment */

      --(pRepContext->ReqNumOfItems);/* commit processed item */
      if (pRepContext->ReqNumOfItems != 0u) /* any left items? */
      {
        Dcm_RepeaterNextStep(DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP); /* next job */
        lStdReturn = DCM_E_LOOP;/* speed up processing */
      }
      else
      {
        lStdReturn = DCM_E_OK; /* all source items finished service processing immediately */
      }
    }
  }
  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_03DidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_03DidLookUp(Dcm_OpStatusType      opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  if(opStatus == DCM_INITIAL)
  {
    Dcm_DiagConsumeReqDataAsU16(pMsgContext, &pRepContext->DynDidInfoContext.Did);                                                                   /* SBSW_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResDataAsU16(pMsgContext, pRepContext->DynDidInfoContext.Did); /* positive response contains the DynDID (2Byte) */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&pRepContext->DynDidInfoContext
                                   ,&pRepContext->DynDidOpTypeContext
                                   ,DCM_DIDMGR_OP_DEFINE);

  if(lStdReturn == DCM_E_OK)
  {
    /* clear concrete DynDID */
    Dcm_Svc2CDefMgrClear((Dcm_CfgDidMgrDynDidHandleMemType)(pRepContext->DynDidInfoContext.Descriptor.DidInfoPtr->OpRef));
  }
  else if(lStdReturn == DCM_E_PENDING)
  {
    /* lStdReturn is already set */
  }
  else
  { /* DCM_E_NOT_OK */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  return lStdReturn;
}
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2EHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc2ERepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  if (opStatus == DCM_INITIAL)
  {
    /* Min Length already checked in DiagDispatcher and expected to be 3 !!! */
    Dcm_DiagConsumeReqDataAsU16(pMsgContext, &(pRepContext->DidInfoContext.Did));                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdResult = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pRepContext->DidInfoContext)
                                   ,&(pRepContext->DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_WRITE);

  if (lStdResult == DCM_E_OK)
  {
    Dcm_DiagProvideResData(pMsgContext, 2u);/* return the DID (shared Rx-Tx buffer) */                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Check DID specific length */
# if (DCM_DIDMGR_WRITE_DYNLEN_DID_SUPPORT_ENABLED == STD_ON)
    if ((0 < pMsgContext->reqDataLen) /* cover the case where a DID with dynamic length has only one data element (i.e. DidInfoPtr->Length == 0) */
      && (pRepContext->DidInfoContext.Descriptor.DidInfoPtr->MinLength <= pMsgContext->reqDataLen)
      && (pRepContext->DidInfoContext.Descriptor.DidInfoPtr->Length >= pMsgContext->reqDataLen))
# else
    if (pRepContext->DidInfoContext.Descriptor.DidInfoPtr->Length == pMsgContext->reqDataLen)
# endif
    {
      lStdResult = Dcm_DidMgrStaticDidStateCheck(pRepContext->DidInfoContext.Descriptor.DidOpInfoPtr->ExecCondRef, ErrorCode);
      if (lStdResult == DCM_E_OK)
      {
        Dcm_DidMgrGetOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_WRITE);
# if (DCM_DIDMGR_2E_ACCESS_LOCK_ENABLED == STD_ON)
        Dcm_RepeaterNextStep(DCM_SVC2E_PROGRESS_CHECKACCESS); /* delegate job */
# else
        Dcm_RepeaterNextStep(DCM_SVC2E_PROGRESS_ECECUTEOP); /* delegate job */
# endif
        lStdResult = DCM_E_LOOP;/* speed up processing */
      } /* else DCM_E_NOT_OK - ErrorCode already assigned */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }
  else if (lStdResult == DCM_E_PENDING)
  {
    /* DCM_E_PENDING -> try again */
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

# if (DCM_DIDMGR_2E_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ECheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ECheckAccess(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_Svc2ERepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
  if (pRepContext->DidInfoContext.Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic)    /* no periodic DID is a writable DID -> no need to check for race conditions! */
  {
    lStdResult = DCM_E_PENDING;
  }
  else
#  endif
  {
    Dcm_InstanceContext.DidMgr.DidRsrcContext.Write = pRepContext->DidInfoContext.Did;
    Dcm_RepeaterNextStep(DCM_SVC2E_PROGRESS_ECECUTEOP); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2EExecuteOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EExecuteOp(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc2ERepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType               lStdResult;

  lStdResult = Dcm_DidMgrWrite(opStatus
                             ,pMsgContext
                             ,&(pRepContext->DidInfoContext)
                             ,&(pRepContext->DidOpTypeContext)
                             ,ErrorCode);
# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
  if(lStdResult == DCM_E_PENDING)
  {
    /* return DCM_E_PENDING */
  }
  else
# endif
  {
    if(lStdResult != DCM_E_OK)
    {
      lStdResult = DCM_E_NOT_OK;
    }

# if (DCM_DIDMGR_2E_ACCESS_LOCK_ENABLED == STD_ON)
    Dcm_InstanceContext.DidMgr.DidRsrcContext.Write = 0u;
# endif
  }

  return lStdResult;
}
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2FReturnControlToEcu()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FReturnControlToEcu(void)
{
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid == TRUE)
  {
    Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid = FALSE;
    {
      P2VAR(Dcm_UtiBitSetBaseType, AUTOMATIC, DCM_VAR_NOINIT) pActiveIoDids = Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids;
      Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRefPage = 0;
      Dcm_CfgDidMgrIoDidHandleOptType ioDidIter = Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS_CONST);

      for(; (ioDidIter != 0u); --ioDidIter)
      {
        Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef = opInfoRefPage;
        DCM_UTI_LOOP_BIT_SCAN(*pActiveIoDids)
        {
          if((*pActiveIoDids & 0x01u) != 0)
          {
            Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_DidMgrGetCtrlOpInfoRef(opInfoRef));
          }
          ++opInfoRef;
        }
        Dcm_UtiNextItemByPtr(pActiveIoDids, 1u);
        opInfoRefPage += (Dcm_CfgDidMgrDidOpClassHandleOptType)Dcm_UtiGetNumBitsOfXintType(Dcm_UtiBitSetBaseType);/* next bunch of IoDids */
      }
    }
  }
# endif
}

# if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_EXT_CEMR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FExtractCEMR()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_Svc2FExtractCEMR(Dcm_ReadOnlyMsgType                 cemrStream
                                                            ,Dcm_CfgDidMgrIoDidCemrLengthMemType cemrSize)
{
  uint32 lResult = 0;

  if(cemrSize <= 4)
  {
    Dcm_CfgDidMgrIoDidCemrLengthOptType lCemrIter;

    /* Extract byte-wise the CEMR */
    for( lCemrIter = 0; lCemrIter < cemrSize; ++lCemrIter)
    {
      lResult <<= 8u;
      lResult |= cemrStream[lCemrIter];
    }

    /* For a 3 byte CEMR a 32bit value will be passed -> move to the MSB to fulfill the IO C/S API convention */
    if(cemrSize == 3)
    {
      lResult <<= 8u;
    }
  }/* else - leave the result = 0 (invalid value) */

  return lResult;
}
# endif

# if (DCM_DIDMGR_IO_MASKRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FProcessCEMR()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FProcessCEMR(Dcm_MsgContextPtrType pMsgContext                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                          ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)
{
  Dcm_CfgDidMgrIoDidCemrLengthMemType lCemrSize;

  /* Consider requests with and without CEMR */

  lCemrSize = Dcm_DidMgrGetCtrlEnblMaskLength(pRepContext->DidInfoContext.Descriptor.DidInfoPtr);

  if(lCemrSize != 0)
  {
    /* Subtract CEMR length from request length to get only the requested DID size in order to get the concrete length of the last DID signal (if variable length) */
    Dcm_DiagUpdateReqLength(pMsgContext, lCemrSize);
    pRepContext->DidOpTypeContext.OpType.Io.EnableMaskPtr = Dcm_DiagGetReqDataRel(pMsgContext, pMsgContext->reqDataLen);

#  if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_EXT_CEMR_ENABLED == STD_ON)
    /* Extract CEMR as a value */
    pRepContext->DidOpTypeContext.OpType.Io.ControlEnableMaskRecord = Dcm_Svc2FExtractCEMR(pRepContext->DidOpTypeContext.OpType.Io.EnableMaskPtr
                                                                                          ,lCemrSize);
#  endif
  }
  else
  {
    /* else - the request does not contain any CEMR */
    pRepContext->DidOpTypeContext.OpType.Io.EnableMaskPtr = NULL_PTR;
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FCalculateExpectedReqLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FCalculateExpectedReqLength(Dcm_DidMgrDidLengthPtrType expLengthMin
                                                                     ,Dcm_DidMgrDidLengthPtrType expLengthMax
                                                                     ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
# if (DCM_DIDMGR_OPTYPE_IO_SHRTTERMADJ_ENABLED == STD_ON)
  if((pRepContext->OpType & DCM_DIDMGR_OPTYPE_IO_SHRTTRMADJ) != 0)
  {
    /* short term adjustment - consider optional enable mask record and the DID data! */
    *expLengthMax = pRepContext->DidInfoContext.Descriptor.DidInfoPtr->Length;
#  if (DCM_DIDMGR_IODID_DYNLEN_ENABLED == STD_ON)
    *expLengthMin = pRepContext->DidInfoContext.Descriptor.DidInfoPtr->MinLength;
    if(*expLengthMin == 0) /* If IO DID with dynamic length AND single signal... */
    {
#   if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR_ENABLED == STD_ON)
      /* Non-"Supported IDs" must have at least one request data byte! */
      if(pRepContext->DidInfoContext.Descriptor.DidSignalOpClassInfoPtr->FuncClass != DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR)
#   endif
      {
        ++(*expLengthMin); /* ... minimum length is one byte! */
      }
    }
#  else
    /* Constant IODID length -> min == max */
    *expLengthMin = *expLengthMax;
#  endif
  }
  else
# endif
  {
    *expLengthMin = 0u; /* no data */
    *expLengthMax = 0u; /* no data */
  }

  *expLengthMin += Dcm_DidMgrGetCtrlEnblMaskLength(pRepContext->DidInfoContext.Descriptor.DidInfoPtr);
  *expLengthMax += Dcm_DidMgrGetCtrlEnblMaskLength(pRepContext->DidInfoContext.Descriptor.DidInfoPtr);
}

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckReqLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2FCheckReqLength(Dcm_MsgContextPtrType pMsgContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)
{
  Dcm_NegativeResponseCodeType lNrc = DCM_E_POSITIVERESPONSE;
  Dcm_DidMgrDidLengthType      expMinReqLen;
  Dcm_DidMgrDidLengthType      expMaxReqLen;

  Dcm_Svc2FCalculateExpectedReqLength(&expMinReqLen, &expMaxReqLen, pRepContext);

  /* Check DID specific length */
  if( (pMsgContext->reqDataLen < expMinReqLen)
    ||(pMsgContext->reqDataLen > expMaxReqLen) )
  {
    lNrc = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }

  return lNrc;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FIoDidOperationProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FIoDidOperationProcessor(Dcm_MsgContextPtrType pMsgContext                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType  lStdResult = DCM_E_NOT_OK;

  /* Initialize the IO-Control operation class from now for any checks that may come
   * (i.e. within Dcm_Svc2FCheckReqLength or later for the IO Control execution)  */
  Dcm_DidMgrGetOpClassInfo(&(pRepContext->DidInfoContext)
                            ,pRepContext->OpType);

  /* Validate request length */
  *ErrorCode = Dcm_Svc2FCheckReqLength(pMsgContext, pRepContext);                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */

  if(*ErrorCode == DCM_E_POSITIVERESPONSE)
  {
    /* Validate remaining state preconditions */
    lStdResult = Dcm_DidMgrStaticDidStateCheck(pRepContext->DidInfoContext.Descriptor.DidOpInfoPtr->ExecCondRef, ErrorCode);
    if(lStdResult == DCM_E_OK)
    {
# if (DCM_DIDMGR_IO_MASKRECORD_ENABLED == STD_ON)
      /* Process any eventually supported CEMR */
      Dcm_Svc2FProcessCEMR(pMsgContext, pRepContext);
# endif
# if (DCM_DIDMGR_2F_ACCESS_LOCK_ENABLED == STD_ON)
      Dcm_RepeaterNextStep(DCM_SVC2F_PROGRESS_CHECKACCESS); /* delegate job */
# else
      Dcm_RepeaterNextStep(DCM_SVC2F_PROGRESS_EXECUTEOP); /* delegate job */
# endif
      lStdResult = DCM_E_LOOP;/* speed up processing */
    }/* else DCM_E_NOT_OK (ErrorCode already set) */
  }/* else DCM_E_NOT_OK (ErrorCode already set) */

  return lStdResult;
}

# if (DCM_DIDMGR_2F_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FCheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FCheckAccess(Dcm_OpStatusType opStatus                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_MsgContextPtrType pMsgContext                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DIDMGR_2A_ACCESS_LOCK_ENABLED == STD_ON)
  if(pRepContext->DidInfoContext.Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadPeriodic)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
#  endif
#  if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
  if(pRepContext->DidInfoContext.Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic )
  {
    lStdResult = DCM_E_PENDING;
  }
  else
#  endif
  {
    Dcm_InstanceContext.DidMgr.DidRsrcContext.Io = pRepContext->DidInfoContext.Did;
    Dcm_RepeaterNextStep(DCM_SVC2F_PROGRESS_EXECUTEOP); /* delegate job */
    lStdResult = DCM_E_LOOP;
  }
  return lStdResult;/* speed up processing */
}
# endif

# if (DCM_SVC_2F_READ_RES_DATA_LEN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FGetLength(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)

{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdReturn = Dcm_DidMgrReadLength(opStatus
                                   ,&(pRepContext->DidInfoContext)
                                   ,ErrorCode);
  if(lStdReturn == DCM_E_OK)
  {
    /* Delegate the job to the data reader */
    Dcm_RepeaterNextStep(DCM_SVC2F_PROGRESS_READDATA);
    lStdReturn = DCM_E_LOOP;
  } /* else DCM_E_PENDING or DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}
# endif

# if(DCM_DIDMGR_IODID_READ_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FReadData(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType          lStdResult;
  Dcm_DiagDataContextType lDataContext;

  Dcm_DiagInitDataContext(&lDataContext, Dcm_DiagGetResData(pMsgContext), pMsgContext->resMaxDataLen);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

  /* Read DID  */
  Dcm_DidMgrGetOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READ);
  lStdResult = Dcm_DidMgrReadDid(opStatus
                                ,&lDataContext
                                ,&(pRepContext->DidInfoContext)
                                ,&(pRepContext->DidOpTypeContext)
                                ,ErrorCode);

  if(lStdResult == DCM_E_OK)
  {
    /* Commit data and go on with response */
    Dcm_DiagProvideResData(pMsgContext, pRepContext->DidInfoContext.DidLength);                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
#  if (DCM_DIDMGR_ASYNC_IODID_SUPPORT_ENABLED == STD_ON)
  if(lStdResult == DCM_E_PENDING)
  {
    /* return DCM_E_PENDING; */
  }
  else
#  endif
  {
    /* DCM_E_NOT_OK | PENDING (if unexpected) */
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FExecuteOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FExecuteOp(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                  ,Dcm_Svc2FRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType               lStdResult;

# if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_INT_CEMR_ENABLED == STD_ON)
  /* #10 If an IO DID with an internal CEMR handling is to be processed: */
  if( (pRepContext->DidOpTypeContext.OpType.Io.EnableMaskPtr != NULL_PTR)/* A request with CEMR is received and ... */
#  if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_EXT_CEMR_ENABLED == STD_ON)
    &&(pRepContext->DidInfoContext.Descriptor.DidSignalOpClassInfoPtr->FuncClass < DCM_DIDMGR_OPCLS_IO_FIRST_OPCLS_WITH_EXT_CEMR) /* ... the CEMR is not handled in the application call */
#  endif
    )
  {
    /* #20 Delegate the IO DID control operation processing to the DID manager utility that considers the requested CEMR */
    lStdResult = Dcm_DidMgrIoControlWithMask(opStatus
                                            ,pMsgContext
                                            ,&(pRepContext->DidInfoContext)
                                            ,&(pRepContext->DidOpTypeContext)
                                            ,ErrorCode);
  }
  else
# endif
  {
    /* #30 Otherwise delegate the IO DID control operation processing to the DID manager utility that executes all callbacks regardless of an available CEMR */
    lStdResult = Dcm_DidMgrIoControl(opStatus
                                    ,pMsgContext
                                    ,&(pRepContext->DidInfoContext)
                                    ,&(pRepContext->DidOpTypeContext)
                                    ,ErrorCode);
  }

  /* #40 On successful IO DID control operation accomplishment: */
  if(lStdResult == DCM_E_OK)
  {
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
    /* #50 Decide whether to register the IO DID for automatic recovery on transition to the default session */
    if(pRepContext->OpType != DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU)
    {
      /* On successfully executed control operation that is not "ReturnControlToEcu", register the complete IO DID for automatic reset on a transition to the default session
       * only if the IO DID supports "ReturnControlToEcu".
       */
      if(Dcm_DidMgrIsOpTypeSupported(pRepContext->DidInfoContext.Descriptor.DidOpInfoPtr, DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU))
      {
        /* Must have a valid index! */
        Dcm_DebugAssert((pRepContext->DidInfoContext.Descriptor.DidInfoPtr->OpRef < DCM_NUM_IODIDS), DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)         /* COV_DCM_RTM_DEV_DEBUG XF */

        /* Register IODID for state change monitoring */
        Dcm_Svc2FSetDidActive(Dcm_DidMgrOpInfoRedirector(pRepContext->DidInfoContext.Descriptor.DidInfoPtr->OpRef, OpRefIoControl));
        /* #60 Activate the scanning algorithm for the next session state change */
        Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid = TRUE;/* at least one activated IO DID */
      }/* Otherwise - nothing to register */
    }
    else
    {
      /* #70 Decide whether to unregister the IO DID from automatic recovery (reduces run-time usage on next session transition) */
#  if (DCM_DIDMGR_IO_MASKRECORD_ENABLED == STD_ON)
      /* Let all once activated DIDs to be reset later on session/security state change. Otherwise if only some of the signals have been reset by "ReturnControlToEcu", the whole DID will be removed from the queue! */
#  else
      /* For return control to ECU - remove from post clearing */
      Dcm_Svc2FClrDidActive(Dcm_DidMgrOpInfoRedirector(pRepContext->DidInfoContext.Descriptor.DidInfoPtr->OpRef, OpRefIoControl));
#  endif
    }
# endif
# if(DCM_DIDMGR_IODID_READ_SUPPORT_ENABLED == STD_ON)
    /* #80 Decide whether any response data have to be sent back to the client in addition to the control operation */
    if(  (Dcm_DidMgrIsOpSupported(pRepContext->DidInfoContext.Descriptor.DidInfoPtr, DCM_DIDMGR_OP_READ))
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR_ENABLED == STD_ON)
       &&(pRepContext->DidInfoContext.Descriptor.DidSignalOpClassInfoPtr->FuncClass != DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR)
#  endif
      )
    {
      /* #90 Set new IO DID operation to be reading */
      Dcm_DidMgrGetDidOpInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OP_READ);

#  if (DCM_SVC_2F_READ_RES_DATA_LEN_ENABLED == STD_ON)
      /* #100 On IO DIDs with dynamic length, start first reading the concrete data length */
      Dcm_RepeaterNextStep(DCM_SVC2F_PROGRESS_GETLENGTH); /* next job */
#  else
      /* #110 On IO DIDs with static length, start directly reading the response data */
      Dcm_RepeaterNextStep(DCM_SVC2F_PROGRESS_READDATA); /* next job */
#  endif
      /* #120 Start with next step immediately */
      lStdResult = DCM_E_LOOP;
    }
    else /* */
# endif
    {
      /* #130 If the IO DID does not support reading operation, continue with an empty positive response */
      lStdResult = DCM_E_OK;
    }
  }
# if (DCM_DIDMGR_ASYNC_IODID_SUPPORT_ENABLED == STD_ON)
  else if(lStdResult == DCM_E_PENDING)
  {
  /* #140 If IO DID control operation is not yet finished, try again later */
  }
# endif
  else /* DCM_E_NOT_OK */
  {
  /* #150 If IO DID control operation has failed return negative response */
    lStdResult = DCM_E_NOT_OK; /* ErrorCode already set */
  }

  /* #160 Delegate final result to the caller */
  return lStdResult;
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc31Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc31Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc31RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  uint8  routineOp;

  /* Min Length already checked in DiagDispatcher and expected to be 3 !!! */
  lStdResult = Dcm_RidMgrRidLookUp(opStatus
                                  ,Dcm_DiagGetReqDataAsU16Rel(pMsgContext,1)
                                  ,&(pRepContext->RidInfoIdx));

  if (lStdResult == DCM_E_OK)
  {
    Dcm_DiagConsumeReqDataAsU8(pMsgContext, &routineOp); /* Extract SF */                                                                            /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    Dcm_DiagConsumeReqData(pMsgContext, 2u); /* Skip RID in request (already used for the look up) */                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResData(pMsgContext, 3u); /* Commit SF and RID in response */                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_RidMgrStateCheckRid(Dcm_CfgRidMgrRidInfoExecCondRef(pRepContext->RidInfoIdx), ErrorCode);
    if (lStdResult == DCM_E_OK)
    {
      pRepContext->Op = Dcm_RidMgrConvOpOfSubFunc(routineOp);
      lStdResult = Dcm_RidMgrGetOpInfo(pRepContext->RidInfoIdx
                                      ,pRepContext->Op
                                      ,&(pRepContext->RidOpInfoIdx));

      if (lStdResult == DCM_E_OK)
      {
        if(
# if (DCM_RIDMGR_DYN_REQ_LEN_ENABLED == STD_ON)
          ((Dcm_CfgRidMgrOpInfoReqMinLength(pRepContext->RidOpInfoIdx) != Dcm_CfgRidMgrOpInfoReqMaxLength(pRepContext->RidOpInfoIdx))
          &&(Dcm_CfgRidMgrOpInfoReqMaxLength(pRepContext->RidOpInfoIdx) >= pMsgContext->reqDataLen) ) ||
# endif
          (Dcm_CfgRidMgrOpInfoReqMaxLength(pRepContext->RidOpInfoIdx) == pMsgContext->reqDataLen))
        {
          Dcm_RepeaterNextStep(DCM_SVC31_PROGRESS_EXECUTEOP); /* delegate job */
          lStdResult = DCM_E_LOOP;/* speed up processing */
        }
        else
        {
          *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
      else
      {
        *ErrorCode = DCM_E_SUBFUNCTIONNOTSUPPORTED;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }/* else DCM_E_NOT_OK - ErrorCode already assigned */
  }
  else if (lStdResult == DCM_E_PENDING)
  {
    /* lStdResult is already set */
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc3DHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DHandler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc3DRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint8          lAlfid;
  uint8          lBlockLength;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* dispatcher guarantees for minimum length of 4 bytes (ALFID + MEM + SIZE + DATA) available */
  *ErrorCode = Dcm_MemMgrValidateAlfid(pMsgContext, &lAlfid, &lBlockLength);                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  if (*ErrorCode == DCM_E_POSITIVERESPONSE)
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    /* check for exact length match */
    Dcm_DiagProvideResData(pMsgContext, (lBlockLength + 1u)); /* (1 byte ALFID + MEM + SIZE) */                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_MemMgrParseMemStream(lAlfid, pMsgContext, &pRepContext->MemBlock);

    if(pRepContext->MemBlock.Length == pMsgContext->reqDataLen)
    {
      lStdResult = Dcm_MemMgrCheckMemBlock(&pRepContext->MemBlock, DCM_MEMMGR_OP_WRITE, ErrorCode);
      if (lStdResult == DCM_E_OK)
      {
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
        Dcm_RepeaterNextStep(DCM_SVC3D_PROGRESS_CHECKACCESS);
# else
        Dcm_RepeaterNextStep(DCM_SVC3D_PROGRESS_WRITEMEMORY);
# endif
        lStdResult = DCM_E_LOOP;/* speed up processing */
      } /* else DCM_E_NOT_OK (ErrorCode already set) */
    }/* else DCM_E_NOT_OK (ErrorCode already set) */
  }/* else DCM_E_NOT_OK (ErrorCode already set) */

  return lStdResult;
}

# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc3DCheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DCheckAccess(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_Svc3DRepeaterProxyContextPtrType pRepContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_InstanceContext.MemMgr.LockedByClient != DCM_MEMMGR_ACCESS_NONE)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
  {
    Dcm_InstanceContext.MemMgr.LockedByClient = DCM_MEMMGR_ACCESS_REQ_EXT;
    Dcm_RepeaterNextStep(DCM_SVC3D_PROGRESS_WRITEMEMORY); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc3DWriteMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DWriteMemory(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                    ,Dcm_Svc3DRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_MemMgrWriteMemory(opStatus
                                   ,&pRepContext->MemBlock
                                   ,Dcm_DiagGetReqData(pMsgContext)
                                   ,ErrorCode);

  return lStdResult;
}
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc85SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc85SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc85SubFuncInfoGetEntryOrNull(
                                                                                Dcm_DiagSubServiceRefOptType SubSvcRef)
{
  Dcm_CfgSvc85SubFuncInfoPtrType lSubFuncInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SubSvcRef >= DCM_CFGSVC85SUBFUNCINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC85SUBFUNCINFOGETENTRY);
    lSubFuncInfo = NULL_PTR;
  }
  else
# endif
  {
    lSubFuncInfo = &Dcm_CfgSvc85SubFuncInfo[SubSvcRef];
  }

  return lSubFuncInfo;
}

/**********************************************************************************************************************
 *  Dcm_Svc85Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc85RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc85SubFuncLookUpTable
                                                   ,Dcm_CfgSvc85SubFuncExecPrecondTable
                                                   ,Dcm_Svc85ReqLengthGetter
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_CALL_VERIFY_SERVICE_WITH_SUBFUNCTION */

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef   = (Dcm_DiagSubServiceRefMemType)(lSubSvcRef);                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ReqMode     = Dcm_CfgSvc85SubFuncInfo[pRepContext->SubSvcRef].Mode;                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->DemClientId = Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol());                                                            /* SBSW_DCM_GLOBAL_PTR_WRITE */

# if (DCM_DEM_API_430_ENABLED == STD_ON)
    if (pMsgContext->reqDataLen == 3)
    {
      Dcm_DiagConsumeReqDataAsU24(pMsgContext, &pRepContext->DTCGroup);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      if (pRepContext->DTCGroup != DEM_DTC_GROUP_ALL_DTCS)
      {
        lStdResult = E_NOT_OK;
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      /* else: everything fine -> proceed with service processing */
    }
    else if (pMsgContext->reqDataLen != 0)
    {
      lStdResult = E_NOT_OK;
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      /* length = 0 -> nothing to extract */
    }
# else
    /* DEM API prior to 4.3.0 */
#  if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
    Dcm_DiagConsumeReqDataAsU24(pMsgContext, &pRepContext->DTCGroup);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
#  else
    pRepContext->DTCGroup = DEM_DTC_GROUP_ALL_DTCS;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
#  endif
# endif

# if (DCM_DEM_API_430_ENABLED == STD_ON)
    if (lStdResult == DCM_E_OK)
# endif
    {
      Dcm_RepeaterSetUser(DCM_REPEATER_USER_DEM);/* set user for central repeater handling */
      Dcm_RepeaterNextStep(DCM_SVC85_PROGRESS_REPEATERPROXY);
      lStdResult = DCM_E_LOOP;/* speed up processing */
    }
  }

  return lStdResult;
}
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_CfgSvc86SubFuncInfoGetEntryOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgSvc86SubFuncInfoPtrType, DCM_CODE) Dcm_CfgSvc86SubFuncInfoGetEntryOrNull(
                                                                                Dcm_DiagSubServiceRefOptType SubSvcRef)
{
  Dcm_CfgSvc86SubFuncInfoPtrType lSubFuncInfo;

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (SubSvcRef >= DCM_CFGSVC86SUBFUNCINFO_SIZE)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_CFGSVC86SUBFUNCINFOGETENTRY);
    lSubFuncInfo = NULL_PTR;
  }
  else
# endif
  {
    lSubFuncInfo = &Dcm_CfgSvc86SubFuncInfo[SubSvcRef];
  }

  return lSubFuncInfo;
}

/**********************************************************************************************************************
 *  Dcm_Svc86Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86Handler(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                ,Dcm_Svc86RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                              ,Dcm_CfgSvc86SubFuncLookUpTable
                                              ,Dcm_CfgSvc86SubFuncExecPrecondTable
                                              ,Dcm_Svc86ReqLengthGetter
                                              ,&lSubSvcRef                                                                                           /* SBSW_DCM_CALL_VERIFY_SERVICE_WITH_SUBFUNCTION */
                                              ,ErrorCode);

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)(lSubSvcRef);
    Dcm_RepeaterNextStep(DCM_SVC86_PROGRESS_SUBFUNCTION); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc86SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86SubFuncHandler(Dcm_OpStatusType opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc86RepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_CfgSvc86SubFuncInfoPtrType pSubFuncInfo;

  pSubFuncInfo = Dcm_CfgSvc86SubFuncInfoGetEntryOrNull(pRepContext->SubSvcRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSubFuncInfo == NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(opStatus, pMsgContext, ErrorCode);
  }

  return lStdResult;
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Module internal function implementations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_MemMgrCheckMemBlock()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrCheckMemBlock(Dcm_MemMgrMemBlockPtrType pMemBlock                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_MemMgrMemoryOpType memOp
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_CfgMemMgrMemMapInfoPtrType pUsedMemMap;
  Dcm_CfgMemMgrMemMapIdxOptType  memMapSize;

# if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
  {
    sint16_least midIdx = Dcm_UtiLookUpUint8(Dcm_CfgMemMgrMidLookUpTable, pMemBlock->Mid);
    if(midIdx < 0)
    {
      return DCM_E_REQUESTOUTOFRANGE;
    }/* else - the mid is supported */
#  if (DCM_MEMMGR_MULTIMID_SUPPORT_ENABLED == STD_ON)
    pUsedMemMap = Dcm_CfgMemMgrMidInfo[midIdx].MemMapTable;
    memMapSize  = Dcm_CfgMemMgrMidInfo[midIdx].Size;
#  else
    pUsedMemMap = Dcm_CfgMemMgrMemMap;
    memMapSize  = DCM_MEMMGR_MEMMAP_NUM_ENTRIES;
#  endif
  }
# else
  pUsedMemMap = Dcm_CfgMemMgrMemMap;
  memMapSize  = DCM_MEMMGR_MEMMAP_NUM_ENTRIES;
# endif

  /*--- Inlined check memory range */
  {
    Dcm_CfgMemMgrReqAddrType       reqEndAddress;

    reqEndAddress = (Dcm_CfgMemMgrReqAddrType)(pMemBlock->Address + (Dcm_CfgMemMgrReqSizeType)(pMemBlock->Length - 1u)); /* possible overflows does not take any effect for now */

    /* Check for address overflow or no data required (length == 0) */
    if( (pMemBlock->Length != 0u)
      &&(reqEndAddress >= pMemBlock->Address) )
    {
      Std_ReturnType lStdResult = DCM_E_OK;
      Dcm_CfgMemMgrMemMapIdxOptType  memMapIter = 0;
      Dcm_CfgMemMgrMemAddrType       lastEndAddr = pUsedMemMap->EndAddr;
      boolean                        isBlockBeginFound = FALSE;

      for(;memMapIter < memMapSize;++memMapIter)
      {
        if(pUsedMemMap->EndAddr >= pMemBlock->Address)/* first block that may contain the requested range */
        {
          if(isBlockBeginFound == FALSE)
          {
            isBlockBeginFound = TRUE;
            if(pUsedMemMap->StartAddr > pMemBlock->Address)/* the start address must be within the configured block  */
            {
              break; /* return DCM_E_REQUESTOUTOFRANGE - the requested start address is not belonging to the memory block */
            }/* else - OK, let's analyze the other properties of the configuration block */
          }
          else /* scanning subsequent blocks */
          {
            ++lastEndAddr;/* prepare for the potential next concatenated range startAddr */
            if(pUsedMemMap->StartAddr != lastEndAddr)      /* no concatenated ranges */
            {
              break; /* return DCM_E_REQUESTOUTOFRANGE */                                                                                            /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
            }/* else - the end address block was not found yet, check this range borders and conditions */
          }

          if (pUsedMemMap->ExecCondRefs[memOp] == 0u) /* memory operation supported for this block in currently active variant(s) ? */
          {
            break; /* return DCM_E_REQUESTOUTOFRANGE */                                                                                              /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
          }
          else/* else - range supports operation - go on with state checks */
# if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
          if (Dcm_VarMgrIsEnabledInActiveVariants((Dcm_CfgStateRefOptType)(pUsedMemMap->ExecCondRefs[memOp] - 1u)) == FALSE)
          {
            break; /* return DCM_E_REQUESTOUTOFRANGE */                                                                                              /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
          }
          else /* else - range supports operation in variant - go on with state checks */
# endif
          {
            /* MISRA */
          }

          if(lStdResult == DCM_E_OK) /* still no error found */
          {
            lStdResult = Dcm_StateCheck((Dcm_CfgStateRefOptType)(pUsedMemMap->ExecCondRefs[memOp] - 1u), DCM_DIAG_CHK_LVL_PARAMETER, ErrorCode);
          }/* else - ErrorCode already set, let see if the range is at least OK */

          if(((Dcm_CfgMemMgrReqAddrType)pUsedMemMap->EndAddr) >= reqEndAddress)
          {
            return lStdResult; /* either POS_RES or first condition error */
          }/* else - try next range (if any still available) */
          lastEndAddr = pUsedMemMap->EndAddr;/* update for next iteration */
        }/* else - not reached a range from the bottom */
        Dcm_UtiNextItemByPtr(pUsedMemMap, 1u);
      }/* no valid range found */
    }/* else - length == 0 or req_addr > blockEnd */
  }

  *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
  return DCM_E_NOT_OK;
}                                                                                                                                                    /* PRQA S 2006, 6030, 6080 */ /* MD_Dcm_Optimize_2006, MD_MSR_STCYC, MD_MSR_STMIF */

# if (DCM_MEMMGR_MEMOP_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrReadMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrReadMemory(Dcm_OpStatusType opStatus
                                                             ,Dcm_MemMgrMemBlockPtrType pMemBlock                                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                             ,Dcm_ConstMsgType data
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_MemMgrOpResultType memOpResult;

  *ErrorCode = DCM_E_POSITIVERESPONSE;
  memOpResult = Dcm_ReadMemory(opStatus
#  if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
      ,pMemBlock->Mid
#  else
      ,0u
#  endif
      ,pMemBlock->Address
      ,pMemBlock->Length
      ,data
#  if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
      ,ErrorCode
#  endif
      );

  return Dcm_MemMgrConvMemOpResult(memOpResult, opStatus, ErrorCode, DCM_E_GENERALREJECT);  /* RFC 57196 - return NRC 0x10 */
}
# endif

# if (DCM_MEMMGR_MEMOP_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MemMgrWriteMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrWriteMemory(Dcm_OpStatusType opStatus
                                                              ,Dcm_MemMgrMemBlockPtrType pMemBlock                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                              ,Dcm_MsgType data
                                                              ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_MemMgrOpResultType memOpResult;

  *ErrorCode = DCM_E_POSITIVERESPONSE;

  memOpResult = Dcm_WriteMemory(opStatus
#  if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
      ,pMemBlock->Mid
#  else
      ,0u
#  endif
      ,pMemBlock->Address
      ,pMemBlock->Length
      ,data
#  if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
      ,ErrorCode
#  endif
      );

  return Dcm_MemMgrConvMemOpResult(memOpResult, opStatus, ErrorCode, DCM_E_GENERALPROGRAMMINGFAILURE);
}
# endif
/**********************************************************************************************************************
 *  Dcm_MemMgrValidateAlfid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_MemMgrValidateAlfid(Dcm_MsgContextPtrType   pMsgContext                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                              ,Dcm_Uint8VarDataPtrType pAlfid
                                                                              ,Dcm_Uint8VarDataPtrType pBlockLength)
{
  Dcm_NegativeResponseCodeType lNrc;

  if (pMsgContext->reqDataLen != 0u)
  {
    uint8 addrSize;
    uint8 lenSize;

    /* else - at least one byte for ALFID is available */
    Dcm_DiagConsumeReqDataAsU8(pMsgContext, pAlfid);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    addrSize = Dcm_MemMgrGetMemBlockAddrSize(*pAlfid);
    lenSize = Dcm_MemMgrGetMemBlockLenSize(*pAlfid);
    *pBlockLength = (uint8)(addrSize + lenSize); /* (memory address + memory size) */

# if (DCM_MEMMGR_ALFID_RESTRICTION_ENABLED == STD_ON)
    if(Dcm_UtiLookUpUint8(Dcm_CfgMemMgrAlfidLookUpTable, *pAlfid) < 0)
# else
#  if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
    --addrSize; /* subtract the MID from the real address carrier */
#  endif
    if(
#  if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
      (addrSize < 1u)  /* a request with only a MID does not make any sense! */
#  else
      (addrSize == 0u)
#  endif
      ||((uint8)sizeof(Dcm_CfgMemMgrReqAddrType) < addrSize)
      ||(lenSize == 0u)  || ((uint8)sizeof(Dcm_CfgMemMgrReqSizeType) < lenSize ) )
# endif
    {
      lNrc = DCM_E_REQUESTOUTOFRANGE;
    }
    else if(*pBlockLength <= pMsgContext->reqDataLen)
    {
      lNrc = DCM_E_POSITIVERESPONSE;
    }
    else
    {
      lNrc = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
    }
  }
  else
  {
    lNrc = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }

  return lNrc;
}

/**********************************************************************************************************************
 *  Dcm_MemMgrParseAlfid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_MemMgrParseMemStream(uint8 alfid
                                                              ,Dcm_MsgContextPtrType   pMsgContext
                                                              ,Dcm_MemMgrMemBlockPtrType pMemBlock)
{
  uint8_least iter;
  uint32 dwordExtract;
  uint8 byteValue;

  iter = Dcm_MemMgrGetMemBlockAddrSize(alfid);

# if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
  --iter; /* skip mid */
  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &(pMemBlock->Mid));
# endif

  /* extract address */
  dwordExtract = 0u;
  do
  {
    --iter;
    dwordExtract <<= 8u;
    Dcm_DiagConsumeReqDataAsU8(pMsgContext, &byteValue);
    dwordExtract |= byteValue;
  }
  while(iter != 0u);

  pMemBlock->Address = (Dcm_CfgMemMgrReqAddrType)dwordExtract;

  /* extract size  */
  dwordExtract = 0u;
  iter = Dcm_MemMgrGetMemBlockLenSize(alfid);
  do
  {
    --iter;
    dwordExtract <<= 8u;
    Dcm_DiagConsumeReqDataAsU8(pMsgContext, &byteValue);
    dwordExtract |= byteValue;
  }
  while(iter != 0u);

  pMemBlock->Length = (Dcm_CfgMemMgrReqSizeType)dwordExtract;
}
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_22_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_SVC_31_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrIsIdEnabled()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_ObdIdMgrIsIdEnabled(uint8 obdId
                                              ,P2CONST(Dcm_ObdIdMgrMaskValueTableType, AUTOMATIC, DCM_CONST) pMaskData)
{
  Dcm_DebugAssert((pMaskData != NULL_PTR), DCM_SID_INTERNAL, DCM_E_PARAM_POINTER)                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
  /* depends on if the first availability ID is requested or another one */
  return (boolean) ((obdId == 0x00u) ? (pMaskData[0] != 0) /* ID 0x00 is only available if any other IDs are supported too */
                                     : Dcm_ObdIdMgrIsIdSupported(pMaskData[Dcm_ObdIdMgrGetAvailabilityIdIdx(obdId-1)], obdId)); /* else - another ID (i.e. [0x01-0xFF]) is requested */
}
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_ObdIdMgrGetAvailabilityMask(uint8 id
                                                                      ,Dcm_Uint8ConstDataPtrType lookUpTable
                                                                      ,Dcm_VarRefMemPtrType lookUpFilterTable
                                                                      ,Dcm_ObdMaskConstDataPtrType pMaskData
                                                                      ,P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue)
{
  sint16_least lLookUpResult;
  uint32 lResultMask;
  uint8 lAID;

  DCM_IGNORE_UNREF_PARAM(pMaskData);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(lookUpFilterTable);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* #10 Initially the mask value is zero */
  lResultMask = 0;

  /* #20 Get the corresponding AID */
  lAID = Dcm_ObdIdMgrGetAvailabilityId(id);

  /* #30 Check if the corresponding AID is supported (in variant) */
  lLookUpResult = Dcm_VarMgrLookUpFilter(Dcm_UtiLookUpUint8(lookUpTable, lAID), lookUpFilterTable);

  /* #40 If the corresponding AID is supported, then the OBD ID might be supported too. Continue with mask calculation. */
  if(lLookUpResult >= 0)
  {
    /* #50 Define a zero-based iterator (i.e. for tables without leading-size-byte element) */
    sint16_least lLookUpIter;

    /* #60 Skip the AID and continue with next DataID or AID */
    lLookUpIter = (sint16_least)(lLookUpResult + 1);

    /* #70 If the requested ID is a DataID, assume it is not supported */
    if(!Dcm_ObdIdMgrIsAvailabilityId(id))
    {
      lLookUpResult = -1;
    }
    /* #80 Otherwise, the lookup index already found and stored (lLookUpResult) */

    /* #90 Iterate within the AID range or end of table and calculate bit mask */
    for(; lLookUpIter < (sint16_least)lookUpTable[0]; ++lLookUpIter)
    {
      uint8 lId = lookUpTable[lLookUpIter+1]; /* Consider the leading-size-byte offset in the lookup table */

# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
      /* #100 Consider variant availability (if PBS/PBL on services enabled) */
      if(Dcm_VarMgrIsEnabledInActiveVariants(lookUpFilterTable[lLookUpIter]) == TRUE)
# endif
      {
        /* #110 If available in the variant set corresponding bit */
        Dcm_UtiBitOpSet(uint32, lResultMask, Dcm_ObdIdMgrGetObdIdMaskBit(lId));

        /* #120 If the ID matches the requested one, update the lookup result */
        if(lId == id)
        {
          lLookUpResult = lLookUpIter;
        }
      }

      /* #130 Iterate until the next AID is reached. This AID shall be reported in bit0 of the mask too, therefore use post-condition-check */
      if(Dcm_ObdIdMgrIsAvailabilityId(lId))
      {
        break;
      }
    }

# if (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED == STD_ON)
    /* #140 Consider calibration dependent availability (if calibration enabled) */
    lResultMask &= Dcm_ObdIdMgrGetMaskValue(id, pMaskData);

    /* #150 Check if the requested ID is still enabled. Note: if the id == AID, the lResultMask will not contain it, therefore call the corresponding API */
    if(Dcm_ObdIdMgrIsIdEnabled(id, pMaskData) == FALSE)
    {
      lLookUpResult = -1; /* currently suppressed */
    }
# endif
  }
  /* #160 Otherwise the AID or DataId within the AID range is not available at all */

  /* #170 Return the calculated mask */
  *pMaskValue = lResultMask;

  return lLookUpResult;
}

# if (DCM_OBDIDMGR_REQ_PARSER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrParseReqAndPrepRes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_ObdIdMgrParseReqAndPrepRes(Dcm_ObdIdMgrDescPtrType idDescPtr
                                                                                    ,Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_NegativeResponseCodeType lNrc = DCM_E_REQUESTOUTOFRANGE;
  Dcm_MsgLenType lNumObdIds = pMsgContext->reqDataLen;

  if ( (lNumObdIds > 0u)         /* At least one ID must be there */
    && ((lNumObdIds <= 6u)      /* Up to 6 IDs possible */
       ||((idDescPtr->ParseFlags & DCM_OBDIDMGR_PFLAG_REQHASDATA) != 0)) )  /* on request data - the parser will stop immediately on the first DataID */
  {
    Dcm_ObdIdMgrHandleOptType idSrcIter;
    sint16_least idIdx;
    Dcm_ObdIdMgrListItemPtrType lIdList = idDescPtr->ParseResult;
    uint8 lId;
    uint8 idTypeMask = 0x00u;

    idDescPtr->ParseCount = 0u;/* reset count */
    idSrcIter = (Dcm_ObdIdMgrHandleOptType)Dcm_UtiMathMin(lNumObdIds, 6u);/* up to 6 in case of request data is available */
    do /* at least one ID is inside */
    {
      --idSrcIter;

      Dcm_DiagConsumeReqDataAsU8(pMsgContext, &lId);                                                                                                 /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
      /* analyze single ID */

      /* Check for valid data Id by getting the corresponding mask  */
      idIdx = idDescPtr->GetMaskFunc(lId, &(lIdList->Result.MaskValue));
      idDescPtr->IsAvailabilityId = (boolean)Dcm_ObdIdMgrIsAvailabilityId(lId);
      if(idDescPtr->IsAvailabilityId == TRUE)
      {
        idTypeMask |= 0x01u;
        /* lIdList->Result.MaskValue already set, "Handle" not needed */
      }
      else
      {
        idTypeMask |= 0x02u;
        lIdList->Result.Handle = (Dcm_ObdIdMgrHandleMemType)(idIdx - Dcm_ObdIdMgrGetAvailabilityIdIdx(lId) - 1); /* skip "availability ID" gaps and make it zero based */
        if(((idDescPtr->ParseFlags & (Dcm_ObdIdMgrParserFlagsType)(DCM_OBDIDMGR_PFLAG_SINGLEDATAID|DCM_OBDIDMGR_PFLAG_REQHASDATA)) != 0) ) /* single ID only OR has data */
        {
          /* if has data - only one ID is allowed in the request.
           * If previously a SuppPid is found -> a later check below will issue error result!
           */
          idSrcIter = 0; /* finish this iteration (consider supported data ID "idIdx>=0") and stop */
        }/* else - no restrictions -> go on */
      }
      /* Found ? */
      if(idIdx >= 0)
      {
        idDescPtr->ParseCount++;
        /* Common processing */
        lIdList->Id = lId;
        /* Prepare for next item */
        Dcm_UtiNextItemByPtr(lIdList, 1u);
      }/* else - not supported/enabled ID */
    }
    while(idSrcIter != 0);

    /* Analyze summary */
    if( (idDescPtr->ParseCount != 0) /* at least one ID supported */
      &&(idTypeMask != 0x03u ) ) /* no mixed types */
    {
      if(idDescPtr->IsAvailabilityId == FALSE)/* it is a data ID */
      {
        if((DCM_OBDIDMGR_PFLAG_REQHASDATA & idDescPtr->ParseFlags) != 0) /* if has any data, then it is OK for now - the service processor shall check the data length! */
        {
          /* OK - it can only be a single DATA ID, otherwise idTypeMask would be 0x03! */
        }
        else if((DCM_OBDIDMGR_PFLAG_SINGLEDATAID & idDescPtr->ParseFlags) != 0) /* only one data ID allowed */
        {
          if (lNumObdIds != 1u)
          {
            /* single ID only allowed */
            return lNrc;
          }/* else - OK */
        }
        else /* (idDescPtr->ParseFlags == DCM_OBDIDMGR_PFLAG_NONE) - no restrictions */
        {
          /* OK */
        }
      }
      else
      {
        /* an availability ID request */
        if( ((DCM_OBDIDMGR_PFLAG_SINGLEDATAID & idDescPtr->ParseFlags) != 0) /* on data ID with request data */
          && (lNumObdIds > 6u)) /* not more than 6 availability IDs allowed! */
        {
          return lNrc;
        }/* else - OK */

        /* iterate over all of them */
        {
          Dcm_ObdIdMgrHandleOptType idIter = idDescPtr->ParseCount;
          lIdList = idDescPtr->ParseResult;
          do
          {
            Dcm_DiagProvideResDataAsU8(pMsgContext, lIdList->Id);                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
            Dcm_DiagProvideResDataAsU32(pMsgContext, lIdList->Result.MaskValue);/* Commit data: ID byte + 4Byte DATA */                              /* SBSW_DCM_PARAM_PTR_FORWARD */
            Dcm_UtiNextItemByPtr(lIdList, 1u);/* next item */
            --idIter;
          }
          while(idIter != 0);
        }
      }
      lNrc = DCM_E_POSITIVERESPONSE;
    }/* else - either mixed request or no valid IDs */
  }/* else - too less/many IDs */
  return lNrc;
}                                                                                                                                                    /* PRQA S 2006, 6010, 6030, 6080 */ /* MD_Dcm_Optimize_2006, MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
# endif
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_UTI_LOOKUP_U16_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_UtiLookUpUint16()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_UtiLookUpUint16(P2CONST(uint16, AUTOMATIC, DCM_CONST) lookUpTable
                                                          ,uint16 value)
{
  sint16_least  lResult;
  uint16_least  loIdx;
  uint16_least  hiIdx;
  uint16_least  lPosition;

  /* #10 Initialize look-up: assume nothing will be found */
  lResult = -1;
  loIdx= 1;
  hiIdx= lookUpTable[0];

  /* #20 If any sub-array exists: */
  while (loIdx <= hiIdx)
  {
    /* #30 Calculate entry position for comparison */
    lPosition = (uint16_least)(loIdx + ((hiIdx - loIdx) / 2)); /* avoids overflows on value addition */

    /* #40 If item found: */
    if(lookUpTable[lPosition] == value)
    {
      /* #50 Return valid entry position (compensate offset) */
      lResult = (sint16_least)(lPosition-1);
      break;
    }
    /* #60 Otherwise - continue searching */

    /* #70 Determine which sub-array shall be taken as a next */
    if (value < lookUpTable[lPosition])
    {
      /* not needed lPosition zero value check, since loIdx >=1 */
      hiIdx = (uint16_least)(lPosition - 1);
    }
    else
    {
      /* Use upper half of interval */
      loIdx = (uint16_least)(lPosition + 1);
    }
  }
  /* #80 Otherwise - report nothing found */

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_UtiGetBitPosition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(uint8, DCM_CODE) Dcm_UtiGetBitPosition(uint32 bitSet)
{
  uint8 bitCtr;

  /* This API shall be called with a single bit set in the bit-mask */
  Dcm_DebugAssert(Dcm_UtiIsPowerOfTwo(uint32, bitSet), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                /* COV_DCM_RTM_DEV_DEBUG XF */

  /* #10 Initialize result counter with 0 (in case no bit or only bit0 is set) */
  bitCtr = 0;

  /* #20 The result is zero based -> skip the first bit in the bit-set */
  bitSet >>= 1;

  /* #30 Count zero bits in the set until the set bit is reached */
  while(bitSet != 0)
  {
    bitSet >>= 1;
    ++bitCtr;
  }

  /* #40 Return bit position */
  return bitCtr;
}

#if (DCM_UTI_NVM_READ_ENABLED  == STD_ON) || \
    (DCM_UTI_NVM_WRITE_ENABLED == STD_ON)                                                                                                            /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_UtiNvMGetErrorStatus()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiNvMGetErrorStatus(uint16 blockId)
{
  Std_ReturnType lStdResult;
  NvM_RequestResultType nvmStatus;

  /* #10 Get current NvM job status */
  lStdResult = Dcm_UtiArEnvNvMGetErrorStatus(blockId, &nvmStatus);

  /* #20 If status report successful: */
  if(lStdResult == E_OK)
  {
    /* #30 If NvM operation succeeded: */
    if (nvmStatus == NVM_REQ_OK )
    {
      /* #40 Return the result to the callee */
      /* result is already E_OK */
    }
    /* #50 If the NvM needs more time: */
    else if (nvmStatus == NVM_REQ_PENDING)
    {
      /* #60 Notify callee to retry later */
      lStdResult = DCM_E_PENDING;
    }
    else
    {
      /* #70 Otherwise: NvM operation failed for other reason; report back to callee */
      lStdResult = E_NOT_OK;
    }
  }
  else
  {
    /* #80 Otherwise: Gathering NvM job status failed; report back to callee */
    lStdResult = E_NOT_OK;
  }

  /* #90 Return final result */
  return lStdResult;
}
#endif
#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetTaskTaMonitor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTaMonitor(Dcm_TskTaskEvOptType ev
                                                   ,Dcm_TskTaskEvPtrType pPostEv)                                                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_CfgNetTObjHandleOptType lTObjCntr;

  /* #10 Check whether any request which has to be canceled is in progress */
  if(((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE | DCM_DIAG_QUEUE_FLAG_IS_WAITING) & Dcm_InstanceContext.Diag.QueuedSet.Flags) != 0)
  {

    /* #20 Enter critical section (Reason: the transport object may not be modified from outside) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/

    /* #30 If a request is in progress */
    if((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE & Dcm_InstanceContext.Diag.QueuedSet.Flags) != 0)
    {
      Dcm_TskTaskEvOptType tObjEv = Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, Dcm_DiagGetTranspObj()->Handle);

      /* #40 If the ongoing request is from the same tester as the new request with the foreign N_TA */
      if(Dcm_TskIsLocalEventSet(ev, tObjEv))
      {
        /* #50 Cancel the request processing */
        Dcm_DiagCancelProcessing();
      }/* else - post processing or idle are to be handled in a normal way */
    }

    /* #60 If a waiting new request is in the queue */
    if((DCM_DIAG_QUEUE_FLAG_IS_WAITING & Dcm_InstanceContext.Diag.QueuedSet.Flags) != 0)
    {
       Dcm_TskTaskEvOptType tObjEv = Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, Dcm_DiagGetQueuedTranspObj()->Handle);

       /* #70 If the queued request is from the same tester as the new request with the foreign N_TA */
       if(Dcm_TskIsLocalEventSet(ev, tObjEv))
       {
         /* #80 Cancel the queued request in the next task cycle */
         *pPostEv = tObjEv;/* retry later */                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
       }
    }
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* #90 Leave critical section */
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

  /* #100 Scan all affected transport objects */
  lTObjCntr = 0u;
  DCM_TSK_EVENT_SCAN_LOOP(ev)
  {
    if(Dcm_TskIsLocalEventSet(ev, 0x01u))
    {
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTransportObject(lTObjCntr);

      /* #110 If a received but not yet processed request was interrupted by another request with a foreign N_TA */
      if( ( pTranspObj->State == DCM_NET_TOBJ_STATE_RX_END)
        &&((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_OBSOLETE) != 0 ) ) /* This is still the original transport object marked to be canceled in the Dcm_OnRequestIndication */
      {
        Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

        /* #120 Prevent the processing of the received but not yet processed request */
        Dcm_TskClrEvent(DCM_TSK_ID_NET_RX, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));

        /* #130 Deallocate the transport object and free the connection */
        Dcm_NetUnRegisterComMActivity(pTranspObj->ConnId); /* Deallocate transport object */
        Dcm_NetBufferRelease(pBufferContext); /* The buffer is free now */                                                                           /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
        Dcm_NetUnRegisterActiveConnection(pTranspObj); /* No further processing needed */                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      } /* #140 Otherwise, connection is not obsolete or will be canceled during service processing (already in state
         * DCM_NET_TOBJ_STATE_READY) */
    }
    ++lTObjCntr;
  }
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
#endif

#if (DCM_NET_TASK_RX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetTaskRx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskRx(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv)                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
# if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
  /* If multi protocol is enabled, start request prioritization */
  Dcm_NetRxPrioritisation(ev, pPostEv);                                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
# elif (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)                                                                                              /* COV_DCM_SUPPORT_ALWAYS TX */
  /*
   * In case that multi protocol is disabled and interruption on a request with foreign N_TA is enabled:
   * When a new request is received instead of calling Dcm_DiagRxIndication directly the new request has to be
   * delegated by this task. This is necessary to be able to cancel already received but not yet processed requests
   * when another request with a foreign N_TA is received. That cancellation would be done by the Dcm_NetTaskTaMonitor.
   */
  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /* Only one transport object can be processed */
  Dcm_DebugAssert(Dcm_UtiIsPowerOfTwo(Dcm_TskTaskEvOptType, ev), DCM_SID_INTERNAL, DCM_E_PARAM)                                                      /* COV_DCM_RTM_DEV_DEBUG XF */

  /* Otherwise, delegate the received request to the task */
  Dcm_DiagRxIndication(Dcm_NetGetTransportObject(Dcm_UtiGetBitPosition(ev)));                                                                        /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
# else
#  error "Invalid configuration!"
# endif
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetTaskTx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTx(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv)                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ev);                                                                                                                        /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Since the DCM_TSK_EV_NET_TX_SEND is the only event of this task -> no need to test any event explicitly (otherwise the task would not be activated) */
#if (DCM_TSK_EV_NET_TX_MSB != 0x01u)
# error "New events have been added for Dcm_NetTaskTx! Make set event check here!"
#endif
  {
    Dcm_CfgNetTObjHandleOptType lTObjIter;

    /* find candidate for NRC 0x21 or final response */
    for(lTObjIter = 0; lTObjIter < Dcm_PbCfgNetNumTransportObjects; ++lTObjIter)
    {
      Dcm_NetTransportObjectPtrType pTranspObj;
      pTranspObj = Dcm_NetGetTransportObject(lTObjIter);

#if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      if( (pTranspObj->State == DCM_NET_TOBJ_STATE_RX_END) /* Completely received ... */
        &&((DCM_NET_TOBJ_FLAG_BUSY & pTranspObj->Flags) != 0))/* ... a parallel request */
      {
        /* Send NRC 0x21 response */
        Dcm_NetComposeAddNegResponse(pTranspObj, DCM_NET_TOBJ_RESTYPE_SIMPLE, DCM_E_BUSYREPEATREQUEST);                                              /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      }
#endif

      if(pTranspObj->State == DCM_NET_TOBJ_STATE_PREPTX)
      {
        Dcm_NetTransmitUsdtResponse(pTranspObj);                                                                                                     /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      }
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_NetRegisterComMActivity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetRegisterComMActivity(Dcm_NetTransportObjectPtrType pTranspObj)                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
#if(DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0)/* internal requests do not manage the ComM activity */
#endif
  {
    Dcm_CfgNetNetIdRefMemType lNetHandle;
    Dcm_NetComMContextPtrType pComMContext;

    lNetHandle   = Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnId].NetworkIdRef;
    pComMContext = Dcm_NetGetComMContext(lNetHandle);

    Dcm_DebugAssert((pComMContext->RegisteredNetworks != Dcm_UtiMaxValueOfUintType(Dcm_NetConnRefMemType)), DCM_SID_INTERNAL, DCM_E_PARAM)           /* COV_DCM_RTM_DEV_DEBUG XF */

    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    if(pComMContext->RegisteredNetworks == 0u)
    {
      /* activate only if default session is active, otherwise already active */
      if(   Dcm_StateIsDefaultSessionActive()
        && (Dcm_SingletonContext.Network.ActiveDiagnostic == DCM_NET_COMM_ACTIVE)
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
        && (Dcm_SingletonContext.Network.KeepAlive == FALSE)
#endif
        )
      {
        /* Register one connection */
        Dcm_NetArEnvComMActiveDiag(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandle]]);
      }
    }

    /* Register one connection */
    ++pComMContext->RegisteredNetworks;                                                                                                              /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterComMActivity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterComMActivity(Dcm_NetConnRefMemType connId)
{
  Dcm_CfgNetNetIdRefMemType lNetHandle;
  Dcm_NetComMContextPtrType pComMContext;

  lNetHandle   = Dcm_PbCfgNetConnectionInfo[connId].NetworkIdRef;
  pComMContext = Dcm_NetGetComMContext(lNetHandle);

  Dcm_DebugAssert((pComMContext->RegisteredNetworks != 0u), DCM_SID_INTERNAL, DCM_E_PARAM)                                                           /* COV_DCM_RTM_DEV_DEBUG XF */

  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Unregister one connection */
  --pComMContext->RegisteredNetworks;                                                                                                                /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */

  if(pComMContext->RegisteredNetworks == 0u)
  {
    /* return only if default session is active */
    if (Dcm_StateIsDefaultSessionActive()
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
       &&(Dcm_SingletonContext.Network.KeepAlive == FALSE)
#endif
       )
    {
      Dcm_NetArEnvComMInactiveDiag(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandle]]);
    }
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterAllComMActivity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterAllComMActivity(void)
{
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  {
    Dcm_CfgNetNetIdRefOptType lNetHandleIter;
    for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
    {
      /* unregister only if no connection is ongoing */
      if(Dcm_PbRamNetComMContext[lNetHandleIter].RegisteredNetworks == 0u)
      {
        Dcm_NetArEnvComMInactiveDiag(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandleIter]]);
      }
    }
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterActiveConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterActiveConnection(Dcm_NetTransportObjectPtrType pTranspObj)
{
#if(DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0)
#endif
  {
    Dcm_DebugAssert((Dcm_SingletonContext.Network.NumActiveConnections != 0u), DCM_SID_INTERNAL, DCM_E_PARAM)                                        /* COV_DCM_RTM_DEV_DEBUG XF */

    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
     BEGIN CRITICAL SECTION
     *=================================*/
    /* Un-register an active connection */
    --Dcm_SingletonContext.Network.NumActiveConnections;

    if(Dcm_SingletonContext.Network.NumActiveConnections == 0u)
    {
      Dcm_TmrStartTimer(DCM_TMR_ID_S3, DCM_DIAG_TIME_S3);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
      Dcm_TmrStartTimer(DCM_TMR_ID_KEEP_ALIVE, DCM_NET_KEEP_ALIVE_TIME);
#endif
    }

    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
  Dcm_NetTranspObjRelease(pTranspObj);                                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
}

/**********************************************************************************************************************
 *  Dcm_NetAllocateOrGetTranspObjectOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetAllocateOrGetTranspObjectOrNull(Dcm_NetConnRefMemType connId)
{
  Dcm_NetTransportObjectPtrType pTranspObj = NULL_PTR; /* No free transport object found */

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(connId >= Dcm_PbCfgNetNumConnections)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETALLOCATEORGETTRANSPOBJECT);
  }
  else
#endif
  {
    if(Dcm_PbRamNetConnId2TObjMap[connId] >= DCM_NET_INVALID_TOBJID)/* check if already assigned */
    {
      Dcm_CfgNetTObjHandleOptType lTObjIter;

      for(lTObjIter = 0; lTObjIter < Dcm_PbCfgNetNumTransportObjects; ++lTObjIter)
      {
        if(Dcm_PbRamNetTransportObject[lTObjIter].State == DCM_NET_TOBJ_STATE_FREE)
        {
          Dcm_NetPutToConn2TObjMap(connId, (Dcm_CfgNetTObjHandleMemType)lTObjIter); /* Assign ownership information */
          pTranspObj = Dcm_NetGetTransportObject(lTObjIter);
          break;
        }/* Transport Object is in use - check next one */
      }
    }
    else
    {
      pTranspObj = Dcm_NetGetTransportObject(Dcm_PbRamNetConnId2TObjMap[connId]);
    }
  }
  return pTranspObj;
}

/**********************************************************************************************************************
 *  Dcm_NetGetTranspObjOfConnectionOrNull()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetConnRefMemType connId)
{
  Dcm_NetTransportObjectPtrType pTranspObj = NULL_PTR;

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(connId >= Dcm_PbCfgNetNumConnections)
  {
    Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETGETTRANSPOBJOFCONNECTION);
  }
  else
#endif
  {
    if(Dcm_PbRamNetConnId2TObjMap[connId] < DCM_NET_INVALID_TOBJID)
    {
      pTranspObj = Dcm_NetGetTransportObject(Dcm_PbRamNetConnId2TObjMap[connId]);
    }
  }

  return pTranspObj;
}

/**********************************************************************************************************************
 *  Dcm_NetTranspObjRelease()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTranspObjRelease(Dcm_NetTransportObjectPtrType pTranspObj)
{
  /* #10 If the transport object is still in use: */
  if(pTranspObj->State != DCM_NET_TOBJ_STATE_FREE) /* assure the object has validly initialized fields */
  {
    /* #20 Its states are valid and can be used if needed */
    /* #30 Reset only the relevant states of the transport object */
    Dcm_NetPutToConn2TObjMap(pTranspObj->ConnId, DCM_NET_INVALID_TOBJID); /* Clear the ownership information */
    pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_NONE;                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    pTranspObj->Flags   = DCM_NET_TOBJ_FLAG_NONE;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    /* #40 Reset the guard state (object in use) at last to avoid critical section usage */
    pTranspObj->State   = DCM_NET_TOBJ_STATE_FREE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  /* #50 Otherwise nothing to do */
}

/**********************************************************************************************************************
 *  Dcm_NetGetConnIdByTesterAddress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_NetGetConnIdByTesterAddress(uint16 testerAddress)
{
  Dcm_NetConnRefOptType lConnIter;
  Dcm_NetConnRefMemType lResult = DCM_NET_INVALID_CONNID;

  for(lConnIter = 0; lConnIter < Dcm_PbCfgNetNumConnections; ++lConnIter)
  {
    if (testerAddress == Dcm_PbCfgNetConnectionInfo[lConnIter].ClientSrcAddr)
    {
      lResult = (Dcm_NetConnRefMemType)lConnIter;
      break;
    }
  }
  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetUsdtTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUsdtTxConfirmation(Dcm_NetTransportObjectPtrType pTranspObj
                                                        ,Dcm_NetTransmissionResultType result)
{
#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0)
  {
    Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    /* ComM is already released in the DiagPostProcessing task */
    Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
#endif
  {
#if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON) || \
    (DCM_NET_PROTOCOL_SWITCH_NOTIFICATION_ENABLED == STD_ON)
    if(pTranspObj->ResType == DCM_NET_TOBJ_RESTYPE_SIMPLE)
    {
      Dcm_NetUnRegisterComMActivity(pTranspObj->ConnId);
      Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
#endif
    {
      Dcm_DiagOnTxFinished(pTranspObj, result);                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
}
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutPeriodicTx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutPeriodicTx(void)
{
  Dcm_TmrTimerCntrMemType lReloadTick;
  boolean                 lDoReload;

  lDoReload = Dcm_OnTimeoutTxObjectHandler();
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
  lDoReload |= Dcm_OnTimeoutDelayTimerHandler();
# endif

  lReloadTick = (Dcm_TmrTimerCntrMemType)((lDoReload == TRUE)?1u:0u);

  return lReloadTick;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_CfgNetPTxObjHandleMemType, DCM_CODE) Dcm_NetPeriodicMsgAllocate(uint16 Did)
{
  Dcm_CfgNetPTxObjHandleMemType perTxObjHandle = DCM_NET_INVALID_PTXOBJ_HANDLE;

  /* If all queued messages were sent, reset counters (continue with highest prio UUDT) */
  if(Dcm_NetPeriodicMsgGetNextMsgHdl() == Dcm_NetPeriodicMsgGetTxObjectSentCntr())
  {
    /* Note: No critical section needed to avoid interrupt by Dcm_NetPeriodicMsgRelease because at this point, all
     *       messages are already sent and so no more notification interrupt can occur */
    Dcm_NetPeriodicMsgResetNextMsgHdl();
    Dcm_NetPeriodicMsgResetTxObjectSentCntr();
  }

  /* If there is a message ID left that has a lower priority: */
  if(Dcm_NetPeriodicMsgGetNextMsgHdl() < Dcm_NetPeriodicMsgNumMsgsCurrConnection())
  {
    Dcm_PbRamNetPeriodicTxObject[Dcm_NetPeriodicMsgGetNextMsgHdl()].State = DCM_NET_PERIODIC_TX_STATE_RESERVED; /* Mark tx object as reserved */
    Dcm_PbRamNetPeriodicTxObject[Dcm_NetPeriodicMsgGetNextMsgHdl()].Did = Did; /* Store the DID */
    perTxObjHandle = (Dcm_CfgNetPTxObjHandleMemType)Dcm_NetPeriodicMsgGetNextMsgHdl();
    Dcm_NetPeriodicMsgIncNextMsgHdl(); /* Increment message handle for next message */                                                               /* PRQA S 3109, 3355, 3358 */ /* MD_Dcm_CfgDepend_3109, MD_Dcm_3355, MD_Dcm_3358 */
  }

  return perTxObjHandle;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgRelease()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgRelease(Dcm_CfgNetPTxObjHandleOptType perTxObjHandle)
{
  Dcm_DebugAssert((perTxObjHandle < Dcm_NetPeriodicMsgNumMsgsCurrConnection()), DCM_SID_INTERNAL, DCM_E_PARAM)                                       /* COV_DCM_RTM_DEV_DEBUG XF */

# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  if (Dcm_PbRamNetPeriodicTxObject[perTxObjHandle].State == DCM_NET_PERIODIC_TX_STATE_ONTX)
  {
    Dcm_NetPTxDelayTimerStart(); /* start delay timer */
  }
# endif

  Dcm_NetPTxObjTimerStop(perTxObjHandle);                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
  Dcm_PbRamNetPeriodicTxObject[perTxObjHandle].State = DCM_NET_PERIODIC_TX_STATE_FREE;

  Dcm_NetPeriodicMsgIncTxObjectSentCntr(); /* Update sent message statistics */
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmit(Dcm_CfgNetPTxObjHandleOptType perTxObjHandle,
                                                          PduLengthType length)
{
  Dcm_DebugAssert((Dcm_NetPeriodicMsgGetConnection() < DCM_NET_INVALID_CONNID), DCM_SID_INTERNAL, DCM_E_PARAM)                                       /* COV_DCM_RTM_DEV_DEBUG XF */
  Dcm_DebugAssert((perTxObjHandle < Dcm_NetPeriodicMsgNumMsgsCurrConnection()), DCM_SID_INTERNAL, DCM_E_PARAM)                                       /* COV_DCM_RTM_DEV_DEBUG XF */

# if (DCM_NET_PERIODIC_MSG_PADDING_ENABLED == STD_ON)
  while(length < DCM_NET_PERIODIC_BUFFER_SIZE)
  {
    Dcm_PbRamNetPeriodicTxObject[perTxObjHandle].TxPduInfo.SduDataPtr[length] = DCM_NET_PERIODIC_MSG_PADDING_PATTERN;
    ++length;
  }
# endif
  Dcm_PbRamNetPeriodicTxObject[perTxObjHandle].TxPduInfo.SduLength = length;

# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  if (Dcm_NetPeriodicMsgGetDelayCntr() == 0)
  {
    Dcm_PbRamNetPeriodicTxObject[perTxObjHandle].State = DCM_NET_PERIODIC_TX_STATE_QUEUED;
  }
  else
# endif
  {
    Dcm_NetPeriodicMsgTransmitTxObj(perTxObjHandle);
  }
}
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetProvideRxBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetProvideRxBuffer(PduIdType DcmRxPduId
                                                              ,PduLengthType TpSduLength
                                                              ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) *PduInfoPtr
                                                              ,Dcm_NetTransportObjectFlagType addTObjFlags)
{
  BufReq_ReturnType lResult = BUFREQ_E_NOT_OK;
  Dcm_NetConnRefMemType lConnId = Dcm_NetGetConnIdOfRxPduId(DcmRxPduId);

  /* #10 If the communication state allows any diagnostic request reception (at least SilentCommunicationMode): */
  if( ((DCM_NET_COMM_STATE_FLAG_RX_EN & Dcm_NetGetComStateByConnection(lConnId)) != 0)
# if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
      && (Dcm_SingletonContext.Network.RxAllowed == TRUE)
# endif
      )
  {
    Dcm_NetTransportObjectPtrType pTranspObj;

    /* #20 Enter critical section (Reason: Needed only on multi-channel DCM configurations to guarantee the correct
     * transport object allocation and initialization) */
    Dcm_NetMultiChannelEnterCS();                                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    /* #30 Allocate new or get existing, already associated with this DcmRxPduId transport object */
    pTranspObj = Dcm_NetAllocateOrGetTranspObjectOrNull(lConnId);

    /* #40 If allocation or getter succeeded: */
    if(pTranspObj != NULL_PTR)
    {
      /* #50 If the transport object is allocated as a new one: */
      if(pTranspObj->State == DCM_NET_TOBJ_STATE_FREE)
      {
        Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

        pTranspObj->BufferHdl = Dcm_NetGetProtObjOfConnection(lConnId)->RxTxBufferRef;                                                               /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

        /* #60 If the request message length fits the Rx-buffer associated with the DcmRxPduId: */
        if(TpSduLength <= lBufferInfo->Size)
        {
          Dcm_NetBufferContextPtrType pBufferContext;

          /* #70 Prepare for positive result or NRC 0x21 response: */
          pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

          /* Store relevant information for later use */
          pTranspObj->RxPduId = DcmRxPduId;                                                                                                          /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->ConnId  = (Dcm_NetConnRefMemType)lConnId;                                                                                      /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->BuffPos = 0u;                                       /* start writing from the buffer begin */                                  /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->State   = DCM_NET_TOBJ_STATE_ONRX;                                                                                             /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */

          /* #80 If the new request can be received - that is: */
          if( Dcm_NetBufferIsFree(pBufferContext) /* Buffer is free */
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
            &&( ((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) != 0) /* a default session is/will be active */
              || (Dcm_NetGetSessionConnection() == lConnId) /* the owner of the (non-default) session */
#  if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
              || (Dcm_NetGetProtObjOfConnection(lConnId)->Priority
                < Dcm_NetGetProtObjOfConnection(Dcm_NetGetSessionConnection())->Priority ) /* higher priority -> let it through */
#  endif
              )
# endif
            )
          {
            /* #90 Lock the buffer and allow further request reception */
            Dcm_NetBufferLock(pBufferContext); /* the buffer is in use now */                                                                        /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
            /* Report available buffer */
            pTranspObj->BuffInfo.SduDataPtr = lBufferInfo->BufferPtr;                                                                                /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            pTranspObj->BuffInfo.SduLength  = lBufferInfo->Size;                                                                                     /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            pTranspObj->Flags = addTObjFlags;                                                                                                        /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            lResult = BUFREQ_OK;
          }
# if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
          else
          {
            /* #100 Otherwise, prepare for pseudo request reception (only SID and sub-function will be copied)
             * (if multiple client environment enabled) */
            /* offset=1, so SID and SUBSID are written to the correct position */
            pTranspObj->BuffInfo.SduDataPtr = &(pTranspObj->AddBuffer[1]);                                                                           /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            pTranspObj->BuffInfo.SduLength  = 7u;                                                                                                    /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            /* no free "real buffer" object - ignore or simulate reception for NRC 0x21 */
            pTranspObj->Flags = (Dcm_NetTransportObjectFlagType)(addTObjFlags | DCM_NET_TOBJ_FLAG_BUSY);                                             /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            lResult = BUFREQ_OK;
          }
# endif
        }
        else
        {
          /* #110 Otherwise, reject the message reception with the result "message too long" */
          lResult = BUFREQ_E_OVFL;
        }

        /* #120 If the message reception is to be continued, register the client connection as active  */
        if(lResult == BUFREQ_OK)
        {
          pTranspObj->RxData   = pTranspObj->BuffInfo.SduDataPtr;                                                                                    /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          /* safe cast, since tpSduLength <= bufferSize = value fits Dcm_CfgNetBufferSizeMemType */
          pTranspObj->RxLength = (Dcm_CfgNetBufferSizeMemType)TpSduLength;                                                                           /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          *PduInfoPtr = &pTranspObj->BuffInfo;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
          Dcm_NetRegisterActiveConnection(pTranspObj);                                                                                               /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        }
        else
        {
          /* #130 Otherwise, release the allocated transport object */
          Dcm_NetTranspObjRelease(pTranspObj);/* no further processing needed */                                                                     /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        }
      }
# if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      else
      {
        /* #150 If parallel reception is in progress, continue to use temporary buffer */
        if ( (pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX) &&
             (pTranspObj->RxPduId == DcmRxPduId) &&
             ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) != 0) )
        {
          /* offset=3, so received SID is left in byte[1], SubSID in byte[2]; received data will be discarded anyway */
          pTranspObj->BuffInfo.SduDataPtr = &(pTranspObj->AddBuffer[3]);                                                                             /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->BuffInfo.SduLength  = 7u;                                                                                                      /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          lResult = BUFREQ_OK;
        } /* #160 Otherwise, reception is neither real nor simulated - ignore reception */
      }
# endif
    }/* #170 Otherwise, no free transport object found (more clients than transport objects configured, legal use case
      * to save resources) - reject the message reception */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* #180 Leave critical section */
    Dcm_NetMultiChannelLeaveCS();                                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
  } /* #190 Otherwise, reject the message reception */
  return lResult;
} /* Dcm_NetProvideRxBuffer */                                                                                                                       /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetSetComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetSetComModeEntered(NetworkHandleType networkId
                                                       ,Dcm_NetComMStateType newComState)
{
  /* used to always verify for valid parameter */
  sint16_least lDcmComMHandle = Dcm_UtiLookUpUint8(Dcm_PbCfgNetNetworkHdlLookUp, networkId);                                                         /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  if(lDcmComMHandle >= 0) /* consider only DCM relevant channels */
  {
    Dcm_NetComMContextPtrType pComMContext;

    pComMContext = Dcm_NetGetComMContext((Dcm_CfgNetNetIdRefOptType)lDcmComMHandle);

    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    pComMContext->ComState = newComState;                                                                                                            /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }/* else - not a DCM channel -> ignore */
}

/**********************************************************************************************************************
 *  Dcm_NetStartOfReception()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetStartOfReception(PduIdType rxPduId
                                                                   ,PduLengthType tpSduLength
                                                                   ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr
                                                                   ,Dcm_NetTransportObjectFlagType addTObjFlags)
{
  BufReq_ReturnType lResult = BUFREQ_E_NOT_OK;
  Dcm_NetConnRefMemType lConnId = Dcm_NetGetConnIdOfRxPduId(rxPduId);

  /* #10 If the communication state allows any diagnostic request reception (at least SilentCommunicationMode): */
  if( ((DCM_NET_COMM_STATE_FLAG_RX_EN & Dcm_NetGetComStateByConnection(lConnId)) != 0)
# if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
    &&(Dcm_SingletonContext.Network.RxAllowed == TRUE)
# endif
    )
  {
    Dcm_NetTransportObjectPtrType pTranspObj;

    /* #20 Enter critical section (Reason: Needed only on multi-channel DCM configurations to guarantee the correct
     * transport object allocation and initialization) */
    Dcm_NetMultiChannelEnterCS();                                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    /* #30 Allocate new or get existing, already associated with this DcmRxPduId transport object */
    pTranspObj = Dcm_NetAllocateOrGetTranspObjectOrNull(lConnId);

    /* #40 If allocation or getter succeeded: */
    if(pTranspObj != NULL_PTR)
    {
      /* #50 If the transport object is allocated as a new one: */
      if(pTranspObj->State == DCM_NET_TOBJ_STATE_FREE)
      {
        Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

        pTranspObj->BufferHdl = Dcm_NetGetProtObjOfConnection(lConnId)->RxTxBufferRef;                                                               /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

        /* #60 If the request message length fits the Rx-buffer associated with the DcmRxPduId: */
        if(tpSduLength <= lBufferInfo->Size)
        {
          Dcm_NetBufferContextPtrType pBufferContext;

          /* #70 Prepare for positive result or NRC 0x21 response: */
          pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
          /* Prepare result to be reported for the available Rx-buffer size */
          *bufferSizePtr = lBufferInfo->Size;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */

          /* Initialize the transport object */
          pTranspObj->RxPduId  = rxPduId;                                                                                                            /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->ConnId   = (Dcm_NetConnRefMemType)lConnId;                                                                                     /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */

          /* Set up Rx message context */
          pTranspObj->RxLength = (Dcm_CfgNetBufferSizeMemType)tpSduLength;/* safe cast, since tpSduLength <= bufferSize = value fits Dcm_CfgNetBufferSizeMemType */ /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->BuffPos  = 0u; /* start writing from the buffer begin */                                                                       /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->State    = DCM_NET_TOBJ_STATE_ONRX;                                                                                            /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->Flags    = addTObjFlags;                                                                                                       /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */

          /* #80 If the new request can be received - that is: */
          if( Dcm_NetBufferIsFree(pBufferContext) /* Is the buffer free? */
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
            &&( ((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) != 0) /* a default session is/will be active */
              || (Dcm_NetGetSessionConnection() == lConnId) /* the owner of the (non-default) session */
#  if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
              || (Dcm_NetGetProtObjOfConnection(lConnId)->Priority
                < Dcm_NetGetProtObjOfConnection(Dcm_NetGetSessionConnection())->Priority ) /* higher priority -> let it through */
#  endif
              )
# endif
            )
          {
            /* #90 Lock the buffer and allow further request reception */
            pTranspObj->RxData = lBufferInfo->BufferPtr;                                                                                             /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            Dcm_NetBufferLock(pBufferContext); /* the buffer is in use now */                                                                        /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
            lResult = BUFREQ_OK;
          }
# if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
          else
          {
            /* #100 Otherwise, prepare for pseudo request reception (only SID and sub-function will be copied) (if multiple client environment enabled) */
            pTranspObj->RxData = &pTranspObj->AddBuffer[1];                                                                                          /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            /* no free "real buffer" object - ignore or simulate reception for NRC 0x21 */
            pTranspObj->Flags |= (Dcm_NetTransportObjectFlagType)(DCM_NET_TOBJ_FLAG_BUSY| DCM_NET_TOBJ_FLAG_COPYHEAD);                               /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            lResult = BUFREQ_OK;
          }
# endif
        }
        else
        {
          /* #110 Otherwise, reject the message reception with the result "message too long" */
          lResult = BUFREQ_E_OVFL;
        }

        /* #120 If the message reception is to be continued, register the client connection as active  */
        if(lResult == BUFREQ_OK)
        {
          Dcm_NetRegisterActiveConnection(pTranspObj);                                                                                               /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        }
        else
        {
          /* #130 Otherwise, release the allocated transport object */
          Dcm_NetTranspObjRelease(pTranspObj);/* no further processing needed */                                                                     /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        }
      }/* #140 Otherwise, the transport object is already in use (i.e. parallel request from the same tester):
        *   - reject the message reception */
    }/* #150 Otherwise, no free transport object found (more clients than transport objects configured, legal use case
      * to save resources) - reject the message reception */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* #160 Leave critical section */
    Dcm_NetMultiChannelLeaveCS();                                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
  } /* #170 Otherwise, reject the message reception */
  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferCancel(Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lResult = DCM_E_OK;

  /* If page buffer is currently activated: */
  if(Dcm_InstanceContext.PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE)
  {
    /* If not all data was written by the application: */
    if(Dcm_InstanceContext.PagedBuffer.UpdateFinished == FALSE)
    {
      /* Notify the application about the cancellation */
      Dcm_DiagSvcCancelFuncType lCancelFunc = Dcm_DiagGetCancelFunc(Dcm_InstanceContext.PagedBuffer.CancelFuncRef);

      lCancelFunc();                                                                                                                                 /* SBSW_DCM_CALL_FUNCPTR_SVCCANCELLERS */
    }

    /* If no transmission was started yet: */
    if(Dcm_InstanceContext.PagedBuffer.State == DCM_PAGEDBUFFER_STATE_ACTIVATED)                                                                     /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
    {
      /* Send the appropriate NRC by using the linear buffer if needed */
      *ErrorCode = DCM_DIAG_CANCEL_OP_NRC;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = DCM_E_NOT_OK;
    }

    /* Reset page buffer state */
    Dcm_PagedBufferInit();
    /* Clear any pending events in the Dcm_PagedBufferTask() to avoid any further processing */
    Dcm_TskClrEvent(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_ALL_EVENTS);
  }

  return lResult;
}
#endif /* (DCM_PAGED_BUFFER_ENABLED == STD_ON) */

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferTask(Dcm_TskTaskEvOptType ev
                                                  ,Dcm_TskTaskEvPtrType pPostEv)
{
  Std_ReturnType               lStdResult;
  Dcm_NetBufferContextPtrType  pBufferContext;
  Dcm_NegativeResponseCodeType lNrc;

  DCM_IGNORE_UNREF_PARAM(ev);                                                                                                                        /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* currently no other events are possible to be set for this task -> no need to check any flags */
# if (DCM_TSK_EV_PGDBUF_MSB != 0x01u)
#  error "New events have been added Dcm_PagedBufferTask! Make set event check here!"
# endif

  pBufferContext = Dcm_NetGetBufferContext(Dcm_InstanceContext.PagedBuffer.BufferHdl);

  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* If any diagnostic job is open: */
  if( ((Dcm_InstanceContext.Diag.State & (DCM_DIAG_STATE_PROCESS | DCM_DIAG_STATE_ON_TX)) != 0)
    && (!Dcm_NetBufferIsFree(pBufferContext)) )                                                                                                      /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX tx tx */
  {
    /* Avoid buffer releasing on asynchronous TxConfirmation with failed status */
    Dcm_NetBufferUsageEnter(pBufferContext);                                                                                                         /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* Update paged data */
    lStdResult = Dcm_PagedBufferUpdatePage(&lNrc);                                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */

    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_NetBufferUsageLeave(pBufferContext);                                                                                                         /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */

    /* If the application needs more time: */
    if(lStdResult == DCM_E_PENDING)
    {
      /* If the paged-buffer was not the last user, try getting data again */
      if(!Dcm_NetBufferIsFree(pBufferContext))                                                                                                       /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
      {
        Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_PGDBUF_UPDATE_PAGE);                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
      }/* else - buffer is free - no more data is to be expected */
    }/* else - that is all */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if (lStdResult == DCM_E_NOT_OK)
    {
      Dcm_SetNegResponse(lNrc);
      Dcm_ProcessingDone();
    }
  }
  else
  {
   /*=================================*
    END CRITICAL SECTION
    *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferStart(Dcm_MsgLenType resDataLen)
{
  /* Once multiple multi frame response started, can not be started again */
  Dcm_DebugAssert((Dcm_InstanceContext.PagedBuffer.State == DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                  /* COV_DCM_RTM_DEV_DEBUG XF */
  /* No multiple multi frame response if a NRC has been already registered */
  Dcm_DebugAssert((Dcm_InstanceContext.Diag.ErrorRegister == DCM_E_OK), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                       /* COV_DCM_RTM_DEV_DEBUG XF */

  /*  Initialize paged-buffer response transmission */
  Dcm_InstanceContext.PagedBuffer.UpdateFuncRef  = Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].UpdateFuncRef;
  Dcm_InstanceContext.PagedBuffer.CancelFuncRef  = Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].CancelFuncRef;
  Dcm_InstanceContext.PagedBuffer.BufferHdl      = Dcm_DiagGetTranspObj()->BufferHdl;
  Dcm_InstanceContext.PagedBuffer.WriteIndex     = (Dcm_CfgNetBufferSizeMemType)(Dcm_InstanceContext.Diag.MsgContext.resDataLen
                                                                               + Dcm_InstanceContext.Diag.MsgContext.resProtHeadLen); /* Write behind SId and the prepared data */
  Dcm_InstanceContext.PagedBuffer.ReadIndex      = 0u;
  Dcm_InstanceContext.PagedBuffer.RemainingLen   = resDataLen; /* Keep track of response data to be copied */
  Dcm_InstanceContext.PagedBuffer.State          = DCM_PAGEDBUFFER_STATE_ACTIVATED;
  Dcm_InstanceContext.PagedBuffer.UpdateFinished = FALSE;
  Dcm_InstanceContext.PagedBuffer.UpdaterDataProvisionState = DCM_PAGEDBUFFER_WAIT_FOR_DATA;

  /*  Calculate total response length, considering any already linearly written data */
  Dcm_InstanceContext.Diag.MsgContext.resDataLen += (Dcm_MsgLenType)resDataLen;

  /*  Initiate paged-data reader */
  Dcm_TskSetEvent(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_PGDBUF_UPDATE_PAGE);
}
#endif
/**********************************************************************************************************************
 *  Dcm_RepeaterExecute()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_RepeaterExecute(Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

#if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  Dcm_OpStatusType opStatusBckp = Dcm_InstanceContext.Repeater.Contexts.OpStatus;/* make a backup in case the processor uses the Dcm_RepeaterSetCallee API */
#endif

  DCM_UTIRTLMTR_CTR_INIT
  DCM_UTI_LOOP_FOR_EVER
  {
    Dcm_CfgDiagServiceInfoPtrType pServiceInfo;

    pServiceInfo = Dcm_CfgDiagServiceInfoGetEntryOrNull(Dcm_InstanceContext.Repeater.CalleeIdx);

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    if (pServiceInfo == NULL_PTR)                                                                                                                    /* COV_DCM_RTM_RUNTIME_CHECK XF */
    {
      *ErrorCode = DCM_E_PANIC_NRC;/* always return the panic NRC! */                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;/* enforce finalization  (allows post-handling and thus resource release event */
    }
    else
#endif
    {
      lStdResult = pServiceInfo->ProcFunc(Dcm_InstanceContext.Repeater.Contexts.OpStatus
                                        ,&Dcm_InstanceContext.Diag.MsgContext
                                        ,ErrorCode);                                                                                                 /* SBSW_DCM_CALL_FUNCPTR_SERVICEINFO */
    }

#if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
    if(opStatusBckp == DCM_CANCEL)
    {
# if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
      if(Dcm_InstanceContext.Repeater.Contexts.User == DCM_REPEATER_USER_DEM)
      {
        Dcm_DemAPI_CancelOperation();/* signal to DEM not to expect any further calls */
      }
# endif
# if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
      Dcm_DidMgrCancelOperation();
# endif
      *ErrorCode = DCM_DIAG_CANCEL_OP_NRC;/* always return the cancellation NRC! */                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;/* enforce finalization */
    }
#endif
    if(lStdResult != DCM_E_LOOP)
    {
      break;
    }/* else - just loop again */

    Dcm_RepeaterResetOpStatus();

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending") */
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING_LIMITER) /* signal retry */                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  return lStdResult;
}
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODEMGR_MONITORING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeTaskMonitor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeTaskMonitor(Dcm_TskTaskEvOptType ev
                                                  ,Dcm_TskTaskEvPtrType pPostEv)
{
#  if (DCM_MODE_CTRLDTCSETTING_MONITOR_ENABLED == STD_ON)
  /* If activated, monitor DTCsetting related mode-rule fulfillment */
  if( Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_MODE_MON_SVC85) )
  {
    Dcm_ModeMonitorControlDtcSetting(pPostEv);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#  endif

#  if (DCM_MODE_COMMCTRL_MONITOR_ENABLED == STD_ON)
  /* If activated, monitor CommunicationControl related mode-rule fulfillment */
  if( Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_MODE_MON_SVC28) )
  {
    Dcm_ModeMonitorCommunicationControl(pPostEv);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#  endif
}
# endif

# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchDtcSetting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchDtcSetting(Rte_ModeType_DcmControlDtcSetting newMode
                                                       ,uint32                            DTCGroup
                                                       ,uint8                             DemClientId)
{
  Std_ReturnType lStdResult;

  /* execute transition */
  lStdResult = Rte_Switch_DcmControlDtcSetting_DcmControlDtcSetting(newMode);

  DCM_IGNORE_UNREF_PARAM(lStdResult);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(DTCGroup);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(DemClientId);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

  /* Update local states */
  Dcm_ModeSetControlDtcSettingGroup(DTCGroup);
  Dcm_ModeSetControlDtcSettingMode(newMode);

#  if (DCM_MODE_CTRLDTCSETTING_MONITOR_ENABLED == STD_ON)
  if(newMode == RTE_MODE_DcmControlDtcSetting_DISABLEDTCSETTING)
  {
#   if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
    Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.LastDisableDTCClientID = DemClientId;
#   endif
    Dcm_TskSetEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC85);
  }
  else
  {
    Dcm_TskClrEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC85);
  }
#  endif
}
# endif

# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchCommControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchCommControl(Dcm_CfgNetNetIdRefOptType networkRef
                                                        ,Dcm_CommunicationModeType newMode)
{
  NetworkHandleType lNetwork = Dcm_PbCfgNetAllComMChannelMap[networkRef];

  Dcm_ModeArEnvBswMComControlModeChange(lNetwork, newMode);/* notify BswM */
  Dcm_ModeOnComControlModeChange(lNetwork, Dcm_ModeComCtrlModeMap[newMode]); /* notify the application */

  Dcm_ModeSetCommControlState(networkRef, newMode);

#  if (DCM_MODE_COMMCTRL_MONITOR_ENABLED == STD_ON)
  if((newMode & DCM_SVC_28_CTRL_OP_MASK) != 0)/* operation is with any disabling */
  {
    Dcm_TskSetEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC28);
  }
  else
  {
    Dcm_TskClrEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC28);
  }
#  endif
}
# endif
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_StateCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_StateCheck(Dcm_CfgStateRefOptType stateRef
                                                       ,Dcm_DiagCheckLvlType chkLevel
                                                       ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdReturn;

  /* Get the precondition package for the related diagnostic entity */
  CONSTP2CONST(Dcm_CfgStateDiagStateInfoType, AUTOMATIC, DCM_CONST) pStatePreconditions = &Dcm_StateGetPreconditionStates(stateRef);

  /* First verify the diagnostic session pre-condition (UDS verification order) */
  if(!Dcm_StateIsSupportedInSession(*pStatePreconditions))                                                                                           /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
  {
    /* If not met, return appropriate to UDS NRC for the evaluated diagnostic entity (i.e. NRC 0x7F for services, 0x7E for sub-functions etc.) */
    *ErrorCode = Dcm_StateSessionNrcs[chkLevel];                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  /* Otherwise, if supported, verify the security access level pre-condition (UDS verification order) */
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(!Dcm_StateIsSupportedInSecurityLevel(*pStatePreconditions))
  {

    /* If not met, do return NRC 0x33 (UDS) */
    *ErrorCode = DCM_E_SECURITYACCESSDENIED;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
#endif
  {
#if(DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
    /* Otherwise, if supported, get the the mode-related pre-condition expression(s) result */
    lStdReturn = Dcm_ModeCheck(Dcm_CfgStatePreconditions[stateRef].ModeRuleRef, ErrorCode);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
#else
    /* Otherwise, everything fine - return positive response code */
    lStdReturn = DCM_E_OK;
#endif
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_StateSetSession()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSession(Dcm_StateIndexOptType stateRef)
{
  Std_ReturnType lStdResult;

#if (DCM_SVC_86_RST_ON_DSC_ENABLED == STD_ON) || \
    (DCM_STATE_SESSION_NOTIFICATION_ENABLED == STD_ON)                                                                                               /* COV_DCM_SUPPORT_PARTIALLY TF xf tf */
  Dcm_CfgStateGroupOptType oldSession;

  oldSession = Dcm_SingletonContext.StateMgr.Preconditions.Session;
#endif

  /* #10 Commit the new diagnostic session */
  Dcm_SplitTaskEnterCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_SingletonContext.StateMgr.Preconditions.Session = Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, stateRef);
  Dcm_StateSyncPendingSession();
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

  /* #20 Notify application for a diagnostic session transition (also for self-transitions e.g. Default->Default): */
  lStdResult = Rte_Switch_DcmDiagnosticSessionControl_DcmDiagnosticSessionControl(Dcm_CfgStateSessionInfo[stateRef].Mode);

  Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK),DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

#if (DCM_STATE_SESSION_NOTIFICATION_ENABLED == STD_ON)
  Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateSessionNotificationInfo, Dcm_StateGetSessionValue(Dcm_UtiGetBitPosition(oldSession)), Dcm_StateGetSessionValue(stateRef)); /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
#endif

  /* #30 If the new session is the default one, reset all related internally handled diagnostic jobs (order irrelevant): */
  if(Dcm_StateIsDefaultSessionActive())
  {
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
    if(Dcm_SingletonContext.Network.KeepAlive == FALSE)
#endif
    {
      Dcm_NetUnRegisterAllComMActivity();
    }

#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
    /* fire and forget */
    (void)Dcm_Svc85EnableDtcSetting(Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.LastDisableDTCClientID);
#endif
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
    Dcm_Svc28EnableCommunication();
#endif
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
    Dcm_Svc2ASchdStopAll();
#endif
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
    Dcm_Svc2FReturnControlToEcu();
#endif
  }

  /* #40 On any diagnostic session transition (order irrelevant): */
#if (DCM_SVC_86_RST_ON_DSC_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
  /* Notify the diagnostic service 0x86 processor (if diagnostic service 0x86 is handled by DCM) */
  Dcm_ExtSvc86OnChangeSession(oldSession, Dcm_SingletonContext.StateMgr.Preconditions.Session);
#endif

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  /* Reset the security access level back to "locked" (if diagnostic service 0x27 is supported by the ECU configuration) */
  Dcm_StateSetSecurity(0);
#else
  /* Notify all service processors that are interested in a state change */
  Dcm_StateNotifyServiceProcessors();
#endif
  DCM_IGNORE_UNREF_PARAM(lStdResult);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateSetSecurity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSecurity(Dcm_StateIndexOptType stateRef)
{
# if (DCM_MODE_SECURITY_ACCESS_ENABLED == STD_ON) || \
     (DCM_STATE_SECURITY_NOTIFICATION_ENABLED == STD_ON)
  Dcm_CfgStateGroupOptType oldLevel;
# endif

# if (DCM_MODE_SECURITY_ACCESS_ENABLED == STD_ON) || \
     (DCM_STATE_SECURITY_NOTIFICATION_ENABLED == STD_ON)
  oldLevel = Dcm_SingletonContext.StateMgr.Preconditions.Security;
# endif
  /* #10 Commit the new security access level */
  Dcm_SingletonContext.StateMgr.Preconditions.Security = Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, stateRef);

  /* #20 Notify application for a security access level transition (only for non-self-transitions e.g. Locked->Level1): */
# if (DCM_MODE_SECURITY_ACCESS_ENABLED == STD_ON) || \
     (DCM_STATE_SECURITY_NOTIFICATION_ENABLED == STD_ON)
  if((oldLevel & Dcm_SingletonContext.StateMgr.Preconditions.Security) == 0) /* consider only non-self transitions (i.e. Locked->Locked) */
  {
#  if (DCM_MODE_SECURITY_ACCESS_ENABLED == STD_ON)
    Std_ReturnType                 lStdResult;
    Rte_ModeType_DcmSecurityAccess newMode;

    newMode = (Rte_ModeType_DcmSecurityAccess)((stateRef == 0)?RTE_MODE_DcmSecurityAccess_LockedLevel
                                                              :Dcm_CfgStateSecurityInfo[stateRef - 1].Mode);

    /* Notify application */
    lStdResult = Rte_Switch_DcmSecurityAccess_DcmSecurityAccess(newMode);

    DCM_IGNORE_UNREF_PARAM(lStdResult);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */
    Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
#  endif

#  if (DCM_STATE_SECURITY_NOTIFICATION_ENABLED == STD_ON)
    {
      Dcm_SecLevelType secLev = Dcm_UtiGetBitPosition(oldLevel); /* Local variable needed to avoid warnings for side-effects on macro Dcm_StateGetSecurityValue() */
      Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateSecurityNotificationInfo, Dcm_StateGetSecurityValue(secLev), Dcm_StateGetSecurityValue(stateRef));  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    }
#  endif
  }
# endif
  /* Notify all service processors that are interested in a state change */
  Dcm_StateNotifyServiceProcessors();
}
#endif
/**********************************************************************************************************************
 *  Dcm_TskScheduler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TskScheduler(Dcm_TskTaskPrioMemType tskPrio)
{
  Dcm_TskSchedulerContextPtrType pSchedulerContext;

  pSchedulerContext = Dcm_TskGetSchedulerContextOrNull(tskPrio);

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSchedulerContext != NULL_PTR)                                                                                                                 /* COV_DCM_RTM_RUNTIME_CHECK TX */
#endif
  {
    if(pSchedulerContext->SchdIsActive == TRUE)
    {
      Dcm_TskTaskIdOptType taskIter;
      Dcm_TskTaskEvOptType ev;

      /*
       * No interrupt protection needed since:
       * If a SetEvent is called and interrupts this assignment, then it sets this flag to true. Two scenarios are possible:
       * - The TRUE signal may be gone - it does not matter since the scheduler is already activated.
       * - The TRUE signal remains - in the worst case the scheduler will be executed once more later but will not have any active tasks.
       */
      pSchedulerContext->SchdIsActive = FALSE; /* per default - no active tasks any more. If any SetEvent executed during the task execution -> the flag will be set again */ /* SBSW_DCM_POINTER_WRITE_SCHEDULERCONTEXT */

      for(taskIter = 0; taskIter < DCM_TSK_NUM_TASKS; ++taskIter)
      {
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
        if(tskPrio == Dcm_TskTaskInfo[taskIter].TskPrio)
#endif
        {
          ev = Dcm_TskGetEvent(taskIter);
          if(ev != DCM_TSK_EV_NONE)
          {
            Dcm_TskExecuteActiveTask(taskIter, ev);
          }
        }
      }
    }
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
/**********************************************************************************************************************
 *  Dcm_TmrTaskTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TmrTaskTimer(Dcm_TskTaskEvOptType ev
                                               ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TmrMaskOptType    expiredTimers = 0u;
  Dcm_TmrTimerIdOptType timerIter;

#if (DCM_TSK_EV_TIMER_MSB != 0x01u)
# error "New events have been added for Dcm_TmrTaskTimer! Make set event check here!"
#endif
  /* the only event here is the DCM_TSK_EV_TIMER_ACTIVE. If not set, this task will not be called -> no additional event check is necessary */
  DCM_IGNORE_UNREF_PARAM(ev);                                                                                                                        /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Enter critical section (Reason: A timer can be modified from an ISR or higher priority task) */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Iterate over all system timers: */
  for(timerIter = 0; timerIter < DCM_TMR_NUM_TIMERS_CASTED; ++timerIter)
  {
    expiredTimers <<=1; /* next timer */
    /* If a timer is active (not yet expired or stopped), update its counter (decrement by one) */
    if(Dcm_SingletonContext.TimerMgr.Timer[timerIter] != 0u)
    {
      Dcm_TmrSetTimer(timerIter, Dcm_SingletonContext.TimerMgr.Timer[timerIter] - 1u);
      if(Dcm_SingletonContext.TimerMgr.Timer[timerIter] == 0u)
      {
        /* If the concrete timer did expire with the above step, register the timerId for later processing */
        expiredTimers |= 0x01u;
      }
      else
      {
        /* Otherwise, signal reactivation of this task again at next main-function cycle, since at least one timer still active */
        *pPostEv |= DCM_TSK_EV_TIMER_ACTIVE;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  /* Leave critical section */
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */

  /* Iterate over all expired timers only: */
  DCM_UTI_LOOP_BIT_SCAN(expiredTimers)
  {
    --timerIter; /* pre-decrement since the iterator equals at first DCM_TMR_NUM_TIMERS_CASTED */
    if((expiredTimers & 0x01u) != 0)
    {
      Dcm_TmrTimerInfoPtrType lTimerInfo;

      lTimerInfo = Dcm_TmrGetTimerInfoOrNull(timerIter);

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if(lTimerInfo != NULL_PTR)                                                                                                                     /* COV_DCM_RTM_RUNTIME_CHECK TX */
#endif
      {
        /* Invoke the associated with the timer "Dcm_OnTimeout*" handler function */
        Dcm_TmrTimerCntrMemType reloadTicks = lTimerInfo->ToFunc();                                                                                  /* SBSW_DCM_CALL_FUNCPTR_TIMERINFO */
        if(reloadTicks != 0)                                                                                                                         /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
        {
          /* If the handler requires an immediate reload of the timer, activate the timer immediately */
          Dcm_TmrStartTimer(timerIter, reloadTicks);
        }
      }
    }
  }
}
#if (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_RETVAL_TO_NRC_MAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiGetNrcForDemRetValue()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DemApiGetNrcForDemRetValue(uint8 demResult, Dcm_Uint8ConstDataPtrType demResult2NrcMap)
{
  Dcm_NegativeResponseCodeType lNrcResult = DCM_E_PANIC_NRC;

  /* Iterate over the "DEM result to NRC" using increment by two to visit each <key,value> pair */
  while(demResult2NrcMap[0] != E_OK) /*lint !e661 !e662 The EOM (EndOfMap) is marked by E_OK, since only negative results shall be used for mapping to NRC */
  {
    /* If a match is found, return the associated NRC */
    if(demResult2NrcMap[0] == demResult)
    {
      lNrcResult = demResult2NrcMap[1]; /*lint !e661 while-do loop prevents from out-of-bounds access */
      break;
    }
    /* Otherwise return the panic NRC */

    /* Increment by two for next map entry */
    demResult2NrcMap = &demResult2NrcMap[2]; /*lint !e662 while-do loop prevents from out-of-bounds access */
  }

#  if(DCM_DEV_ERROR_REPORT == STD_ON)
  /* Check if the DEM has returned an unexpected value (i.e. default case in a switch-case dispatcher) */
  if(demResult2NrcMap[0] == E_OK) /*lint !e661 !e662 The EOM (EndOfMap) is marked by E_OK, since only negative results shall be used for mapping to NRC */
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
  }
#  endif

  /* Return final result (concrete or panic NRC) */
  return lNrcResult;
}
# endif

# if (DCM_DEMAPI_GETNEXTFILTEREDITEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiConvDemRsltGetNextFilteredItem()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DemApiConvDemRsltGetNextFilteredItem(
                                                                         Dcm_DemReturnGetNextFilteredItemType demResult
                                                                        ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lDcmResult;
  switch(demResult)
  {
  case DCM_DEM_RET_FILTERED_NO_ITEMS:
    /* If no more items to be reported, signal data ready with eventual data padding */
    lDcmResult = DCM_E_DATA_READY_PADDING; /* signal end of list */
    break;
  case DCM_DEM_RET_FILTERED_PENDING:
    /* If Dem cannot provide next filtered item immediately, signal a retry */
    lDcmResult = DCM_E_PENDING;/* signal end of list */
    break;
#  if defined(DCM_DEM_RET_FILTERED_BUFFER_TOO_SMALL)                                                                                                 /* COV_DCM_SUPPORT_RESTRICTED TX */
  case DCM_DEM_RET_FILTERED_BUFFER_TOO_SMALL:
    /* If Dem cannot provide the data due to a too low buffer allocation, signal buffer overrun */
    lDcmResult = DCM_E_BUFFERTOOLOW;
    break;
#  endif
  default:
    /* Any other Dem result is treated as an error, thus signal job closing with panic NRC */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);

    lDcmResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  }
  return lDcmResult;
}
# endif
#endif /* (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_DYNDID_DEEP_CHECK_ON_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDynDidStateCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDynDidStateCheck(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_StateCheck(pDidInfoContext->Descriptor.DidOpInfoPtr->ExecCondRef, DCM_DIAG_CHK_LVL_PARAMETER, ErrorCode);
  if (lStdResult == DCM_E_OK)
  {
    if(Dcm_DidMgrIsOpSupported(pDidInfoContext->Descriptor.DidInfoPtr, DCM_DIDMGR_OP_DEFINE)) /* for DynDID check source states */
    {
      lStdResult = Dcm_Svc2CStateCheckSrcItems(pDidInfoContext->Descriptor.DidInfoPtr->OpRef, ErrorCode);
    }
  }/* else - ErrorCode already set */

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_CANCEL_OP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrCancelOperation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrCancelOperation(void)
{
  Dcm_DidMgrInitMainResources();
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLength(Dcm_OpStatusType                opStatus
                                                             ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                             ,Dcm_NegativeResponseCodePtrType errorCode)                                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
#   error "Only one signal (the last one of a DID) can have dynamic length!"
#  else
  Std_ReturnType lStdResult = DCM_E_OK;

  /* read length */
  if(Dcm_DidMgrIsOpTypeSupported(pDidInfoContext->Descriptor.DidOpInfoPtr, DCM_DIDMGR_OPTYPE_READLENGTH))
  {
    Dcm_DidMgrDidLengthType signalLength;

    Dcm_DidMgrGetOpClassInfo(pDidInfoContext, DCM_DIDMGR_OPTYPE_READLENGTH);
    lStdResult = Dcm_DidMgrReadLengthSignal(opStatus, pDidInfoContext, &signalLength, errorCode);

    if(lStdResult == DCM_E_OK)
    {
      /* Set concrete DID length */
      pDidInfoContext->DidLength = (uint16)(pDidInfoContext->Descriptor.DidInfoPtr->MinLength + signalLength);
    }
    /* else - DCM_E_PENDING, DCM_E_NOT_OK -> just delegate */
  }/* else - static length -> length already set in pDidInfoContext */
  return lStdResult;
#  endif
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadCheckCond()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadCheckCond(Dcm_OpStatusType opStatus
                                                                ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType errorCode)
{
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_CHKCOND_ENABLED == STD_ON)
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrOpTypeHandlerInit(pDidInfoContext, pDidOpTypeContext);
  }

  DCM_UTI_LOOP_FOR_EVER
  {
    lStdResult = Dcm_DidMgrReadCheckCondSignal(opStatus
                                              ,pDidOpTypeContext->Base.SignalOpList
                                              ,errorCode);
    if(lStdResult != DCM_E_OK)
    {
      /* on pending or not OK -> just leave */
      break;/* try later */
    }

    pDidOpTypeContext->Base.NumSignals--;
    if(pDidOpTypeContext->Base.NumSignals == 0u)
    {
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }
    /* next signal */
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalOpList,  1u);
    opStatus = DCM_INITIAL;/* reset op status */
  }

  return lStdResult;
#  else
  DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_DidMgrReadCheckCondSignal(opStatus
                                      ,pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr
                                      ,errorCode);
#  endif
}
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrGetDidOpInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrGetDidOpInfo(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                     ,Dcm_DidMgrOpOptType didOp)
{
  pDidInfoContext->Descriptor.DidOpInfoPtr = &Dcm_CfgDidMgrOpInfo[pDidInfoContext->Descriptor.DidInfoPtr->OpBaseIdx];
  /* 0x01 ->0x00 -> already found
   * 0x02 ->0x01 -> iterate once
   * .Etc */
  --didOp; /* there is always at least one operation configured */
  didOp &= pDidInfoContext->Descriptor.DidInfoPtr->Operations;  /* clear all flags above this operation index (not relevant) */

  while(didOp != 0)
  {
    Dcm_UtiNextItemByPtr(pDidInfoContext->Descriptor.DidOpInfoPtr,1u);
    didOp &= (Dcm_DidMgrOpOptType)(didOp - 1); /* clear the least significant bit set */
  }
}

/**********************************************************************************************************************
 *  Dcm_DidMgrGetOpClassInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrGetOpClassInfo(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                       ,Dcm_DidMgrOpCallOptType opType)
{
# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
  pDidInfoContext->Descriptor.DidOpClassInfoPtr = &Dcm_CfgDidMgrDidOpClassInfo[pDidInfoContext->Descriptor.DidOpInfoPtr->OpTypeBaseIdx];
# else
  pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr = &Dcm_CfgDidMgrSignalOpClassInfo[pDidInfoContext->Descriptor.DidOpInfoPtr->OpTypeBaseIdx];
# endif

  /* 0x01 ->0x00 -> already found
   * 0x02 ->0x01 -> iterate once
   * .Etc */
  --opType; /* there is always at least one operation configured */
  opType &= pDidInfoContext->Descriptor.DidOpInfoPtr->CallTypes; /* clear all flags above this operation index (not relevant) */

  while(opType != 0)
  {
# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
    Dcm_UtiNextItemByPtr(pDidInfoContext->Descriptor.DidOpClassInfoPtr, 1u);
# else
    Dcm_UtiNextItemByPtr(pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr,1u);
# endif
    opType &= (Dcm_DidMgrOpOptType)(opType - 1); /* clear the least significant bit set */
  }

# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
  pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr = &Dcm_CfgDidMgrSignalOpClassInfo[pDidInfoContext->Descriptor.DidOpClassInfoPtr->OpClassRef];
# endif
}

/**********************************************************************************************************************
 *  Dcm_DidMgrGetDidInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetDidInfo(Dcm_OpStatusType                  opStatus
                                                             ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                             ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                             ,Dcm_DidMgrOpOptType               didOp)
{
  Std_ReturnType  lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DIDMGR_ASYNC_LOOKUP_ENABLED == STD_ON)
  lStdReturn = DCM_E_NOT_OK;

  /* #10 On the very first call: */
  if(opStatus == DCM_INITIAL)
  {
    /* #20 Determine the lookup engine to run first (DID range or concrete DID) */
#  if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
    pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_DIDRANGE;
#  else
    pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_CONCRETEDID;
#  endif
  }
  /* #25 Otherwise: proceed with next steps */
# endif

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
  /* #30 If current progress is to (still) lookup for a DID range: */
  if(pDidOpTypeContext->OpType.LookUp.State == DCM_DIDMGR_LOOKUP_STATE_DIDRANGE)
  {
    /* #40 Delegate search to the DID range lookup engine */
    lStdReturn = Dcm_DidMgrDidRangeLookUp(opStatus, pDidInfoContext, didOp);

    /* #50 Evaluate result: */
#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
    if(opStatus == DCM_CANCEL)
    {
      /* #60 If the current call is a cancellation event: Terminate immediately any further processing */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
#  endif
    if(lStdReturn == DCM_E_NOT_OK)
    {
      /* #70 Otherwise: If no match found: Continue with concrete DID look up */
      pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_CONCRETEDID;
    }
    else
#  if (DCM_DIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
    if(lStdReturn == DCM_E_OK)
    {
      /* #80 Otherwise: If match found: Go on with optional DID look up result filtering */
      pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN;
    }
    else
#  endif
#  if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
    if(lStdReturn == DCM_E_LOOKUP_MATCH_FOUND)
    {
      /* #90 Otherwise: If range match found but it was a gap: Report DID as not supported */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
#  endif
    {
      /* #100 Otherwise: Just return the final result: (DCM_E_PENDING | DCM_E_OK (if no extended look up) | DCM_E_NOT_OK (if no gaps) ) */
    }
  }
  /* #110 Otherwise - keep current result: DCM_E_NOT_OK */
# endif

# if (DCM_DIDMGR_ASYNC_LOOKUP_ENABLED == STD_ON)
  /* #120 If current progress is to lookup for a concrete DID: */
  if(pDidOpTypeContext->OpType.LookUp.State == DCM_DIDMGR_LOOKUP_STATE_CONCRETEDID)
# endif
  {
    /* #130 Start concrete DID lookup engine */
    lStdReturn = Dcm_DidMgrConcreteDidLookUp(pDidInfoContext, didOp);

    /* #140 Evaluate result: */
# if (DCM_DIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
    if(lStdReturn == DCM_E_OK)
    {
      /* #150 If valid DID found: proceed with optional lookup result filtering */
      opStatus = DCM_INITIAL; /* Prepare for new asynchronous calling sequence */
      pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN;
    }
# endif
  }
  /* #155 Otherwise - keep current result: DCM_E_OK, DCM_E_NOT_OK, DCM_E_PENDING */

# if (DCM_DIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
  /* #160 If any valid DID(range) found: */
  if(pDidOpTypeContext->OpType.LookUp.State == DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN)
  {
    /* #170 Proceed with optional lookup result filtering */
    lStdReturn = Dcm_FilterDidLookUpResult(opStatus, pDidInfoContext->Did, (Dcm_DidOpType)didOp);

    /* #180 Evaluate result: */
#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
    if(opStatus == DCM_CANCEL)
    {
      /* #190 If the current call is a cancellation event: Terminate immediately any further processing */
      lStdReturn = DCM_E_NOT_OK;
    }
#  endif

#  if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    /* #200 If an valid/unexpected return value: */
    if( (lStdReturn != DCM_E_OK)
      &&(lStdReturn != DCM_E_PENDING)
      &&(lStdReturn != DCM_E_NOT_OK) )
    {
      /* #210 Unexpected return value is treated as "DID not supported" */
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      lStdReturn = DCM_E_NOT_OK;
    }
#  endif
  }
  /* #220 Otherwise - keep current result: DCM_E_OK, DCM_E_NOT_OK, DCM_E_PENDING */
# endif

  /* #230 If final result available and it is that the DID is supported: */
  if(lStdReturn == DCM_E_OK)
  {
    /* #240 Always perform standard filtering (variant, session, etc.) */
    lStdReturn = Dcm_DidMgrFilterDidLookUp(pDidInfoContext, didOp);

  }
  /* #250 Otherwise just return the current state or not supported DID: DCM_E_PENDING or DCM_E_NOT_OK */

  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrOpTypeHandlerInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrOpTypeHandlerInit(Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                          ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext)
{
  pDidOpTypeContext->Base.NumSignals          = (Dcm_CfgDidMgrSignalIterMemType)(pDidInfoContext->Descriptor.DidOpClassInfoPtr[1].OpClassRef
                                                                               - pDidInfoContext->Descriptor.DidOpClassInfoPtr[0].OpClassRef);/* number of operations to be iterated (number signals) */
  pDidOpTypeContext->Base.SignalOpList        = pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr;/* start position of the operations to be called */
  pDidOpTypeContext->Base.SignalInfoList      = &(Dcm_CfgDidMgrSignalInfo[pDidInfoContext->Descriptor.DidInfoPtr->SignalRef]);/* start position of the signal offsets */
}
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadDidLinear()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadDidLinear(Dcm_OpStatusType                  opStatus
                                                                ,Dcm_DiagDataContextPtrType        pDataContext
                                                                ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                ,Dcm_NegativeResponseCodePtrType   errorCode)
{
  /* #10 If multi signal is supported for read operation: */
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_ENABLED == STD_ON)
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* #20 Initialize DID handler */
    Dcm_DidMgrOpTypeHandlerInit(pDidInfoContext, pDidOpTypeContext);

    /* Commit a leading gap if applicable */
    Dcm_DiagCommitData(pDataContext, pDidOpTypeContext->Base.SignalInfoList->Offset);
    pDidOpTypeContext->OpType.Read.Offset = pDidOpTypeContext->Base.SignalInfoList->Offset;
  }

  /* #30 For each signal of the DID: */
  DCM_UTI_LOOP_FOR_EVER
  {
#   if (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
    Dcm_CfgNetBufferSizeMemType lSignalLen = pDidOpTypeContext->Base.SignalInfoList->Length;
#   endif

    /* #40 Read the signal data */
    lStdResult = Dcm_DidMgrReadSignal(opStatus
                                     ,pDataContext
                                     ,pDidInfoContext
                                     ,pDidOpTypeContext
                                     ,errorCode);

    /* #50 If the application needs more time or some error occurred: */
    if(lStdResult != DCM_E_OK)
    {
      /* #60 Just leave and try later if applicable */
      break;
    }

    pDidOpTypeContext->Base.NumSignals--;
    if(pDidOpTypeContext->Base.NumSignals == 0u)
    {
      /* Commit a trailing gap if applicable */
      Dcm_DiagCommitData(pDataContext, (Dcm_MsgLenType)(pDidInfoContext->DidLength - pDataContext->Usage));
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }

    /* Go on with next signal */
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalOpList,  1u);
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalInfoList, 1u);

#   if (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
    /* Commit any possible gap to the next signal */
    Dcm_DiagCommitData(pDataContext, (Dcm_MsgLenType)(pDidOpTypeContext->Base.SignalInfoList->Offset - lSignalLen));
#   endif
    pDidOpTypeContext->OpType.Read.Offset += (Dcm_CfgDidMgrOptimizedDidLengthType)(pDidOpTypeContext->Base.SignalInfoList->Offset);
    opStatus = DCM_INITIAL; /* reset op status */
  }

  return lStdResult;
#  else
  /* #70 Otherwise read the signal data */
  return Dcm_DidMgrReadSignal(opStatus
                             ,pDataContext
                             ,pDidInfoContext
                             ,pDidOpTypeContext
                             ,errorCode);
#  endif
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_Dcm_Design_6060 */
# endif /* (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_OFF) */

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadDidPaged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadDidPaged(Dcm_OpStatusType opStatus
                                                               ,Dcm_DiagDataContextPtrType pDataContext
                                                               ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                               ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                               ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType  lResult;

  /* #10 If any read operation has to be canceled: */
  if(opStatus == DCM_CANCEL)
  {
    lResult = DCM_E_NOT_OK;
    /* #20 If DID signal already in processing: */
    if(pDidOpTypeContext->OpType.Read.OpStatus != DCM_INITIAL)
    {
      /* #30 Notify application about cancellation */
      (void)Dcm_DidMgrReadSignal(opStatus
                                ,pDataContext
                                ,pDidInfoContext
                                ,pDidOpTypeContext
                                ,errorCode);
    } /* #40 Otherwise no cancellation shall be notified */
  }
  else  /* #50 If multi signal is supported for read operation: */
  {
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_ENABLED == STD_ON)
    if(opStatus == DCM_INITIAL)
    {
      /* #60 Initialize DID handler */
      Dcm_DidMgrOpTypeHandlerInit(pDidInfoContext, pDidOpTypeContext);
      pDidOpTypeContext->OpType.Read.Offset       = pDidOpTypeContext->Base.SignalInfoList->Offset;
      pDidOpTypeContext->OpType.Read.OpStatus     = DCM_INITIAL;
      pDidOpTypeContext->OpType.Read.Progress     = 0u;
    }

    /* #70 Read all signals */
    lResult = Dcm_DidMgrReadPagedMultiSignal(pDataContext, pDidInfoContext, pDidOpTypeContext,  errorCode);
#  else
    /* #80 Otherwise, if there is not enough buffer space available for the signal: */
    if( (pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr->FuncClass != DCM_DIDMGR_OPCLS_READ_PAGED)
      &&(pDataContext->AvailLen < pDidInfoContext->DidLength) )
    {
      /* #90 Try it the next task cycle */
      lResult = DCM_E_BUFFERTOOLOW;
    }
    else
    {
      /* #100 Otherwise, read the signal data */
      lResult = Dcm_DidMgrReadSignal(opStatus
                                    ,pDataContext
                                    ,pDidInfoContext
                                    ,pDidOpTypeContext
                                    ,errorCode);
    }
#  endif
  }
  return lResult;
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_Dcm_Design_6060 */
# endif /* (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) */
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(Dcm_DiagDataContextPtrType pDataContext
                                                                          ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                          ,Dcm_ObdDtcManagerContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  uint32                                lDtc;
  uint8                                 dtcStatus;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lStdResult = DCM_E_BUFFERTOOLOW;
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  while (pDataContext->AvailLen >= 2u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTC)(
# if (DCM_DEM_API_430_ENABLED == STD_ON)
                                               pRepContext->DemClientId,
# endif
                                               &lDtc, &dtcStatus);                                                                                   /* SBSW_DCM_POINTER_FORWARD_STACK */

    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_DiagProvideDataAsU8(pDataContext, Dcm_UtiGetHiLoByte(lDtc));                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_DiagProvideDataAsU8(pDataContext, Dcm_UtiGetLoHiByte(lDtc));                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult, ErrorCode);
      break;
    }
    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending") */
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING) /* signal retry */                                                                 /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrDemSetDTCFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrDemSetDTCFilter(uint8 StatusMask
                                                                 ,Dem_DTCOriginType Origin
                                                                 ,Dcm_MsgContextPtrType pMsgContext                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_ObdDtcManagerContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  if(pMsgContext->reqDataLen == 0u)
  {
    Dcm_DemReturnSetFilterType resultSetDtcFilter;

  resultSetDtcFilter = Dcm_DemAPI(SetDTCFilter)(
# if (DCM_DEM_API_430_ENABLED == STD_ON)
      pRepContext->DemClientId,
# endif
      StatusMask
# if (DCM_DEM_API_430_ENABLED == STD_OFF)
     ,DEM_DTC_KIND_EMISSION_REL_DTCS
# endif
     ,DEM_DTC_FORMAT_OBD
     ,Origin
     ,DCM_DEM_FILTER_WITH_SEVERITY_NO
     ,DEM_SEVERITY_NO_SEVERITY
     ,DCM_DEM_FILTER_FOR_FDC_NO);

    if(resultSetDtcFilter == DCM_DEM_RET_FILTER_ACCEPTED)
    {
      Dcm_ObdDtcMgrSetNextStep(DCM_OBDDTCMGR_PROGRESS_GETNUMFLTRDDTC, pRepContext);
      lStdReturn = DCM_E_LOOP;
    }
    else
    {/* else - set NRC */
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(resultSetDtcFilter, Dcm_DemApiNrcMapSetDTCFilter);                                                 /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrReadDtcByStatusMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE)Dcm_ObdDtcMgrReadDtcByStatusMask(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                 ,Dcm_ObdDtcManagerContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;

  switch (Dcm_ObdDtcMgrGetNextStep(pRepContext))
  {
  case DCM_OBDDTCMGR_PROGRESS_GETNUMFLTRDDTC:
    lStdResult = Dcm_ObdDtcMgrDemGetNumFltrdDtc(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_OFF)
  case DCM_OBDDTCMGR_PROGRESS_COPYLINEARDATA:
    lStdResult = Dcm_ObdDtcMgrCopyLinearData(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# endif
  default:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_TSK_NUM_DIAG_GARB_COL > 0)
/**********************************************************************************************************************
 *  Dcm_DiagTaskGarbageCollector()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskGarbageCollector(Dcm_TskTaskEvOptType ev
                                                           ,Dcm_TskTaskEvPtrType pPostEv)                                                            /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_CfgNetTObjHandleOptType lTObjCntr;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Cleanup or reject all transport objects that never succeeded and are now canceled */
  lTObjCntr = 0;
  DCM_TSK_EVENT_SCAN_LOOP(ev)
  {
    /* Check who shall be removed */
    if(Dcm_TskIsLocalEventSet(ev, 0x01u))
    {
      Dcm_NetTransportObjectPtrType pTranspObj;

      pTranspObj = Dcm_NetGetTransportObject(lTObjCntr);
      /* Always unregister ComM activity here, since CANCELED flag will not clean it up!
       * If no RCR-RP on transmission: everything has to be cleaned up here!
       */
      Dcm_NetUnRegisterComMActivity(pTranspObj->ConnId);

      /* If just requested, then only this TObject could be the trigger for P2 timer - avoid any RCR-RP transmission */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ) != 0)
      {
        Dcm_TskClrEvent(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_RCRRP);
      }

      Dcm_UtiArEnvEnterCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
      /*=================================*
       BEGIN CRITICAL SECTION
       *=================================*/
      /* Check if any RCR-RP for this object is on Tx (DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ is excluded since the high-prio
       * Dcm_DiagTaskTx() shall already have switched to ON_TX!) */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_RCRRP_ON_TX) != 0)
      {
        pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_CANCELED; /* isolate this connection */                                                               /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

        /* Try cancel any ongoing response. The return value does not matter:
         * OK -> there will be a confirmation for this cancellation
         * N_OK -> request rejected, but there will be a confirmation due to the ongoing transmission
         */
        (void)Dcm_NetArEnvPduRCancelTransmit(Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnId].TxPduIdMain);
        /* Any RCR-RP will just end with releasing the connection assigned to the tObject!
         * No confirmation post-processing will be performed! */
      }
      else
      {
        Dcm_NetBufferContextPtrType pBufferContext;

        pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
        Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                           /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
        Dcm_NetUnRegisterActiveConnection(pTranspObj); /* no further processing needed */                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      }
      /*=================================*
       END CRITICAL SECTION
       *=================================*/
      Dcm_UtiArEnvLeaveCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
    }
    ++lTObjCntr;
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

/**********************************************************************************************************************
 *  Dcm_DiagRcrRpTxFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRcrRpTxFinished(Dcm_NetTransportObjectPtrType pTranspObj                                                      /* COV_DCM_RTM_NO_RCR_RP_TX */ /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                      ,Dcm_NetTransmissionResultType txStatus)
{
  Dcm_InstanceContext.Diag.TxStatus   = txStatus;/* store current Tx state */

  pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_NONE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_ON_TX);                                                 /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */ /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_UtiBitOpSet(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_SENT);/* mark RCR-RP at least once sent state */        /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->State   = DCM_NET_TOBJ_STATE_READY;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */

  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_TX_END_RCRRP);  /* Notify for sent RCR_RP */
}

/**********************************************************************************************************************
 *  Dcm_DiagSetP2Timings()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagSetP2Timings(Dcm_StateIndexMemType sesStateIdx,
                                                    Dcm_NetProtRefMemType protocolIdx)
{
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
   BEGIN CRITICAL SECTION
   *=================================*/

  /* Calculate the current P2 timings considering the protocol related adjust timings */
  Dcm_InstanceContext.Diag.P2Timings.P2 = Dcm_DiagGetP2Time(sesStateIdx)
                                        - Dcm_NetGetP2AdjTime(protocolIdx);

  Dcm_InstanceContext.Diag.P2Timings.P2Star = Dcm_DiagGetP2StarTime(sesStateIdx)
                                            - Dcm_NetGetP2StarAdjTime(protocolIdx);

  /*=================================*
   END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagCancelProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagCancelProcessing(void)
{
  Dcm_TmrStopTimer(DCM_TMR_ID_P2);
  Dcm_TskKillAllTasks();
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_KILL_JOBS);
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRxIndication(Dcm_NetTransportObjectPtrType pTranspObj)                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

#if (DCM_DIAG_RST2DEF_ON_FUNC_OBD_REQ_ENABLED == STD_ON)                                                                                             /* COV_DCM_UNSUPPORTED XF */
  /* #10 Handle OBD requests (SID [0x00-0x0F]) when only one diagnostic client is used */
  if ( (pTranspObj->RxData[0] < 0x10u)
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
     &&(Dcm_PbCfgNetNumConnections == 1u)
# endif
     &&((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) == 0)
     &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE)
     )
  {
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);
    Dcm_DiagSetP2Timings(0, 0);
  }
#endif

#if (DCM_DIAG_SYNCH_FLAGS_ENABLED == STD_ON)
  /* #20 Update diagnostic kernel queue flags: */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_InstanceContext.Diag.QueuedSet.Flags |= DCM_DIAG_QUEUE_FLAG_IS_WAITING;
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
#endif

  /* #30 Prepare for new diagnostic request processing by setting all relevant for the real-time task properties: */
  Dcm_DiagSetQueuedTranspObj(pTranspObj);                                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_TmrStartTimer(DCM_TMR_ID_P2, Dcm_InstanceContext.Diag.P2Timings.P2);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.KeepAlive = TRUE;
#endif

  /* #40 Signal the Dcm_DiagTaskWorker that the request is now ready for processing */
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_RX, DCM_TSK_EV_DIAG_RX_NEW_REQ);
}

/**********************************************************************************************************************
 *  Dcm_DiagTxFinalization()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTxFinalization(Dcm_NetTransportObjectPtrType pTranspObj                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                     ,Dcm_NetTransmissionResultType txStatus)
{
  Dcm_InstanceContext.Diag.TxStatus = txStatus;
  Dcm_InstanceContext.Diag.State    = DCM_DIAG_STATE_POST_PROCESS;

#if (DCM_DIAG_SYNCH_FLAGS_ENABLED == STD_ON)
  Dcm_SplitTaskEnterCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_UtiBitOpClr(Dcm_DiagProcessorFlagType, Dcm_InstanceContext.Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_ACTIVE);                               /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
#endif

#if (DCM_DIAG_FAST_POST_PROCESSING_ENABLED == STD_ON)                                                                                                /* COV_DCM_SUPPORT_ALWAYS TX */
  if(((DCM_DIAG_APPL_NOTIFICATION_SVC_HDLR | DCM_DIAG_APPL_NOTIFICATION_SID_FOUND) & Dcm_InstanceContext.Diag.ApplNotification) != 0)
  {
    Dcm_DiagSvcConfirmationFuncType lFastConfFunc;
    Dcm_ConfirmationStatusType      lConfStatus;

    lFastConfFunc = Dcm_DiagGetPostProcessorFunc(Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].FastConfFuncRef);
    lConfStatus   = Dcm_DiagGetPostProcessResult();

    /* Execute any internal service processors fast-post-handlers */
    lFastConfFunc(lConfStatus);                                                                                                                      /* SBSW_DCM_CALL_FUNCPTR_SVCPOSTPROCESSORS */
  }
#endif
  /* release the connection */
#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
  if((DCM_NET_TOBJ_FLAG_CANCELED & pTranspObj->Flags) == 0) /* let the connection expire with the Tx confirmation (after CancelTransmit) */
#endif
  {
    Dcm_NetBufferContextPtrType pBufferContext;

    pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    Dcm_NetUnRegisterActiveConnection(pTranspObj);/* Start the S3 timer if needed here to have maximum real-time accuracy (from communication bus point of view) */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL);
}

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagOnFblResTxFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagOnFblResTxFinished(Dcm_NetTransportObjectPtrType pTranspObj                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                         ,Dcm_NetTransmissionResultType txStatus)
{
  Dcm_NetBufferContextPtrType pBufferContext;

  pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

  Dcm_NetBufferRelease(pBufferContext);                                                                                                              /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
  Dcm_NetUnRegisterActiveConnection(pTranspObj);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

  Dcm_InstanceContext.Diag.StartUpFbl.TxStatus = txStatus;
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_FBLRES, DCM_TSK_EV_DIAG_FBLRES_TXCONF);
}
#endif

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutFblRes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutFblRes(void)
{
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_FBLRES, DCM_TSK_EV_DIAG_FBLRES_CANCEL);
  return 0u;
}
#endif

/**********************************************************************************************************************
 *  Dcm_OnTimeoutP2()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutP2(void)                                                                              /* COV_DCM_RTM_NO_RCR_RP_TX */
{
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_RX, DCM_TSK_EV_DIAG_RX_TMR_P2_TO);
  return 0u;
}

/**********************************************************************************************************************
 *  Dcm_OnTimeoutS3()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutS3(void)
{
  if(!Dcm_StateIsDefaultSessionActive())
  {
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);
    Dcm_DiagSetP2Timings(0, Dcm_NetGetProtIdOfActiveProtocol());
  }
  return 0u;
}

#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutKeepAlive()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutKeepAlive(void)
{
  if(Dcm_StateIsDefaultSessionActive())                                                                                                              /* COV_DCM_RTM_DEPENDS_ON_CFG */
  {
    Dcm_NetUnRegisterAllComMActivity();
  } /* else - ComM activity will be unregistered by S3 timeout */

  Dcm_SingletonContext.Network.KeepAlive = FALSE;

  return 0u; /* No reload */
}
#endif

#if(DCM_DIAG_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagExecIndicationFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagExecIndicationFunc(Dcm_MsgItemType sid
                                                                   ,Dcm_DiagApplNotificationType notificationType
                                                                   ,Dcm_CfgDiagNotificationInfoPtrType notifList
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode)                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lResult = DCM_E_OK; /* positive case */
  uint16_least   lIter;

  Dcm_InstanceContext.Diag.ApplNotification |= notificationType; /* mark application has been notified */

  /* Prepare for post processing later */
  Dcm_InstanceContext.Diag.PostProcessorContext.Sid     = sid;
  Dcm_InstanceContext.Diag.PostProcessorContext.SrcAddr = Dcm_PbCfgNetConnectionInfo[Dcm_NetGetConnIdOfRxPduId(Dcm_InstanceContext.Diag.MsgContext.rxPduId)].ClientSrcAddr;
  Dcm_InstanceContext.Diag.PostProcessorContext.ReqType = (uint8)Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.reqType;

  *ErrorCode = DCM_E_POSITIVERESPONSE;                                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

  for(lIter = 0u; notifList[lIter].IndFunc != NULL_PTR; ++lIter)
  {
    Std_ReturnType               lStdResult;
    Dcm_NegativeResponseCodeType lNrc = DCM_E_POSITIVERESPONSE; /* Initialize out parameter */

    lStdResult = notifList[lIter].IndFunc(sid
                                         ,Dcm_InstanceContext.Diag.MsgContext.reqData
                                         ,(uint16)Dcm_InstanceContext.Diag.MsgContext.reqDataLen
                                         ,(uint8)Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.reqType
                                         ,Dcm_InstanceContext.Diag.PostProcessorContext.SrcAddr
                                         ,&lNrc);                                                                                                    /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */

    if(lStdResult != DCM_E_OK)
    {
      lResult = DCM_E_NOT_OK; /* Mark error, but let other checks to be performed - check for higher priority NOT_ACCEPTED result */

      switch(lStdResult)
      {
      case DCM_E_NOT_OK:
        Dcm_DiagHandleApplNrc(lStdResult, &lNrc, DCM_E_CONDITIONSNOTCORRECT);                                                                        /* SBSW_DCM_POINTER_FORWARD_STACK */
        break;
      case DCM_E_REQUEST_NOT_ACCEPTED:
        lNrc = DCM_E_CONDITIONSNOTCORRECT; /* In DCM_E_REQUEST_NOT_ACCEPTED case no positive response shall be sent! */
        Dcm_InstanceContext.Diag.DoSuppressResponse = TRUE; /* Try to suppress, but if an RCR-RP has been already sent - send the registered NRC */
        break;
      default:
        /* Unexpected return value */
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
        lNrc = DCM_E_PANIC_NRC;
        break;
      }

      /* Try to register NRC if no other has been set! */
      if (*ErrorCode == DCM_E_POSITIVERESPONSE)
      {
        *ErrorCode = lNrc;                                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }
  }

  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

/**********************************************************************************************************************
 *  Dcm_ProcessingDone()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ProcessingDone(void)
{
  /* If positive response to be sent: */
  if(Dcm_InstanceContext.Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
  {
    /* If SPRMIB == TRUE (suppression of positive response): */
    if(Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.suppressPosResponse != 0u)
    {
      /* Mark no response to be sent */
      Dcm_InstanceContext.Diag.DoSuppressResponse = TRUE;
    }/* Otherwise - proceed with positive response transmission */
  }
  else /* Otherwise (negative response): */
  {
    /* If functionally requested diagnostic job: */
    if(Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.reqType != 0)
    {
      switch(Dcm_InstanceContext.Diag.ErrorRegister)
      {
        case DCM_E_SERVICENOTSUPPORTED:
        case DCM_E_SUBFUNCTIONNOTSUPPORTED:
        case DCM_E_REQUESTOUTOFRANGE:
#if (DCM_DIAG_SUPPRESS_NRC_7F_7E_ENABLED == STD_ON)
        case DCM_E_SERVICENOTSUPPORTEDINACTIVESESSION:
        case DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION:
#endif
          /* Suppress negative response for certain NRCs only */
          Dcm_InstanceContext.Diag.DoSuppressResponse = TRUE;
          break;
        default:
          /* Otherwise - proceed with negative response transmission */
          break;
      }
    }/* Otherwise - proceed with negative response transmission */
  }
  /* Update diagnostic sub-component activity state */
  Dcm_InstanceContext.Diag.State = DCM_DIAG_STATE_ON_TX;

  /* Notify the transmission task for linear data response transmission/suppression */
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_LINEAR);
}

/**********************************************************************************************************************
 *  Dcm_SetNegResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_SetNegResponse(Dcm_NegativeResponseCodeType nrc)
{
  if(Dcm_InstanceContext.Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
  {
    Dcm_InstanceContext.Diag.ErrorRegister = nrc;
  }
}
/**********************************************************************************************************************
 *  Dcm_DiagTaskRx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRx(Dcm_TskTaskEvOptType ev
                                             ,Dcm_TskTaskEvPtrType pPostEv)                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_NetTransportObjectPtrType pQueuedTObj;

  pQueuedTObj = Dcm_DiagGetQueuedTranspObj();

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* If new request received: */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_RX_NEW_REQ))
  {
    /* Initialize related objects */
    pQueuedTObj->State = DCM_NET_TOBJ_STATE_READY;                                                                                                   /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
    Dcm_DiagResetRcrRpLimiter();
    /* Synchronize with diagnostic job processing task */
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_NEW_REQ);
  }

  /* If P2 timeout detected: */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_RX_TMR_P2_TO))
  {
    /* Pre-processing a P2 timeout in oder to cancel the working thread in time (on non-split task configuration) */
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
    /* If RCR-RP limit reached: */
    if(Dcm_DiagGetRcrRpLimiter() == 0)
    {
      /* Reset any RCR-RP related states and notify worker task to initiate job cancellation */
      Dcm_DiagRcrRpTxFinished(pQueuedTObj, DCM_E_NOT_OK);                                                                                            /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */

      /*
       * Signal cancellation to the worker. If worker gets interrupted by this hi priority task,
       * while already called "processing done", the cancellation signal will be lost and
       * the final response will be sent at next worker task call.
       */
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_CANCEL_OP);

      /*
       * Do not send RCR-RP and restart the P2 timer again since the limit has been reached and the worker will
       * finalize the job, once the cancel signal is received.
       */
    }
    else
#endif
    {
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
      /* Otherwise - update RCR-RP limiter */
      Dcm_DiagDecrementRcrRpLimiter();
#endif
      /* Notify diagnostic transmission task to initiate RCR-RP transmission */
      pQueuedTObj->Flags |= DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ;                                                                                          /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_RCRRP);
    }
  }
}

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagTaskFblRes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskFblRes(Dcm_TskTaskEvOptType ev
                                                 ,Dcm_TskTaskEvPtrType pPostEv)
{
  /* #10 Check for eventual FBL final response request */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_FBLRES_SEND))
  {
    ev = Dcm_DiagFblResDoGetProgCond(ev, pPostEv);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* #20 If final response required, wait for ComM before sending the response */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_FBLRES_WAITTXCOMM))
  {
    ev = Dcm_DiagFblResDoWaitTxComm(ev, pPostEv);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* #30 Once final FBL response request processed, reset all flags to prevent from a new response at next power-on/reset */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_FBLRES_RSTFLAGS))
  {
    ev = Dcm_DiagFblResDoResetFlags(ev, pPostEv);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* #40 If any FBL final response confirmation received, do the designated job (e.g. session transition) */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_FBLRES_TXCONF))
  {
    (void)Dcm_DiagFblResDoProcessTxConfirmation(ev, pPostEv);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTaskWorker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskWorker(Dcm_TskTaskEvOptType ev
                                                 ,Dcm_TskTaskEvPtrType pPostEv)
{
#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
  /* Important: this event is a synchronization event between high- and low-priority tasks.
   * Never move this event processing into another task than the one that initiates the new request processing (DCM_TSK_EV_DIAG_WORK_NEW_REQ).
   * Otherwise the clean-up jobs from DCM_TSK_EV_DIAG_WORK_KILL_JOBS event may be performed AFTER the new request processing has been started.
   * This will lead to out of sync of services post- and main-processing!
  */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_KILL_JOBS))
  {
    Dcm_TskClrLocalEvent(ev, DCM_TSK_EV_DIAG_WORK_KILL_JOBS); /* Already processed - avoid re-execution of this event if kill-job is nested */       /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    ev = Dcm_DiagWorkerDoCancelProcessing(ev, pPostEv);                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#endif

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL))
  {
    Dcm_TskClrLocalEvent(ev, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL); /* Already processed - avoid re-execution of this event if kill-job is nested */    /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    Dcm_DiagWorkerDoPostProcessing();
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF))
  {
    Dcm_TskClrLocalEvent(ev, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF); /* Already processed - avoid re-execution of this event if kill-job is nested */     /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    ev = Dcm_DiagWorkerSetDefSessionExtern(ev, pPostEv);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF))
  {
    Dcm_TskClrLocalEvent(ev, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF); /* Already processed - avoid re-execution of this event if kill-job is nested */     /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    Dcm_StateSetSession(0);
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_NEW_REQ))
  {
    ev = Dcm_DiagWorkerProcessNewRequest(ev, pPostEv);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_TX_END_RCRRP))
  {
    ev = Dcm_DiagWorkerProcessRcrRpTxEnd(ev, pPostEv);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON) && \
    (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_CANCEL_OP))
  {
    ev = Dcm_DiagWorkerCancelOperation(ev, pPostEv);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#endif

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_REPEAT))
  {
    (void)Dcm_DiagWorkerDoRepeat(ev, pPostEv);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}                                                                                                                                                    /* PRQA S 6010, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_DiagTaskTx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskTx(Dcm_TskTaskEvOptType ev
                                             ,Dcm_TskTaskEvPtrType pPostEv)
{
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_TX_SEND_PAGED))
  {
    ev = Dcm_DiagTxPostponeFinalPagedResponse(ev, pPostEv);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#endif

  if(Dcm_TskIsLocalEventSet(ev, (DCM_TSK_EV_DIAG_TX_SEND_PAGED | DCM_TSK_EV_DIAG_TX_SEND_LINEAR)))
  {
    ev = Dcm_DiagTxStartFinalResponse(ev, pPostEv);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_TX_SEND_RCRRP))
  {
    Dcm_DiagTxStartRcrRpResponse();
  }
}

#if (DCM_TSK_NUM_DIAG_RECOVERY > 0)                                                                                                                  /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagTaskRecovery()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRecovery(Dcm_TskTaskEvOptType ev
                                                   ,Dcm_TskTaskEvPtrType pPostEv)
{
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_RECOVERY_GETSTATE))
  {
    Std_ReturnType lResult;

    /* Retrieve the recovery information from the application */
    lResult = Dcm_GetRecoveryStates(&Dcm_InstanceContext.Repeater.Contexts.Context.Recovery.RecoveryInfo);

    switch(lResult)
    {
    case DCM_E_OK:
      Dcm_TskSetLocalEvent(ev, DCM_TSK_EV_DIAG_RECOVERY_PROCESS);
      Dcm_InstanceContext.Repeater.Contexts.Context.Recovery.OpStatus = DCM_INITIAL;
      break;
    case DCM_E_PENDING:
      /* Retry next time */
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_RECOVERY_GETSTATE);                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
      break;
    default:
      Dcm_DebugAssert((lResult == DCM_E_NOT_OK), DCM_SID_GETRECOVERYSTATES, DCM_E_INTERFACE_RETURN_VALUE)                                            /* COV_DCM_RTM_DEV_DEBUG XF */
      /* Abort recovering */
      Dcm_TskSetLocalEvent(ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH);
      break;
    }
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_RECOVERY_PROCESS))
  {
    Std_ReturnType   lResult;
    lResult = Dcm_DiagSafeProcessRecoveryInfo(&Dcm_InstanceContext.Repeater.Contexts.Context.Recovery.RecoveryInfo,
                                               Dcm_InstanceContext.Repeater.Contexts.Context.Recovery.OpStatus);

    switch(lResult)
    {
    case DCM_E_OK:
      Dcm_TskSetLocalEvent(ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH);
      break;
    case DCM_E_PENDING:
      /* Retry next time */
      Dcm_InstanceContext.Repeater.Contexts.Context.Recovery.OpStatus = DCM_PENDING;
      break;
    default: /* DCM_E_NOT_OK */
      /* Abort recovering */
      Dcm_TskSetLocalEvent(ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH);
      break;
    }
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH))
  {
    Dcm_SingletonContext.Network.RxAllowed = TRUE;
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagLookUpFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_DiagLookUpFilter(sint16_least lookUpResult
                                                           ,Dcm_VarRefMemPtrType lookUpFilterTable
                                                           ,Dcm_DiagCheckLvlType chkLevel
                                                           ,Dcm_NegativeResponseCodePtrType errorCode)
{
  sint16_least lLookUpResult;

  /* #10 Check if diagnostic object exists in current variant */
  lLookUpResult = Dcm_VarMgrLookUpFilter(lookUpResult, lookUpFilterTable);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* #20 If diagnostic object not supported in current variant at all: */
  if(lLookUpResult < 0)
  {
    /* #30 Set appropriate NRC depending on the diagnostic object type */
    *errorCode = Dcm_DiagObjNotFoundNrcs[chkLevel];                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  /* #40 Otherwise if diagnostic object not supported in current session: */
  else if (!Dcm_StateIsSupportedInSession(Dcm_StateGetPreconditionStates(lookUpFilterTable[lLookUpResult])))
  {
    /* #50 Invalidate lookup result and set appropriate NRC depending on the diagnostic object type */
    lLookUpResult = -1; /* override result */
    *errorCode = Dcm_StateSessionNrcs[chkLevel];                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* #60 Otherwise return positive result  */
  }

  /* #70 Return final result */
  return lLookUpResult;
}

#if (DCM_DIAG_SF_ONLY_SERVICE_ENABLED == STD_ON)                                                                                                     /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagSvcWithOnlySubFuncReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_DiagSvcWithOnlySubFuncReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  DCM_IGNORE_UNREF_PARAM(sfRef);                                                                                                                     /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return 1u;
}
#endif

#if (DCM_DIAG_ANY_SERVICE_WITH_SF_ENABLED == STD_ON)                                                                                                 /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagVerifyServiceWithSubFunction()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagVerifyServiceWithSubFunction(
                                                                 Dcm_MsgContextPtrType                pMsgContext
                                                                ,Dcm_Uint8ConstDataPtrType            lookUpTable
                                                                ,Dcm_VarRefMemPtrType                 lookUpFilterTable
                                                                ,Dcm_DiagServiceLengthGetterFuncType  svcLengthGetter
                                                                ,Dcm_DiagSubServiceRefOptPtrType      pSubSvcRef
                                                                ,Dcm_NegativeResponseCodePtrType      ErrorCode)
{
  Std_ReturnType               lStdResult;
  sint16_least                 lLookUpResult;
  uint8                        sfID = Dcm_DiagGetReqDataAsU8(pMsgContext);

  *pSubSvcRef = 0;                                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Min Length already checked in DiagDispatcher and expected to be 1 !!! */
  Dcm_DebugAssert((pMsgContext->reqDataLen > 0), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                              /* COV_DCM_RTM_DEV_DEBUG XF */

  lLookUpResult = Dcm_DiagLookUpFilter(Dcm_UtiLookUpUint8(lookUpTable, sfID)
                                      ,lookUpFilterTable
                                      ,DCM_DIAG_CHK_LVL_SUBFUNC
                                      ,ErrorCode);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lLookUpResult >= 0)
  {
    Dcm_DiagSubServiceLengthType expectedLength;
    /* Mark found position in any case if found */
    *pSubSvcRef = (Dcm_DiagSubServiceRefOptType)lLookUpResult;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

    expectedLength = svcLengthGetter((Dcm_DiagSubServiceRefOptType)lLookUpResult);                                                                   /* SBSW_DCM_PARAM_FUNCPTR_CALL */

    if( (expectedLength == 0) /* dynamic length */
      ||(expectedLength == pMsgContext->reqDataLen) ) /* SF + data */
    {
      lStdResult = Dcm_StateCheck(lookUpFilterTable[lLookUpResult], DCM_DIAG_CHK_LVL_SUBFUNC, ErrorCode);                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    /* Extract SF in any case if supported */
    Dcm_DiagConsumeReqData(pMsgContext, 1u);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagProvideResDataAsU8(pMsgContext, sfID);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

    Dcm_DiagSetNewReqBaseToCurProgress(pMsgContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagSetNewResBaseToCurProgress(pMsgContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    /* else - ErrorCode is already set */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050, 6060 */ /* MD_MSR_STCAL, MD_Dcm_Design_6060 */
#endif
#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VarMgrIsEnabledInActiveVariants()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgStateRefOptType cfgVariantRef)
{
  boolean lIsEnabled = FALSE;
  Dcm_CfgVarMgrDiagVariantIdOptType varRowIter = Dcm_VarMgrBitSetCalcSize(DCM_VARMGR_NUM_CFG_VARIANTS);

  /* scan all variants (at least 8 way scan) for at least one match */
  while(varRowIter > 0)
  {
    --varRowIter;
    if((Dcm_PbCfgVarMgrDiagVariantFilter[cfgVariantRef][varRowIter] & Dcm_SingletonContext.VarMgr.ActiveCfgVariants[varRowIter]) != 0)
    {
      lIsEnabled = TRUE;/* at least one matched variant */
      break;
    }/* else - continue searching */
  }

  return lIsEnabled;
}
#endif

/**********************************************************************************************************************
 *  Dcm_VarMgrLookUpFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_VarMgrLookUpFilter(sint16_least lookUpResult
                                                             ,Dcm_VarRefMemPtrType lookUpFilterTable)
{
  DCM_IGNORE_UNREF_PARAM(lookUpFilterTable);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

#if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
  if(lookUpResult >= 0)
  {
    if (Dcm_VarMgrIsEnabledInActiveVariants(lookUpFilterTable[lookUpResult]) == FALSE)
    {
      lookUpResult = -1; /* override result */
    }
  }
#endif

  return lookUpResult;
}
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc01GetAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc01GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue)
{
  /* #10 Return the lookup index and AID bit mask for given OBD PID on service 0x01 */
  return Dcm_ObdIdMgrGetAvailabilityMask(id, Dcm_CfgSvc01LookUpTable, Dcm_CfgSvc01ExecPrecondTable, Dcm_CfgSvc01SupportedIdMask, pMaskValue);
}
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_Svc06GetAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc06GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue)
{
  /* #10 return the lookup index and AID bit mask for given OBD MID on service 0x06 */
  return Dcm_ObdIdMgrGetAvailabilityMask(id, Dcm_CfgSvc06LookUpTable, Dcm_CfgSvc06ExecPrecondTable, Dcm_CfgSvc06SupportedIdMask, pMaskValue);
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc08GetAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc08GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue)
{
  /* #10 Return the lookup index and AID bit mask for given OBD TID on service 0x08 */
  return Dcm_ObdIdMgrGetAvailabilityMask(id, Dcm_CfgSvc08LookUpTable, Dcm_CfgSvc08ExecPrecondTable, Dcm_CfgSvc08SupportedIdMask, pMaskValue);
}
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc09GetAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc09GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue)
{
  /* #10 Return the lookup index and AID bit mask for given OBD VID on service 0x09 */
  return Dcm_ObdIdMgrGetAvailabilityMask(id, Dcm_CfgSvc09LookUpTable, Dcm_CfgSvc09ExecPrecondTable, Dcm_CfgSvc09SupportedIdMask, pMaskValue);
}
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessEcuReset(Dcm_ModeMgrArEnvModeEcuResetType mode
                                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lResult;

  /* Try performing mode switch on ECU reset */
  if(Dcm_ModeMgrArEnvSwitchReqEcuReset(mode) == DCM_E_OK)
  {
    /* If succeeded, go on with waiting for acknowledge */
    Dcm_RepeaterNextStep(DCM_SVC11_PROGRESS_ECURST_WAITFORACK);
    lResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    /* If this attempt fails, send back NRC 0x22 to notify diagnostic client */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  return lResult;
}
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessRapPwrDwn()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessRapPwrDwn(Dcm_ModeMgrArEnvModeRapidPowerShutDownType mode
                                                                   ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lResult;

  /* Try performing mode switch on ECU reset */
  if(Dcm_ModeMgrArEnvSwitchReqRapidPowerShutDown(mode) == DCM_E_OK)
  {
    /* If succeeded, go on with waiting for acknowledge */
    Dcm_RepeaterNextStep(DCM_SVC11_RAPPWRDWN_WAITFORACK);
    lResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    /* If this attempt fails, send back NRC 0x22 to notify diagnostic client */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }

  return lResult;
}
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc19ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  /* Return sub-function specific length */
  return Dcm_CfgSvc19SubFuncInfo[sfRef].ReqLength;
}
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainStart(
                                                   P2CONST(Dcm_RepeaterProgressType, AUTOMATIC, DCM_CONST) funcChain
                                                  ,Dcm_Svc19RepeaterProxyContextPtrType                    pRepContext)
{
  pRepContext->FuncChain = funcChain;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_RepeaterNextStep(*pRepContext->FuncChain);
  return DCM_E_LOOP;/* execute it immediately */
}
# endif

# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainNext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainNext(Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Dcm_UtiNextItemByPtr(pRepContext->FuncChain, 1u);                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_RepeaterNextStep(*pRepContext->FuncChain);
  return DCM_E_LOOP;/* take next item from list */
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcByStatusMaskData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcByStatusMaskData(
                                                                      Dcm_Svc19DemSetFilterClassType       dsfClass
                                                                     ,Dcm_Svc19DemSetFilterMaskUsageType   maskUsage
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  uint8 dtcStatusMask;
  uint8 dtcSAM;

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pRepContext->DemClientId
                                                       ,&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  if(lStdResult == E_OK)
  {
    lStdResult = DCM_E_NOT_OK;

    /* If a requested DTC status mask shall be considered: */
    if(maskUsage == DCM_SVC_19_USE_MASK_REQ)
    {
      Dcm_DiagConsumeReqDataAsU8(pMsgContext, &dtcStatusMask);                                                                                       /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
      Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter(&dtcStatusMask);                                                                                     /* PRQA S 3109 */ /* MD_MSR_14.3 */
      dtcStatusMask &= dtcSAM;

      if(dtcStatusMask == 0u)
      {
        /* If no supported (relevant) status bit remains, omit DEM SetFilter API invokation
         * (i.e. send final positive response only with SAM)
         */
        lStdResult = DCM_E_OK;
      }
      /* Otherwise, prepare a DEM filter to consider relevant DTC status bits */
    }
    else
    {
      /* Otherwise, prepare a DEM filter to report all supported DTCs */
      dtcStatusMask = 0u;
    }

    Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* If DEM filtering still required: */
    if(lStdResult != DCM_E_OK)
    {
      lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                              ,dsfClass
                                              ,dtcStatusMask
                                              ,0 /* parameter not used */
                                              ,DCM_DEM_FILTER_FOR_FDC_NO
                                              ,pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
      if(lStdResult == DCM_E_OK)
      {
        lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainReadDtcByStatus, pRepContext);                                                          /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
      }
      else
      {
        /* Already set by Dcm_Svc19UtiDemSetDTCFilter */
      }
    }/* Otherwise, send the final response with no additional data */
  }
  else
  {
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByStatusMaskData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByStatusMaskData(
                                                                     Dcm_Svc19DemSetFilterClassType       dsfClass
                                                                    ,uint8                                dtcStatusMask
                                                                    ,Dem_DTCSeverityType                  dtcSeverity
                                                                    ,Dcm_MsgContextPtrType                pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                    ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType           lStdResult;
  uint8                    dtcSAM;

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pRepContext->DemClientId
                                                       ,&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  if (lStdResult == E_OK)
  {
    Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter(&dtcStatusMask);                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */

    Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
    Dcm_DiagProvideResDataAsU8(pMsgContext, Dcm_DemAPI(GetTranslationType)(pRepContext->DemClientId));                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
#  else
    Dcm_DiagProvideResDataAsU8(pMsgContext, Dcm_DemAPI(GetTranslationType)());                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
#  endif

    dtcStatusMask &= dtcSAM;
    if(dtcStatusMask != 0)
    {
      lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                              ,dsfClass
                                              ,dtcStatusMask
                                              ,dtcSeverity
                                              ,DCM_DEM_FILTER_FOR_FDC_NO
                                              ,pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
      if(lStdResult == DCM_E_OK)
      {
        lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainDtcCount, pRepContext);                                                                 /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
      }
      else
      {
        /* Already set by Dcm_Svc19UtiDemSetDTCFilter */
      }
    }
    else
    {
      Dcm_DiagProvideResDataAsU16(pMsgContext, 0); /*lint !e572 if a constant fits into uint8, then lint threats it as such and ignores any casts */ /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_OK;
    }
  }
  else
  {
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_Dcm_Design_6060 */
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportExtDataRecordByDtcNum()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportExtDataRecordByDtcNum(Dem_DTCOriginType         dtcOrigin
                                                                     ,Dcm_MsgContextPtrType                pMsgContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  pRepContext->Origin = dtcOrigin;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

  Dcm_DiagConsumeReqDataAsU24(pMsgContext, &(pRepContext->Dtc));                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &(pRepContext->RecordNum));                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(pRepContext->RecordNum == DCM_SVC_19_RECNUM_ALL)
  {
    pRepContext->RecordNumList = Dcm_Svc19ExtDataRecords;                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else if(pRepContext->RecordNum == DCM_SVC_19_RECNUM_OBD_ALL)
  {
#  if (DCM_SVC_19_OBD_EXT_RECORD_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
    pRepContext->RecordNumList = Dcm_Svc19ExtDataRecordsObd;                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
#  else
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE; /* the ECU does not support any OBD extended data records - reject request */                              /* SBSW_DCM_PARAM_PTR_WRITE */
    return DCM_E_NOT_OK;
#  endif
  }
  else
  {
    /* Single record */
    pRepContext->RecordNumList = NULL_PTR;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  return Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainReadExtRecords, pRepContext);                                                                       /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}                                                                                                                                                    /* PRQA S 2006 */ /* MD_Dcm_Optimize_2006 */
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByOccurenceTime()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByOccurenceTime(Dem_DTCRequestType        dtcReqType
                                                                     ,Dcm_MsgContextPtrType                pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType      ErrorCode
                                                                     ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdResult;
  uint8 dtcSAM;

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pRepContext->DemClientId
                                                       ,&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  if (lStdResult == E_OK)
  {
    Dcm_DemReturnGetDTCByOccurrenceTimeType demResult;

    Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    demResult = Dcm_DemAPI(GetDTCByOccurrenceTime)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
                                                   pRepContext->DemClientId,
#  endif
                                                   dtcReqType
                                                  ,&pRepContext->Dtc);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    switch(demResult)
    {
      case DCM_DEM_RET_OCCURR_OK:
        pRepContext->Origin = DEM_DTC_ORIGIN_PRIMARY_MEMORY;                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainGetDtcStatusEnd, pRepContext);                                                          /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
        break;
      default:
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetDTCByOccurrenceTime);                                               /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
    }
  }
  else
  {
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcFFRByDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcFFRByDtc(Dem_DTCOriginType                    dtcOrigin
                                                                      ,Dcm_MsgContextPtrType                pMsgContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                      ,Dcm_Svc19RepeaterProxyContextPtrType pRepContext)
{
  pRepContext->Origin = dtcOrigin;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_DiagConsumeReqDataAsU24(pMsgContext, &(pRepContext->Dtc));                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &(pRepContext->RecordNum));                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(pRepContext->RecordNum == DCM_SVC_19_RECNUM_ALL)
  {
    pRepContext->RecordNumList = Dcm_Svc19FFDataRecords;                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* Single record */
    pRepContext->RecordNumList = NULL_PTR;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  return Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainReadFFRByDtc, pRepContext);                                                                         /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
# if (DCM_TSK_NUM_SVC27 > 0)
/**********************************************************************************************************************
 *  Dcm_Svc27Task()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27Task(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv)                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  /* #10 If the attempt counters should be restored: */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_READ))
  {
    /* #20 Process attempt counter reading */
    (void)Dcm_Svc27ReadAttemptCounter(ev, pPostEv);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* #30 If the attempt counters should be stored: */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_WRITE))
  {
    /* #40 Process attempt counter writing */
    (void)Dcm_Svc27WriteAttemptCounter(ev, pPostEv);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSecurityAccess_0()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSecurityAccess_0(void)
{
  Dcm_TmrTimerCntrMemType lReloadTick = 0u;
  uint8_least             lTmrIter;
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  uint32_least            lJustExpiredMask = 0u;
#  endif

  /* For each software timer: */
  for(lTmrIter = 0; lTmrIter < DCM_SVC_27_NUM_DELAY_TIMERS; ++lTmrIter)
  {
#  if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
    /* If delay time is set to infinity: */
    if(Dcm_Svc27ReloadReadFailedGet(lTmrIter) == TRUE)
    {
      /* Reload forever */
      lReloadTick = 1u;
    }
    else
#  endif
    {
      /* Otherwise, if the software timer is not expired: */
      if(Dcm_Svc27TimerExpired(lTmrIter) == FALSE)
      {
        /* Decrement the timer value */
        Dcm_Svc27TimerDec(lTmrIter);

        /* If the software timer is still not expired */
        if(Dcm_Svc27TimerExpired(lTmrIter) == FALSE)
        {
          /* Reload the hardware timer */
          lReloadTick = 1u;
        }
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
        else
        {
          /* Otherwise, remember the index of the just expired timer */
          lJustExpiredMask |= Dcm_UtiGetBitFromIndex(uint32, lTmrIter);
        }
#  endif
      }
    }
  }

#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  {
    uint8_least lSecLvlIter;

    /* For each security level */
    for(lSecLvlIter = 0; lSecLvlIter < DCM_STATE_SECURITY_NUM_LEVELS; ++lSecLvlIter)
    {
      /* If the corresponding timer of the given security level is just expired */
      if(Dcm_Svc27TimerJustExpired(lJustExpiredMask, lSecLvlIter) == TRUE)
      {
        /*
         * Reset the corresponding attempt counter of the given security level (if only single counter used, it will
         * be overwritten multiple times)
         */
        Dcm_Svc27CounterReset(lSecLvlIter);
        Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask |= Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter);
      }
    }
  }

  /* If at least one attempt counter was reset */
  if(Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask != 0)
  {
    /* Notify the application about changed attempt counter values */
    Dcm_TskSetEvent(DCM_TSK_ID_SVC27, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_WRITE);
  }
#  endif

  return lReloadTick;
}
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiSetAttemptCntr()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27UtiSetAttemptCntr(Dcm_OpStatusType opStatus
                                                         ,P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask)
{
  uint8_least lSecLvlIter = 0u;
  uint32      lMask = *levelMask;

  /* For each security level: */
  DCM_UTI_LOOP_BIT_SCAN(lMask)
  {
    /* If the attempt counter for that specific security level is not already written: */
    if(Dcm_UtiBitOpTest(uint32, lMask, 0x01u))
    {
      Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;

      pSecLevelInfo = Dcm_CfgSvc27SecLevelInfoGetEntryOrNull(lSecLvlIter);

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if (pSecLevelInfo == NULL_PTR)                                                                                                                 /* COV_DCM_RTM_RUNTIME_CHECK XF */
      {
        break;
      }
      else
#  endif
      {
        Std_ReturnType lResult;

        /* Notify the application about the new attempt counter value */
        lResult = pSecLevelInfo->SetAttemptCntrFunc(opStatus, Dcm_Svc27CounterGet(lSecLvlIter));                                                     /* SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL */

        if (lResult == DCM_E_PENDING)
        {
          /* Otherwise try it later */
        }
        else
        {
          Dcm_DebugApiCheckRte(((lResult == DCM_E_OK) || (lResult == DCM_E_NOT_OK)), DCM_SID_SETSECURITYATTEMPTCOUNTER, DCM_E_INTERFACE_RETURN_VALUE)
          /*
           * If the attempt counter was written successfully or an error occurred, don't try to write the attempt
           * counter again.
           */
          Dcm_SplitTaskEnterCS(); /* Avoid interrupt from Dcm_OnTimeoutSecurityAccess */                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
          /*=================================*
            BEGIN CRITICAL SECTION
           *=================================*/
          Dcm_UtiBitOpClr(uint32                                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
                         ,*levelMask
                         ,Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter));
          /*=================================*
            END CRITICAL SECTION
           *=================================*/
          Dcm_SplitTaskLeaveCS();                                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
        }
      }
    }
    ++lSecLvlIter;
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc27ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc27ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  /* Return sub-function specific length */
  return Dcm_CfgSvc27SubFuncInfo[sfRef].ReqLength;
}
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc28EnableCommunication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc28EnableCommunication(void)
{
  uint8_least channelIter = Dcm_PbCfgNetNumAllComMChannels;

  while(channelIter != 0) /* Use top-down counting to be consistent with the Dcm_Svc28ApplyCommControl all-channel calls */
  {
    --channelIter;
    if(Dcm_ModeGetCommControlState(channelIter) != DCM_ENABLE_RX_TX_NORM_NM)
    {
      Dcm_ModeSwitchCommControl(channelIter, DCM_ENABLE_RX_TX_NORM_NM);
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc28ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc28ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  /* Return sub-function specific length */
  return Dcm_CfgSvc28SubFuncInfo[sfRef].ReqLength;
}
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_TMR_NUM_SVC2A_SCHEDULER > 0)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSvc2AScheduler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSvc2AScheduler(void)
{
  Dcm_TmrTimerCntrMemType lReturn = 0;

  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    boolean doActivateProcessorTask;

    doActivateProcessorTask = Dcm_Svc2ASchdUpdateTimers();

    if(doActivateProcessorTask == TRUE)
    {
      Dcm_TskSetEvent(DCM_TSK_ID_SVC2A_SCHEDULER, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS);/* at least one job to do */
    }
    lReturn = 1u;/* immediate timeout in next slot */
  }/* else - a NOP activate - will be the last one */
  return lReturn;/* no reload */
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ATaskSchdProcess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ATaskSchdProcess(Dcm_TskTaskEvOptType ev
                                                       ,Dcm_TskTaskEvPtrType pPostEv)                                                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(ev);                                                                                                                        /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
  /* scheduler timer update is done in a dedicated task to achieve maximum timing accuracy */
# else
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_SVC2A_SCHEDULER_TMR_UPD))
  {
    boolean doActivateProcessorTask;

    if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
    {
      doActivateProcessorTask = Dcm_Svc2ASchdUpdateTimers();
      if(doActivateProcessorTask == TRUE)
      {
        Dcm_TskSetLocalEvent(ev,  DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS);/* let's check which did is in a timeout */
      }
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_SVC2A_SCHEDULER_TMR_UPD);/* still something to do - keep timer updater alive */                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS))
# endif
  {
    Dcm_Svc2ASchdItemHandleOptType schdIter;

    for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter) /* loop over all scheduled items (maximum once per task activation) */
    {
      Dcm_Svc2ASchdEntryPtrType pSchedTableEntry = &Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NextEntryIdx];

      if( (pSchedTableEntry->Timer == 0u)
        &&( (pSchedTableEntry->Rate & DCM_SVC2A_RATE_TYPE_STOPPED) == 0) )
      {
        Std_ReturnType lStdReturn;

        lStdReturn = Dcm_Svc2ASchdProcessEntry(pSchedTableEntry);
        if(lStdReturn == DCM_E_PENDING)
        {
          Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS);                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
          break; /* leave the loop and the task */
        }
      }
      /* next entry to be processed */
      Dcm_Svc2ASchdNextEntryIdxInc();
    }
  }
}
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopAll()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopAll(void)
{
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    Dcm_Svc2ASchdItemHandleOptType schdIter;

    for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
    {
      Dcm_Svc2ASchdStopItemByHandle(schdIter);
    }
  }
}

# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByHandle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByHandle(Dcm_Svc2ASchdItemHandleOptType schdHandle)
{
  if( (Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr != NULL_PTR)
    &&(schdHandle == Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NextEntryIdx) )
  {
    Dcm_NegativeResponseCodeType lNrc;/* not evaluated after the API call */
    Dcm_DiagDataContextType      lDataContext;

    Dcm_DiagInitDataContext(&lDataContext
                           ,&Dcm_NetPeriodicMsgGetTxBuffer(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle)[1]
                           ,(Dcm_MsgLenType)(DCM_NET_PERIODIC_BUFFER_SIZE - 1u));

    /* cancel ongoing operation immediately  */
    (void)Dcm_DidMgrReadDid(DCM_CANCEL
                           ,&lDataContext
                           ,Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr
                           ,&(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidOpTypeContext)
                           ,&lNrc);

    /* Finish scheduled job */
    Dcm_Svc2ASchdFinishEntryProcessing(FALSE);
  }/* else - nothing to do */
}
# endif

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON) && \
     (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByDid(uint16 did)
{
  sint16_least schdHandle = Dcm_Svc2ASchdGetItemByDid(did);

  if(schdHandle >= 0)
  {
    Dcm_Svc2ASchdCancelReadByHandle((Dcm_Svc2ASchdItemHandleOptType)schdHandle);
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByHandle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByHandle(Dcm_Svc2ASchdItemHandleOptType schdHandle)
{
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdHandle].Rate < DCM_SVC2A_RATE_TYPE_STOPPED)
  {
    Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdHandle].Rate = DCM_SVC2A_RATE_TYPE_STOPPED;
    /* must have at least one element (this one) */
    Dcm_DebugAssert((Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries > 0), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                 /* COV_DCM_RTM_DEV_DEBUG XF */
    --Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries; /* update statistic */

# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    Dcm_Svc2ASchdCancelReadByHandle(schdHandle);
# endif

    Dcm_NetPeriodicMsgStopDid(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdHandle].DidContext.Did);
    if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries == 0u)/* scheduler is empty */
    {
      Dcm_NetPeriodicMsgResetConnection(); /* allow other tester to use service 0x2A */
      Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NextEntryIdx = 0u;
# if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
      Dcm_TmrStopTimer(DCM_TMR_ID_SVC2A_SCHEDULER);/* stop timer updater */
# else
      /* no need to deactivate the task - if the event was set, the task will deactivate itself after a single short execution time activation */
# endif
    }
  }/* else - this item is not scheduled at all */
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByDid(uint16 did)
{
  sint16_least schdHandle = Dcm_Svc2ASchdGetItemByDid(did);

  if(schdHandle >= 0)
  {
    Dcm_Svc2ASchdStopItemByHandle((Dcm_Svc2ASchdItemHandleOptType)schdHandle);
  }
}
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc2ASchdGetItemByDid(uint16 did)
{
  sint16_least lResult = -1;
  Dcm_Svc2ASchdItemHandleOptType schdIter;

  for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
  {
    if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].DidContext.Did == did)
    {
      lResult = (sint16_least)schdIter;
      break;
    }
  }
  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFinishEntryProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdFinishEntryProcessing(boolean doSendResponse)
{
  if(doSendResponse == TRUE)
  {
    Dcm_NetPeriodicMsgTransmit(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle
                              ,(PduLengthType)(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr->DidLength + 1));
  }
  else
  {
    Dcm_NetPeriodicMsgRelease(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle);/* release resource if not used */
  }

  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr = NULL_PTR;
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle   = DCM_NET_INVALID_PTXOBJ_HANDLE; /* free for next DID */
# if (DCM_DIDMGR_2A_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadPeriodic = 0u;
# endif
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2ADidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidLookUp(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext
                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                           ,Dcm_Svc2ARepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;
  boolean doProcessDid = TRUE;

  if(opStatus == DCM_INITIAL)
  {
    if(pMsgContext->reqDataLen != 0u)
    {
      uint8 perDidLoByte;
      Dcm_DiagConsumeReqDataAsU8(pMsgContext, &perDidLoByte);                                                                                        /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

      pRepContext->DidInfoContext.Did = Dcm_Svc2AMakePeriodicDid(perDidLoByte);
    }
    else
    {
      doProcessDid = FALSE;
    }
  }

  if(doProcessDid == TRUE)
  {
    lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                     ,&(pRepContext->DidInfoContext)
                                     ,&(pRepContext->DidOpTypeContext)
                                     ,DCM_DIDMGR_OP_READ);
    if(lStdReturn == DCM_E_OK)
    {
      pRepContext->HasAnySupportedDids = TRUE; /* register a supported DID */
      /* go on with the DID condition check - DCM_E_OK */
    }
    else if(lStdReturn == DCM_E_PENDING)
    {
      /* already set */
    }
    else
    {
      /* Just skip this DID - DCM_E_NOT_OK - request a new client loop */
      lStdReturn = DCM_E_LOOP;
    }
  }
  else
  {
    /* empty run loop ended without any DID to be processed (for this activation of the repeater proxy) */
    /* all DIDs processed */
    if (pRepContext->HasAnySupportedDids == FALSE)
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
    {
      lStdReturn = DCM_E_PROCESSINGDONE;
    }
  }

  return lStdReturn;
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_2C_CLEAR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrClear()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrClear(Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle)
{
#  if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
  {
    uint16 lDid = Dcm_DidMgrGetDynDidIdFromHandle(dynDidHandle);
    /* Try stopping any active periodic DID (can be still read at that time)! */
    Dcm_Svc2ASchdStopItemByDid(lDid);
  }
#  endif
  Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Length = 0u;
  Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Count  = 0u;
}
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2CCheckNumOfItems()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2CCheckNumOfItems(uint8 numRequestedItems
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_NegativeResponseCodeType lNrcResult;
  if ((uint8)((Dcm_DidMgrGetDynDidSize(pRepContext->DynDidHandle) - pRepContext->DynDidItemCount)) >= numRequestedItems)
  {
    pRepContext->ReqNumOfItems = numRequestedItems;
    lNrcResult = DCM_E_POSITIVERESPONSE;
  }
  else
  {
    lNrcResult = DCM_E_REQUESTOUTOFRANGE;
  }

  return lNrcResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CParseAndCheckDynDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CParseAndCheckDynDid(Dcm_OpStatusType      opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext
                                                                     ,Dcm_NegativeResponseCodePtrType ErrorCode
                                                                     ,Dcm_Svc2CRepeaterProxyContextPtrType pRepContext)
{
  Std_ReturnType lStdReturn;

  if(opStatus == DCM_INITIAL)
  {
    Dcm_DiagConsumeReqDataAsU16(pMsgContext, &pRepContext->DynDidInfoContext.Did);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&pRepContext->DynDidInfoContext
                                   ,&pRepContext->DynDidOpTypeContext
                                   ,DCM_DIDMGR_OP_DEFINE);

  if(lStdReturn == DCM_E_OK)
  {
    lStdReturn = Dcm_StateCheck(pRepContext->DynDidInfoContext.Descriptor.DidOpInfoPtr->ExecCondRef, DCM_DIAG_CHK_LVL_PARAMETER, ErrorCode);
    if (lStdReturn == DCM_E_OK)
    {
      /* initialize common DynDID request context */
# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
      if (Dcm_Svc2AIsPeriodicDid(pRepContext->DynDidInfoContext.Did))
      {
        pRepContext->MaxAllowedLength = DCM_SVC2A_MAX_RESPONSE_LEN;
      }
      else
# endif
      {
        /* Perform length check based on the current protocol only. Sid 0x22 will do additional checks at read time in case a client from another protocol is trying to access the DynDID! */
        pRepContext->MaxAllowedLength = Dcm_Svc2CGetMaxDynDidProtocolLen();
      }

      pRepContext->DynDidHandle = (Dcm_CfgDidMgrDynDidHandleMemType)pRepContext->DynDidInfoContext.Descriptor.DidInfoPtr->OpRef;
      pRepContext->DynDidLength = Dcm_InstanceContext.Diag.Services.Svc2C.Items[pRepContext->DynDidHandle].Length; /* set current length for updates during service processing */
      pRepContext->SrcItemIndex = Dcm_Svc2CGetSrcItemIndex(pRepContext->DynDidHandle
                                                          ,Dcm_InstanceContext.Diag.Services.Svc2C.Items[pRepContext->DynDidHandle].Count);
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
      pRepContext->SrcItemPtr = &(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[pRepContext->SrcItemIndex]);
# endif
      pRepContext->DynDidItemCount = Dcm_InstanceContext.Diag.Services.Svc2C.Items[pRepContext->DynDidHandle].Count;

      Dcm_DiagProvideResData(pMsgContext, 2u); /* positive response contains the DynDID (2Byte) */                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
      /* lStdReturn = DCM_E_OK - already set */
    } /* else DCM_E_NOT_OK (ErrorCode already set) */
  }
  else if(lStdReturn == DCM_E_PENDING)
  {
    /* lStdReturn already set */
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc2CReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  DCM_IGNORE_UNREF_PARAM(sfRef);                                                                                                                     /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /* Return sub-function specific length (always zero -> dynamic since it depends on the complete request content) */
  return 0u;
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc85EnableDtcSetting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85EnableDtcSetting(uint8 DemClientId)
{
  Std_ReturnType                     lStdResult;
  Dcm_DemReturnControlDTCSettingType lDemResult;

  if(Dcm_ModeGetControlDtcSettingMode() != RTE_MODE_DcmControlDtcSetting_ENABLEDTCSETTING)
  {
    /* Enable the DTC setting for all DTCs */
# if (DCM_DEM_API_430_ENABLED == STD_ON)
    lDemResult = Dcm_DemAPI(EnableDTCSetting)(DemClientId);
# else
    lDemResult = Dcm_DemAPI(EnableDTCSetting)(DEM_DTC_GROUP_ALL_DTCS, DEM_DTC_KIND_ALL_DTCS);
# endif

    switch (lDemResult)
    {
      case DCM_DEM_RET_CONTROL_DTC_SETTING_OK:
        lStdResult = DCM_E_OK;
        Dcm_ModeSwitchDtcSetting(RTE_MODE_DcmControlDtcSetting_ENABLEDTCSETTING, DEM_DTC_GROUP_ALL_DTCS, DemClientId);
        break;
# if defined (DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING)
      case DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING:
        lStdResult = DCM_E_PENDING;
        break;
# endif
      default:
        lStdResult = DCM_E_NOT_OK;
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
        break;
    }
  }
  else
  {
    lStdResult = DCM_E_OK;
  }
  return lStdResult;
}

# if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc85DisableDtcSetting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85DisableDtcSetting(Dem_DTCGroupType DTCGroup
                                                                   ,uint8 DemClientId)
{
  Std_ReturnType                     lStdResult;
  Dcm_DemReturnControlDTCSettingType lDemResult;

  /* Disable the DTC setting for all DTCs */
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  lDemResult = Dcm_DemAPI(DisableDTCSetting)(DemClientId);
#  else
  lDemResult = Dcm_DemAPI(DisableDTCSetting)(DTCGroup, DEM_DTC_KIND_ALL_DTCS);
#  endif

  switch (lDemResult)
  {
    case DCM_DEM_RET_CONTROL_DTC_SETTING_OK:
      lStdResult = DCM_E_OK;
      Dcm_ModeSwitchDtcSetting(RTE_MODE_DcmControlDtcSetting_DISABLEDTCSETTING, DTCGroup, DemClientId);
      break;
#  if defined (DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING)
    case DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING:
      lStdResult = DCM_E_PENDING;
      break;
#  endif
    default:
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
      break;
  }
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc85ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc85ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  DCM_IGNORE_UNREF_PARAM(sfRef);                                                                                                                     /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /* Return sub-function specific length (always the same constant) */
  return DCM_SVC_85_REQ_LENGTH;
}

/**********************************************************************************************************************
 *  Dcm_Svc85_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc85_XX_RepeaterProxy(Dcm_OpStatusType                     opStatus
                                                                   ,Dcm_MsgContextPtrType                pMsgContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_NegativeResponseCodePtrType      ErrorCode                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_Svc85RepeaterProxyContextPtrType pRepContext)                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType                     lStdResult;
  Dcm_DemReturnControlDTCSettingType lDemResult;
  Dcm_CfgSvc85SubFuncInfoPtrType     pSubFuncInfo;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pSubFuncInfo = Dcm_CfgSvc85SubFuncInfoGetEntryOrNull(pRepContext->SubSvcRef);

# if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                              /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pSubFuncInfo == NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
# endif
  {
# if (DCM_DEM_API_430_ENABLED == STD_ON)
    lDemResult = pSubFuncInfo->DemFunc(pRepContext->DemClientId);                                                                                    /* SBSW_DCM_CALL_FUNCPTR_SVC85SUBFUNC */
# else
    lDemResult = pSubFuncInfo->DemFunc(pRepContext->DTCGroup, DEM_DTC_KIND_ALL_DTCS);                                                                /* SBSW_DCM_CALL_FUNCPTR_SVC85SUBFUNC */
# endif
    switch(lDemResult)
    {
    case DCM_DEM_RET_CONTROL_DTC_SETTING_OK:
      /* success */
      lStdResult = DCM_E_OK;
      break;
# if defined (DCM_DEM_RET_CONTROL_DTC_SETTING_N_OK)
    case DCM_DEM_RET_CONTROL_DTC_SETTING_N_OK:
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      break;
# endif
# if defined (DCM_DEM_RET_CONTROL_DTC_WRONG_DTCGROUP)
    case DCM_DEM_RET_CONTROL_DTC_WRONG_DTCGROUP:
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      break;
# endif
# if defined (DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING)
    case DCM_DEM_RET_CONTROL_DTC_SETTING_PENDING:
      lStdResult = DCM_E_PENDING;
      break;
# endif
    default:
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      lStdResult = DCM_E_NOT_OK;
      break;
    }
  }

  return lStdResult;
}
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc86ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc86ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  /* Return sub-function specific length */
  return Dcm_CfgSvc86SubFuncInfo[sfRef].ReqLength;
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Module API function implementations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_VERSION_INFO_API == STD_ON)
/**********************************************************************************************************************
 *  Dcm_GetVersionInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_GetVersionInfo(P2VAR(Std_VersionInfoType, AUTOMATIC, DCM_APPL_DATA) versioninfo)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(versioninfo == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    versioninfo->vendorID = (uint16)DCM_VENDOR_ID;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    versioninfo->moduleID = (uint16)DCM_MODULE_ID;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
# if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
    versioninfo->instanceID = (uint16)0;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
# endif
    versioninfo->sw_major_version = (uint8)DCM_SW_MAJOR_VERSION;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    versioninfo->sw_minor_version = (uint8)DCM_SW_MINOR_VERSION;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    versioninfo->sw_patch_version = (uint8)DCM_SW_PATCH_VERSION;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETVERSIONINFO, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_TriggerTransmit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_TriggerTransmit(PduIdType txPduId
                                                  ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info)                                                /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType lResult;
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsTxPduIdValid(txPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(info == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(info->SduDataPtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(Dcm_NetPeriodicMsgGetConnection() != Dcm_NetGetConnIdOfTxPduId(txPduId))
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
# endif
  {
    Dcm_CfgNetPTxObjHandleMemType lPerTxObjHandle;

    lPerTxObjHandle = (Dcm_CfgNetPTxObjHandleMemType)Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId);
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    if(Dcm_NetPeriodicMsgNumMsgsCurrConnection() <= lPerTxObjHandle)
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
# endif
    {
      P2VAR(PduInfoType, AUTOMATIC, DCM_VAR_NOINIT) txPduInfoPtr = &(Dcm_PbRamNetPeriodicTxObject[lPerTxObjHandle].TxPduInfo);

      DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

      Dcm_UtiMemCopySafe(txPduInfoPtr->SduDataPtr, info->SduDataPtr, 0u, info->SduLength, txPduInfoPtr->SduLength);                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

      info->SduLength = txPduInfoPtr->SduLength;
      lResult = E_OK;
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TRIGGERTRANSMIT, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DCM_NET_PERIODIC_TX_ENABLED == STD_ON) */

/**********************************************************************************************************************
 *  Dcm_GetActiveProtocol()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetActiveProtocol(P2VAR(Dcm_ProtocolType, AUTOMATIC, DCM_APPL_DATA) ActiveProtocol)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(ActiveProtocol == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#endif
  {
#if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
    if(Dcm_NetGetProtIdOfActiveProtocol() >= DCM_NET_INVALID_PROTID)
    {
      *ActiveProtocol = DCM_NO_ACTIVE_PROTOCOL;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
#endif
    {
      *ActiveProtocol = Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfActiveProtocol()].Id;                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETACTIVEPROTOCOL, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif

  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_GetTesterSourceAddress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetTesterSourceAddress(PduIdType DcmRxPduId
                                                         ,P2VAR(uint16, AUTOMATIC, DCM_APPL_DATA) TesterSourceAddress)
{
  Std_ReturnType lResult;
  uint8          lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = DCM_E_NOT_OK;
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsRxPduIdValid(DcmRxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(TesterSourceAddress == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#endif
  {
    lResult = DCM_E_OK;
    *TesterSourceAddress = Dcm_PbCfgNetConnectionInfo[Dcm_NetGetConnIdOfRxPduId(DcmRxPduId)].ClientSrcAddr;                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETTESTERSOURCEADDRESS, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif

  return lResult;
}

#if (DCM_DIAG_VIRTUAL_REQUEST_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ProcessVirtualRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ProcessVirtualRequest(PduIdType     RxPduId
                                                        ,Dcm_MsgType   Data
                                                        ,PduLengthType Length)
{
  Std_ReturnType lResult;
  uint8          lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = DCM_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsRxPduIdValid(RxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Data == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  /* if (length > <BufferSize>)
  {
    This check is done through the Dcm_NetRxIndInternal API!
  }
  else */
# endif
  {
    lResult = Dcm_NetRxIndInternal(RxPduId, Data, Length);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_PROCESSVIRTUALREQUEST, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_SetActiveDiagnostic()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetActiveDiagnostic(boolean active)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if ( (active != DCM_NET_COMM_ACTIVE)
          &&(active != DCM_NET_COMM_NOT_ACTIVE) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#endif
  {
    /* #30 Enter critical section (Reason: API is reentrant) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /* #40 Apply new ComM management state */
    Dcm_SingletonContext.Network.ActiveDiagnostic = active;
    /* #50 Leave critical section */
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_SETACTIVEDIAGNOSTIC, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif

  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_GetRequestKind()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetRequestKind(uint16 TesterSourceAddress
                                                 ,P2VAR(Dcm_RequestKindType, AUTOMATIC, DCM_APPL_DATA) RequestKind)
{
  Std_ReturnType lResult = DCM_E_NOT_OK;
  uint8 lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (RequestKind == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#endif
  {
    Dcm_NetConnRefMemType connId;

    connId = Dcm_NetGetConnIdByTesterAddress(TesterSourceAddress);

    /* #30 Check if the tester source address is a valid one */
    if (connId < DCM_NET_INVALID_CONNID)
    {
      Dcm_NetTransportObjectPtrType pTranspObj;

      /* Assure that no interrupt will change the state of the conn2tobj map and the tobj state/flags */
      Dcm_UtiArEnvEnterCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
      /*=================================*
        BEGIN CRITICAL SECTION
       *=================================*/
      pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(connId);

      if (pTranspObj == NULL_PTR)
      {
        *RequestKind = DCM_REQ_KIND_NONE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      else
      {
        /* #50 If for this tester any request is ongoing: */
        if (pTranspObj->State != DCM_NET_TOBJ_STATE_FREE)
        {
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
          /* #60 Determine the kind of the request */
          if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0)
          {
            *RequestKind = DCM_REQ_KIND_ROE;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
          }
          else
#endif
          {
            *RequestKind = DCM_REQ_KIND_EXTERNAL;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
          }
        }
        else
        {
          /* #70 Otherwise consider this tester idling */
          *RequestKind = DCM_REQ_KIND_NONE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
        }
      }
      /*=================================*
        END CRITICAL SECTION
       *=================================*/
      Dcm_UtiArEnvLeaveCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

      lResult = DCM_E_OK;
    }/* else - result already set to NOT_OK */
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETREQUESTKIND, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif

  /* #200 Return the final result */
  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ComM_NoComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_NoComModeEntered(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_NetComMContextPtrType pComMContext = Dcm_NetGetComMContext(0);

    Dcm_UtiArEnvEnterCriticalSection(); /* Avoid concurrent access on registerNetworks from an interrupt  */                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    pComMContext->ComState = DCM_NET_COMM_STATE_RX_DIS_TX_DIS;                                                                                       /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERNOCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_ComM_SilentComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_SilentComModeEntered(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_NetComMContextPtrType pComMContext = Dcm_NetGetComMContext(0);

    Dcm_UtiArEnvEnterCriticalSection(); /* Avoid concurrent access on registerNetworks from an interrupt  */                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    pComMContext->ComState = DCM_NET_COMM_STATE_RX_EN_TX_DIS;                                                                                        /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERSILENTCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_ComM_FullComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_FullComModeEntered(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_NetComMContextPtrType pComMContext = Dcm_NetGetComMContext(0);

    Dcm_UtiArEnvEnterCriticalSection(); /* Avoid concurrent access on registerNetworks from an interrupt  */                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    pComMContext->ComState = DCM_NET_COMM_STATE_RX_EN_TX_EN;                                                                                         /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERFULLCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_ProvideRxBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_ProvideRxBuffer(PduIdType DcmRxPduId
                                                     ,PduLengthType TpSduLength
                                                     ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) *PduInfoPtr)
{
  BufReq_ReturnType lResult;
  uint8             lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = BUFREQ_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsRxPduIdValid(DcmRxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(PduInfoPtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    lResult = Dcm_NetProvideRxBuffer(DcmRxPduId, TpSduLength, PduInfoPtr, DCM_NET_TOBJ_FLAG_NONE);                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_PROVIDERXBUFFER, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_RxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_RxIndication(PduIdType DcmRxPduId
                                     ,Dcm_NetArEnvNotifResultType Result)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsRxPduIdValid(DcmRxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfRxPduId(DcmRxPduId));

    if(pTranspObj == NULL_PTR)
    {
      /* just ignore in case the DCM_E_NOT_OK from ProvideRxBuffer has led to the RxIndication
       * (AR does not specify what will happen after this) */
    }
    else
    {
      if(pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX)/* expected state for Rx indication? */
      {
        /* Consider also any nested request on different TP connection but from the same tester! */
        if(DcmRxPduId == pTranspObj->RxPduId)
        {
          if(Result != DCM_NET_ARENV_NTFRSLT_OK)
          {
            Dcm_NetTpRxIndicationNotOk(pTranspObj);                                                                                                  /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
          }
          else
          {
            Dcm_NetTpRxIndicationOk(pTranspObj);                                                                                                     /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
          }
        }/* else - indication of unexpected connection */
      }/* else- could be an unexpected API call but most probably it is due to a concurrent request
        * (StartOfReception returns DCM_E_NOT_OK) from the same tester */
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_RXINDICATION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_ProvideTxBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_ProvideTxBuffer(PduIdType DcmTxPduId
                                                     ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) *PduInfoPtr
                                                     ,PduLengthType Length)
{
  BufReq_ReturnType lResult = BUFREQ_E_NOT_OK;
  uint8             lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsTxPduIdValid(DcmTxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(PduInfoPtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfTxPduId(DcmTxPduId));

    DCM_IGNORE_UNREF_PARAM(DcmTxPduId);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */

    if(pTranspObj == NULL_PTR)                                                                                                                       /* COV_DCM_RTM_UNREACHABLE XF */
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
    {
      /* Always check for valid call state - if free or skip -> ignore call
       * This check is necessary in case Dcm_Init is called some time during ongoing transmission or
       * The ongoing transmission is set to "canceled" (pending TxCancelation)! */
      if( (pTranspObj->State == DCM_NET_TOBJ_STATE_ONTX)
# if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
        &&((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) == 0)
# endif
        )
      {
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
        if(pTranspObj->ResType == DCM_NET_TOBJ_RESTYPE_PAGED)
        {
          lResult = Dcm_PagedBufferCopyData(&pTranspObj->BuffInfo, Length);                                                                          /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
        }
        else
# endif
        {
          DCM_IGNORE_UNREF_PARAM(Length);                                                                                                            /* PRQA S 3112 */ /* MD_Dcm_3112 */
          /* Linear case */
          /* the current buffer is the only one */
          lResult = BUFREQ_OK;
        }

        /* set PduInfo, just in case this is the first call */
        *PduInfoPtr = &(pTranspObj->BuffInfo);                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_PROVIDETXBUFFER, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TxConfirmation(PduIdType DcmTxPduId
                                       ,NotifResultType Result)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(DcmTxPduId);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsTxPduIdValid(DcmTxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
# if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
    /* check if TxPdu is main TxPdu (which is used for TP communication)  */
    /* Note: in ASR3, the TxPdu is identical to the TxConfPdu             */
    if (Dcm_PbCfgNetConnectionInfo[Dcm_NetGetConnIdOfTxPduId(DcmTxPduId)].TxPduIdMain != DcmTxPduId)
    {
      if(Dcm_NetPeriodicMsgGetConnection() != Dcm_NetGetConnIdOfTxPduId(DcmTxPduId))
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else if(Dcm_NetPeriodicMsgGetHandleFromTxPduId(DcmTxPduId) >= Dcm_NetPeriodicMsgNumMsgsCurrConnection())
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
      {
        /* confirmation of IF transmission */
        Dcm_NetPeriodicMsgRelease(Dcm_NetPeriodicMsgGetHandleFromTxPduId(DcmTxPduId));
      }
    }
    else
# endif /* (DCM_NET_PERIODIC_TX_ENABLED == STD_ON) */
    {
      /* confirmation of TP transmission */
      Dcm_NetTpTxConfirmation(DcmTxPduId, Result);
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TXCONFIRMATION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ComM_NoComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_NoComModeEntered(NetworkHandleType networkId)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_NetSetComModeEntered(networkId, DCM_NET_COMM_STATE_RX_DIS_TX_DIS);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERNOCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_ComM_SilentComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_SilentComModeEntered(NetworkHandleType networkId)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_NetSetComModeEntered(networkId, DCM_NET_COMM_STATE_RX_EN_TX_DIS);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERSILENTCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_ComM_FullComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_FullComModeEntered(NetworkHandleType networkId)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_NetSetComModeEntered(networkId, DCM_NET_COMM_STATE_RX_EN_TX_EN);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERFULLCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

# if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnRequestDetection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_OnRequestDetection(PduIdType canTpRxPduId
                                           ,uint8 tpAddrExtension)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

#  if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  /* #10 Check initialization state */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
#  endif
  {
    /* #20 Check whether the CanTpPduId is between the upper and lower bound of DCM CanTpPduIds */
    if(
#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
        (Dcm_PbCfgNetNumCanRxPduIds > 0) &&  /* Check for a non-empty map */
#  endif
        ( (canTpRxPduId >= Dcm_PbCfgNetCanTpRxPduIdMin)
        &&(canTpRxPduId <= Dcm_PbCfgNetCanTpRxPduIdMax) )
      )
    {
      PduIdType lDcmRxPduId;

      /* #30 Retrieve the DCM RxPduId from the CanTp PduId */
      lDcmRxPduId = Dcm_NetGetDcmRxPduIdOfCanTpPduId(canTpRxPduId);

      /* #40 Check for DCM connection on this SDU */
      if(lDcmRxPduId < Dcm_PbCfgNetNumRxPduIds)
      {
        Dcm_NetConnRefMemType lConnId = Dcm_NetGetConnIdOfRxPduId(lDcmRxPduId);

        /* #50 Compare the N_TA with the own ECU address. React only on external ECU requests */
        if(Dcm_NetGetNodeAddress(lConnId) != tpAddrExtension)
        {
          Dcm_NetOnRequestDetection(lConnId);
        }/* else - a DcmPduId and the same N_TA -> request will be ignored on task level */
      }/* else - not a DcmPduId or a functional DcmPduId -> ignore */
    }/* else - not a DcmPduId -> ignore */
  }

#  if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_ONREQUESTDETECTION, lErrorId);
  }
#  else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#  endif
}
# endif

/**********************************************************************************************************************
 *  Dcm_StartOfReception()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_StartOfReception(PduIdType rxPduId
# if (DCM_PDUR_API_412_ENABLED == STD_ON)
                                                      ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                             /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
# endif
                                                      ,PduLengthType tpSduLength
                                                      ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr)
{
  BufReq_ReturnType lResult;
  uint8             lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = BUFREQ_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(bufferSizePtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#  if (DCM_PDUR_API_412_ENABLED == STD_ON)
  /* infoPool and meta-data not supported yet -> must always be NULL_PTR for DCM PDUs */
  if(info != NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#  endif
# endif
  {
# if (DCM_PDUR_API_412_ENABLED == STD_ON)
    DCM_IGNORE_UNREF_PARAM(info);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
    lResult = Dcm_NetStartOfReception(rxPduId, tpSduLength, bufferSizePtr, DCM_NET_TOBJ_FLAG_NONE);                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_STARTOFRECEPTION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_CopyRxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_CopyRxData(PduIdType rxPduId
                                                ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr)
{
  BufReq_ReturnType  lResult = BUFREQ_E_NOT_OK;
  uint8              lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_NetIsPduInfoValid(info) == FALSE)                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(bufferSizePtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfRxPduId(rxPduId));

    DCM_IGNORE_UNREF_PARAM(rxPduId);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

    /* Check always for valid call state - if free or ready -> ignore call
    * This check is necessary in case Dcm_Init is called some time during ongoing transmission
    */
    if(pTranspObj == NULL_PTR)
    {
      /* Check for valid call state */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
    {
      Dcm_DebugAssert((rxPduId == pTranspObj->RxPduId), DCM_SID_COPYRXDATA, DCM_E_ILLEGAL_STATE)                                                     /* COV_DCM_RTM_DEV_DEBUG XF */

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if(pTranspObj->State != DCM_NET_TOBJ_STATE_ONRX)/* expected state for copy Rx? */                                                              /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY XF */
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
# endif
      {
        lResult = Dcm_NetCopyRxData(pTranspObj, info, bufferSizePtr);                                                                                /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COPYRXDATA, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TpRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TpRxIndication(PduIdType rxPduId
                                       ,Dcm_NetArEnvNotifResultType result)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    Dcm_NetTpRxIndication(rxPduId, result);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TPRXINDICATION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_CopyTxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_CopyTxData(PduIdType txPduId
                                                ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                ,P2VAR(RetryInfoType, AUTOMATIC, DCM_APPL_DATA) retry                                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr)
{
  BufReq_ReturnType lResult  = BUFREQ_E_NOT_OK;
  uint8             lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsTxPduIdValid(txPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_NetIsPduInfoValid(info) == FALSE)                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(availableDataPtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if( (retry != NULL_PTR) /* else - if(retry == NULL_PTR) -> not used => OK */
         &&(retry->TpDataState != TP_DATACONF) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfTxPduId(txPduId));

    DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(retry);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

    if(pTranspObj == NULL_PTR)
    {
      /* Check for valid call state */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
    {
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if(pTranspObj->State != DCM_NET_TOBJ_STATE_ONTX)                                                                                               /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY XF */
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
# endif
      {
        lResult = Dcm_NetCopyTxData(pTranspObj, info, availableDataPtr);                                                                             /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COPYTXDATA, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TpTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TpTxConfirmation(PduIdType txPduId
                                         ,Dcm_NetArEnvNotifResultType result)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsTxPduIdValid(txPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfTxPduId(txPduId));

    if(pTranspObj == NULL_PTR)
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
    {
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if(pTranspObj->State != DCM_NET_TOBJ_STATE_ONTX)
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
# endif
      {
        Dcm_NetUsdtTxConfirmation(pTranspObj, Dcm_NetArEnvGetTransmResult(result));                                                                  /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TPTXCONFIRMATION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TxConfirmation(PduIdType txPduId)
{
# if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
  uint8 lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_NetIsTxPduIdValid(txPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_NetPeriodicMsgGetConnection() != Dcm_NetGetConnIdOfTxPduId(txPduId))
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else if(Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId) >= Dcm_NetPeriodicMsgNumMsgsCurrConnection())
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
#  endif /* (DCM_DEV_ERROR_DETECT == STD_ON) */
  {
    Dcm_NetPeriodicMsgRelease(Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId));
  }

#  if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TXCONFIRMATION, lErrorId);
  }
#  else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#  endif
# else
  /* Function is not used since 0x2A or periodic messages are not available.
   * Note: PduR may still need this API to be able to link in case periodic messages are available, but SID 0x2A shall
   * not be supported.
   */
  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif /* (DCM_NET_PERIODIC_TX_ENABLED == STD_ON) */
}
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_ResetToDefaultSession()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ResetToDefaultSession(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
#endif
  {
    /* Just register an externally triggered request for changing back to default diagnostic session */
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF);
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_RESET2DEFAULTSESSION, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif
  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_GetSesCtrlType()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetSesCtrlType(P2VAR(Dcm_SesCtrlType, AUTOMATIC, DCM_APPL_DATA) SesCtrlType)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(SesCtrlType == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#endif
  {
    /* Return the diagnostic session ID of the currently (still) active (committed not pending) diagnostic session state */
    *SesCtrlType = Dcm_CfgStateSessionInfo[Dcm_UtiGetBitPosition(Dcm_SingletonContext.StateMgr.Preconditions.Session)].Value;                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETSESCTRLTYPE, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif

  return DCM_E_OK;
}

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_GetSecurityLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetSecurityLevel(P2VAR(Dcm_SecLevelType, AUTOMATIC, DCM_APPL_DATA) SecLevel)
{
  uint8 lErrorId = DCM_E_NO_ERROR;
  uint8 stateIdx = Dcm_UtiGetBitPosition(Dcm_SingletonContext.StateMgr.Preconditions.Security);

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(SecLevel == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    /* Return the security access level ID of the currently active security access level state */
    *SecLevel = Dcm_StateGetSecurityValue(stateIdx);                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETSECLEVEL, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return DCM_E_OK;
}
#endif

#if (DCM_STATE_SECURITY_EXT_SETTER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_SetSecurityLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetSecurityLevel(Dcm_SecLevelType SecLevel)
{
  Std_ReturnType lResult;
  uint8          lErrorId = DCM_E_NO_ERROR;
  sint8_least    lStateIdx;

  /* #10 Convert security access level to internal zero based security access state handle */
  lStateIdx = Dcm_StateFindStateIndexFromSecLevel(SecLevel);/* Calling this API is safe since it does not depend on any internal DCM state (no initialization is needed!) */

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = DCM_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (lStateIdx < 0)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    /* #50 Check for valid API call context */

    /* Protect against any ISR or higher priority tasks */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if(Dcm_TskTraceIsEmpty())
    {
      /* No task active: this API is called outside of any DCM main-function context! */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else if(Dcm_TskTraceGetCurrTskId() != DCM_TSK_ID_DIAG_WORK)
    {
      /* A task is active, but not the correct one: worker task with low priority! */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
    {
      /* Needed by MISRA */
    }
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if(lErrorId == DCM_E_NO_ERROR)
# endif
    {
      Dcm_StateSetSecurity((Dcm_StateIndexOptType)lStateIdx);
      lResult = DCM_E_OK;
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_SETSECLEVEL, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_GetSecurityLevelFixedBytes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetSecurityLevelFixedBytes(Dcm_SecLevelType SecLevel
                                                             ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) FixedBytes
                                                             ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) BufferSize)
{
  Std_ReturnType  lResult;
  uint8           lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = DCM_E_NOT_OK;

  if (!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if ((FixedBytes == NULL_PTR) || (BufferSize == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    lResult = Dcm_StateGetSecurityLevelFixedBytes(SecLevel, FixedBytes, BufferSize);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETSECLEVELFIXEDBYTES, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}
#endif
/**********************************************************************************************************************
 *  Dcm_InitMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_InitMemory(void)
{
  /* Destroy default RAM content of all DCM variables (for uninitialized global variable revelation) */
  Dcm_UtiRamShredder(Dcm_SingletonContext, DCM_VAR_NOINIT);                                                                                          /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
  Dcm_UtiRamShredder(Dcm_InstanceContext,  DCM_VAR_NOINIT);                                                                                          /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */

  /* Initialize memory of sub-components */
  Dcm_DebugInitMemory(); /* Initialize first to start monitoring the module initialization */
}

/**********************************************************************************************************************
 *  Dcm_Init()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Init(Dcm_ConfigPtrType configPtr)
{
  DCM_IGNORE_UNREF_PARAM(configPtr);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
  if(Dcm_VarMgrInit(configPtr) == TRUE)                                                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
#endif
  {
    /* Initialize run-time kernel sub-system */
    Dcm_TmrInit();
    Dcm_TskInit();

    /* Initialize communication sub-systems */
    Dcm_NetInit();
    Dcm_PagedBufferInit();

    /* Initialize diagnostic service helpers sub-systems */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
    Dcm_DidMgrInit();
#endif
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
    Dcm_MemMgrInit();
#endif

    /* Initialize diagnostic state management sub-systems */
    Dcm_ModeInit();
    Dcm_StateInit();

    /* Initialize diagnostic service processing kernel sub-system */
    Dcm_DiagInit();

    /* Initialize debug sub-component as last to mark DCM as completely initialized */
    Dcm_DebugInit();/* from now on the DCM is ready to work */
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MainFunctionTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_MainFunctionTimer(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_TskScheduler(DCM_TSK_PRIO_HIGH);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_MAINFUNCTION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif

#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MainFunctionWorker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_MainFunctionWorker(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_TskScheduler(DCM_TSK_PRIO_LOW);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_MAINFUNCTION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif

#if (DCM_SPLIT_TASKS_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_MainFunction()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_MainFunction(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_TskScheduler(DCM_TSK_PRIO_NONE);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_MAINFUNCTION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif
#if(DCM_DIAG_EXTERN_SVC_HANDLING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OptimizedProcessingDone()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_OptimizedProcessingDone(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_ProcessingDone();
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_EXT_PROCESSINGDONE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif

#if(DCM_DIAG_EXTERN_SVC_HANDLING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OptimizedSetNegResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_OptimizedSetNegResponse(Dcm_NegativeResponseCodeType errorCode)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_SetNegResponse(errorCode);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_EXT_PROCESSINGDONE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ProvideRecoveryStates()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ProvideRecoveryStates(
                                                    P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo)
{
  Std_ReturnType  lResult;
  uint8           lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = DCM_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(RecoveryInfo == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    Dcm_DiagProvideRecoveryStates(RecoveryInfo);
    lResult = DCM_E_OK;
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_PROVIDERECOVERYSTATES, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}
#endif
#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VsgSetSingle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
*********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgSetSingle(Dcm_VsgIdentifierType VsgId
                                               ,Dcm_VsgStateType State)
{
  /* ----- Local Variables ---------------------------------------------- */
  Std_ReturnType lStdResult;
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ------------------------------------- */
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lStdResult = DCM_E_NOT_OK;

  if (!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if ( (VsgId >= DCM_VARMGR_NUM_CFG_VARIANTS)
         || (VsgId == 0))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  /* ----- Implementation ----------------------------------------------- */
  {
    lStdResult = DCM_E_OK;

    Dcm_VarMgrVsgSetSingle(VsgId, State);
  }

  /* ----- Development Error Report --------------------------------------- */
# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_VSGSETSINGLE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lStdResult;
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VsgIsActive()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
*********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgIsActive(Dcm_VsgIdentifierType VsgId
                                              ,P2VAR(Dcm_VsgStateType, AUTOMATIC, DCM_APPL_DATA) State)
{
  /* ----- Local Variables ---------------------------------------------- */
  Std_ReturnType lStdResult;
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ------------------------------------- */
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lStdResult = DCM_E_NOT_OK;

  if (!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if ( (VsgId >= DCM_VARMGR_NUM_CFG_VARIANTS)
         || (VsgId == 0))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if (State == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  /* ----- Implementation ----------------------------------------------- */
  {
    lStdResult = DCM_E_OK;

    Dcm_VarMgrVsgIsActive(VsgId, State);
  }

  /* ----- Development Error Report --------------------------------------- */
# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_VSGISACTIVE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lStdResult;
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VsgSetMultiple()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
*********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgSetMultiple(P2CONST(Dcm_VsgIdentifierType, AUTOMATIC, DCM_APPL_DATA) VsgIdList
                                                 ,uint16 VsgListSize
                                                 ,Dcm_VsgStateType State)
{
  /* ----- Local Variables ---------------------------------------------- */
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ------------------------------------- */
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if ( (VsgListSize > DCM_VARMGR_NUM_CFG_VARIANTS)
         || (VsgListSize == 0u) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else if (VsgIdList == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  /* ----- Implementation ----------------------------------------------- */
  {
    Dcm_VsgIdentifierType lVsgIter;

    /* Iterate over all passed VSGs */
    for (lVsgIter = 0; lVsgIter < VsgListSize; ++lVsgIter)
    {
      lStdResult = Dcm_VsgSetSingle(VsgIdList[lVsgIter], State);

      if(lStdResult == DCM_E_NOT_OK)
      {
        break;
      }
    }
  }

  /* ----- Development Error Report --------------------------------------- */
# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_VSGSETMULTIPLE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VsgIsActiveAnyOf()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
*********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgIsActiveAnyOf(P2CONST(Dcm_VsgIdentifierType, AUTOMATIC, DCM_APPL_DATA) VsgIdList
                                                 ,uint16 VsgListSize
                                                 ,P2VAR(Dcm_VsgStateType, AUTOMATIC, DCM_APPL_DATA) State)
{
  /* ----- Local Variables ---------------------------------------------- */
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ------------------------------------- */
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if ( (VsgListSize > DCM_VARMGR_NUM_CFG_VARIANTS)
         || (VsgListSize == 0u) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else if (State == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if (VsgIdList == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  /* ----- Implementation ----------------------------------------------- */
  {
    Dcm_VsgIdentifierType lVsgIter;

    /* Iterate over all passed VSGs */
    for (lVsgIter = 0; lVsgIter < VsgListSize; ++lVsgIter)
    {
      lStdResult = Dcm_VsgIsActive(VsgIdList[lVsgIter], State);

      if( (lStdResult == DCM_E_NOT_OK)
        ||(*State == DCM_VSG_ENABLED) )
      {
        break;
      }
    }
  }

  /* ----- Development Error Report --------------------------------------- */
# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_VSGISACTIVEANY, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Module internal API function implementations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrReadSupportedId()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgrReadSupportedId(uint32 maskValue, Dcm_MsgType resData)
{
  resData[0] = Dcm_UtiGetHiHiByte(maskValue);
  resData[1] = Dcm_UtiGetHiLoByte(maskValue);
  resData[2] = Dcm_UtiGetLoHiByte(maskValue);
  resData[3] = Dcm_UtiGetLoLoByte(maskValue);
  return DCM_E_OK;
}

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrReadUdsMid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgrReadUdsMid(Dcm_ObdIdMgrHandleMemType handle
                                                     ,Dcm_OpStatusType opStatus
                                                     ,Dcm_MsgType resData)
{
  Std_ReturnType     lResult = DCM_E_OK; /* if no data to be returned -> positive response (same as Mode 0x06) */
  uint16             lTestValue;
  uint16             lMinLimit;
  uint16             lMaxLimit;
  Dcm_DTRStatusType  lStatus;

  /* data MID -> only one possible */
  P2CONST(Dcm_CfgSvc06MidTidInfoType, AUTOMATIC, DCM_CONST) tidObject = &Dcm_CfgSvc06MidTidInfoTable[Dcm_CfgSvc06Mid2TidRefMap[handle]];
  Dcm_CfgSvc06Mid2TidRefOptType numTids = (Dcm_CfgSvc06Mid2TidRefOptType)( Dcm_CfgSvc06Mid2TidRefMap[handle + 1]
                                                                         - Dcm_CfgSvc06Mid2TidRefMap[handle + 0]);

  for(; numTids != 0; --numTids)
  {
    lResult = tidObject->OpFunc(opStatus, &lTestValue, &lMinLimit, &lMaxLimit, &lStatus);
    if(lResult == DCM_E_OK)
    {
      if(lStatus == DCM_DTRSTATUS_INVISIBLE)
      {
        lTestValue = 0;
        lMinLimit  = 0;
        lMaxLimit  = 0;
      }

      /* Copy data */
      resData[0] = tidObject->Tid;

      resData[1] = tidObject->Uasid;

      resData[2] = Dcm_UtiGetHiByte(lTestValue);
      resData[3] = Dcm_UtiGetLoByte(lTestValue);

      resData[4] = Dcm_UtiGetHiByte(lMinLimit);
      resData[5] = Dcm_UtiGetLoByte(lMinLimit);

      resData[6] = Dcm_UtiGetHiByte(lMaxLimit);
      resData[7] = Dcm_UtiGetLoByte(lMaxLimit);

      Dcm_UtiNextItemByPtr(resData, 8u);/* move to next block of response */
      Dcm_UtiNextItemByPtr(tidObject,1u);/* next MIDTID object */
    }
    else
    {
      break;
    }
  }

  return lResult;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_IsDidAvailable()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_IsDidAvailable(uint16 DID
                                                    ,Dcm_OpStatusType OpStatus
                                                    ,P2VAR(Dcm_DidSupportedType, AUTOMATIC, DCM_VAR_NOINIT) supported)
{
  uint8 lOBDMid = Dcm_UtiGetLoByte(DID);

  DCM_IGNORE_UNREF_PARAM(OpStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  *supported = DCM_DID_NOT_SUPPORTED;

  /* #10 Check kind of DID (Availability ID or Data ID) */
  if (Dcm_ObdIdMgrIsAvailabilityId(DID))
  {
    /* #20 If DID is a availability ID  */
    uint32 lObdMidAvailMask;

    /* #30 Request value of availabity ID from Dem */
    if (Dem_DcmGetAvailableOBDMIDs(lOBDMid, &lObdMidAvailMask) == E_OK)
    {
      /* #40 If request ist successful */
      /* #50 Report to caller that DID is available */
      *supported = DCM_DID_SUPPORTED;
    }
  }
  else
  {
    /* #60 If DID is Data ID */
    uint8 lNumOfTIDs;

    /* #70 Request number of TIDs for Data ID */
    if (Dem_DcmGetNumTIDsOfOBDMID(lOBDMid, &lNumOfTIDs) == E_OK)
    {
      /* #80 If request is successful */
      /* #90 Report to caller that DID is available */
      *supported = DCM_DID_SUPPORTED;
    }
  }

  return DCM_E_OK;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidRangeDataLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidRangeDataLength(uint16 DID
                                                                       ,Dcm_OpStatusType OpStatus
                                                                       ,Dcm_DidMgrDidLengthPtrType DataLength)

{
  Std_ReturnType lStdResult = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(OpStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* #10 Check kind of DID (Availability ID or Data ID) */
  if (Dcm_ObdIdMgrIsAvailabilityId(DID))
  {
    /* #20 If DID is a availability ID  */
    /* #30 Set data length to 4 */
    *DataLength = 4u;
  }
  else
  {
    /* #40 Otherwise DID is a Data ID */
    uint8 lObdMid = Dcm_UtiGetLoByte(DID);
    uint8 lNumOfTIDs;

    /* #50 Request number of TIDs for Data ID */
    if (Dem_DcmGetNumTIDsOfOBDMID(lObdMid, &lNumOfTIDs) == E_OK)
    {
      /* #60 If request is successful calculate total response data length */
      *DataLength = lNumOfTIDs * 8;
    }
    else
    {
      /* #70 Otherwise something went wrong - report back */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData(uint16 DID
                                                          ,Dcm_MsgType Data
                                                          ,Dcm_OpStatusType OpStatus
                                                          ,Dcm_DidMgrDidLengthPtrType DataLength
                                                          ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  uint8 lObdMid = Dcm_UtiGetLoByte(DID);

  DCM_IGNORE_UNREF_PARAM(OpStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* #10 Check kind of DID (Availability ID or Data ID) */
  if (Dcm_ObdIdMgrIsAvailabilityId(DID))
  {
    /* #20 If DID is a availability ID */
    /* #30 Read value of availabiltity Id */
    lStdResult = Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId(lObdMid, Data, DataLength, ErrorCode);
  }
  /* #40 Otherwise */
  else
  {
    /* #50 Read Value of Data Id */
    lStdResult = Dcm_ObdIdMgr_F6XX_ReadDidData_DataId(lObdMid, Data, DataLength, ErrorCode);
  }

  return lStdResult;
}
# endif

# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetDidAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(uint32, DCM_CODE) Dcm_ObdIdMgrGetDidAvailabilityMask(uint16 DidLookUpRefStart
                                                         ,uint16 DidLookUpRefEnd
                                                         ,Dcm_ObdIdMgrMaskValueTableType maskValue)
{
  uint32 lResultMask;
  uint16_least lLookUpIter;

  DCM_IGNORE_UNREF_PARAM(maskValue);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lResultMask = 0;

  /* #10 Iterate over all (WWH-)OBD DIDs related to the AID */
  for(lLookUpIter  = DidLookUpRefStart;
      lLookUpIter <= DidLookUpRefEnd;
      ++lLookUpIter)
  {
    Dcm_DidMgrDidInfoContextType didContext;
    uint8 lDidLowByte;

    /* #20 Consider only the DID low-byte since the AID reports the availability mask only for a certain
     * DID range (e.g 0xF4XX).
     */
    lDidLowByte = Dcm_UtiGetLoByte(Dcm_CfgDidMgrDidLookUpTable[lLookUpIter]);

    didContext.Descriptor.DidInfoPtr = &Dcm_CfgDidMgrDidInfo[lLookUpIter-1];
    Dcm_DidMgrGetDidOpInfo(&didContext, DCM_DIDMGR_OP_READ);

    /* #30 If the DID is (still) supported: */
    if(Dcm_VarMgrIsEnabledInActiveVariants(didContext.Descriptor.DidOpInfoPtr->ExecCondRef) == TRUE)
    {
      /* #40 Set the corresponding bit in the availability bitmap */
      Dcm_UtiBitOpSet(uint32, lResultMask, Dcm_ObdIdMgrGetObdIdMaskBit(lDidLowByte));
    }
  }

#  if (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED == STD_ON)
  /* #50 Consider any DIDs additionally suppressed by calibration procedure */
  lResultMask &= maskValue;
#  endif

  /* #60 Return calculated availability ID bitmap */
  return lResultMask;
}
# endif

# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetRidAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(uint32, DCM_CODE) Dcm_ObdIdMgrGetRidAvailabilityMask(uint16 RidLookUpRefStart
                                                         ,uint16 RidLookUpRefEnd
                                                         ,Dcm_ObdIdMgrMaskValueTableType maskValue)
{
  uint32 lResultMask;
  uint16_least lLookUpIter;

  DCM_IGNORE_UNREF_PARAM(maskValue);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lResultMask = 0;
  /* #10 Iterate over all (WWH-)OBD RIDs related to the AID */
  for(lLookUpIter  = RidLookUpRefStart;
      lLookUpIter <= RidLookUpRefEnd;
      ++lLookUpIter)
  {
    uint8 lRidLowByte;
    /* #20 Consider only the RID low-byte since the AID reports the availability mask only for a certain
     * RID range (e.g 0xE0XX).
     */
    lRidLowByte = Dcm_UtiGetLoByte(Dcm_CfgRidMgrRidLookUpTable[lLookUpIter]);

    /* #30 If the RID is (still) supported: */
    if(Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgRidMgrRidInfo[lLookUpIter-1].ExecCondRef) == TRUE)
    {
      /* #40 Set the corresponding bit in the availability bitmap */
      Dcm_UtiBitOpSet(uint32, lResultMask, Dcm_ObdIdMgrGetObdIdMaskBit(lRidLowByte));
    }
  }

#  if (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED == STD_ON)
  /* #50 Consider any RIDs additionally suppressed by calibration procedure */
  lResultMask &= maskValue;
#  endif

  /* #60 Return calculated availability ID bitmap */
  return lResultMask;
}
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_UtiLookUpUint8()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(sint16_least, DCM_CODE) Dcm_UtiLookUpUint8(Dcm_Uint8ConstDataPtrType lookUpTable, uint8 value)
{
  sint16_least iter;
  sint16_least lResult = -1;

  for(iter = (sint16_least)lookUpTable[0]; iter>0; --iter)
  {
    if(lookUpTable[iter] == value)
    {
      lResult = (sint16_least)(iter-1);
      break;
    }
  }
  return lResult;
}

#if(DCM_UTI_NVM_READ_ENABLED == STD_ON)                                                                                                              /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_UtiNvMRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiNvMRead(Dcm_OpStatusType                opStatus
                                             ,Dcm_GenericDcmRamNoInitPtrType  data
                                             ,uint16                          blockId)
{
  Std_ReturnType lStdResult;

  lStdResult = E_OK;

  /* #10 If first call: */
  if(opStatus == DCM_INITIAL)
  {
    /* #20 Initiate NvM read operation */
    lStdResult = NvM_ReadBlock(blockId, data);

    /* #30 If NvM operation accepted: */
    if (lStdResult == E_OK)
    {
      /* #40 Try immediate get status */
    }
    else
    {
      /* #50 Otherwise: NvM request failed; close job */
      lStdResult = E_NOT_OK;
    }
  }
  else
# if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  /* #60 If service is canceled: */
  if (opStatus == DCM_CANCEL)
  {

    /* #70 Try to cancel NvM read; this is all we can do. Operation result is not from importance */
    (void)NvM_CancelJobs(blockId);

    /* #80 Finish the job with failed */
    lStdResult = E_NOT_OK;
  }
  else
# endif
  {
    /* Shall not be any other then DCM_PENDING (i.e. DCM_FORCE_RCRRP_OK or DCM_FORCE_RCRRP_NOT_OK) */
    Dcm_DebugAssert((opStatus == DCM_PENDING), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                /* COV_DCM_RTM_DEV_DEBUG XF */
  }

  /* #90 If no error found during NvM request or just next call of this function: */
  if(lStdResult == E_OK)
  {
    /* #100 Gather and return the NvM operation state */
    lStdResult = Dcm_UtiNvMGetErrorStatus(blockId);
  }/* else - result is already E_NOT_OK */

  /* #110 Return final result */
  return lStdResult;
}
#endif

#if(DCM_UTI_NVM_WRITE_ENABLED == STD_ON)                                                                                                             /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_UtiNvMWrite()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiNvMWrite(Dcm_OpStatusType                     opStatus
                                              ,Dcm_GenericDcmConstRamNoInitPtrType  data
                                              ,uint16                               blockId)
{
  Std_ReturnType lStdResult;

  lStdResult = E_OK;

  /* #10 If first call: */
  if(opStatus == DCM_INITIAL)
  {
    /* #20 Initiate NvM write operation */
    lStdResult = NvM_WriteBlock(blockId, data);
    /* #30 If NvM operation accepted: */
    if (lStdResult == E_OK)
    {
      /* #40 Try immediate get status */
    }
    else
    {
      /* #50 Otherwise: NvM request failed; close job */
      lStdResult = E_NOT_OK;
    }
  }
  else
# if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  /* #60 If service is canceled: */
  if (opStatus == DCM_CANCEL)
  {
    /* #70 Try to cancel NvM write; this is all we can do. Operation result is not from importance */
    (void)NvM_CancelJobs(blockId);

    /* #80 Finish the job with failed */
    lStdResult = E_NOT_OK;
  }
  else
# endif
  {
    /* Shall not be any other then DCM_PENDING (i.e. DCM_FORCE_RCRRP_OK or DCM_FORCE_RCRRP_NOT_OK) */
    Dcm_DebugAssert((opStatus == DCM_PENDING), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                /* COV_DCM_RTM_DEV_DEBUG XF */
  }

  /* #90 If no error found during NvM request or just next call of this function: */
  if(lStdResult == E_OK)
  {
    /* #100 Gather and return the NvM operation state */
    lStdResult = Dcm_UtiNvMGetErrorStatus(blockId);
  }/* else - result is already E_NOT_OK */

  /* #110 Return final result */
  return lStdResult;
}
#endif

#if(DCM_UTI_NVM_SWCDATA_WRITE_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_UtiNvMSwcDataWrite()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiNvMSwcDataWrite(Dcm_OpStatusType                     opStatus
                                                     ,Dcm_GenericDcmConstRamNoInitPtrType  data
                                                     ,uint16                               blockId)
{
  Std_ReturnType lStdResult;

  /* #10 If first call: */
  if(opStatus == DCM_INITIAL)
  {
    /* #20 Lock the access to the blockId for any other NvM client */
    NvM_SetBlockLockStatus(blockId, TRUE);
  }

  /* #30 Perform normal NvM write operation */
  lStdResult = Dcm_UtiNvMWrite(opStatus, data, blockId);

  /* #40 If NvM operation failed for any reason */
  if(lStdResult == DCM_E_NOT_OK)
  {
    /* #50 Unlock the access to the current blockId for other clients */
    NvM_SetBlockLockStatus(blockId, FALSE);
  }/* else - DCM_E_PENDING, DCM_E_OK */

  /* #60 Return operation result */
  return lStdResult;
}
#endif
#if(DCM_EXT_NEED_API_DEBUGISMODULEINITIALIZED_ENABLED == STD_ON)                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DebugIsModuleInitialized()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(boolean, DCM_CODE) Dcm_DebugIsModuleInitialized(void)
{
  return (boolean)Dcm_DebugOptIsModuleInitialized();
}
#endif

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
/**********************************************************************************************************************
 *  Dcm_DebugCatchCriticalError()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_DebugCatchCriticalError(Dcm_ExtendedSidType extApiSid)
{
  DCM_IGNORE_UNREF_PARAM(extApiSid);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  Dcm_DebugDeInit();

  Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  Dcm_DebugAssertAlways(extApiSid, DCM_E_CRITICAL_ERROR)
}
#endif
#if (DCM_EXT_NEED_API_NETGETCOMSTATE_ENABLED == STD_ON)                                                                                              /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetGetComState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Dcm_NetComMStateType, DCM_CODE) Dcm_NetGetComState(PduIdType rxPduId)
{
  Dcm_NetComMStateType lResult;
  uint8                lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(rxPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult  = DCM_NET_COMM_STATE_RX_DIS_TX_DIS;

  if(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    lResult = Dcm_NetGetComStateByRxPduId(rxPduId);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)
# if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxIndInternal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_NetRxIndInternal(PduIdType     rxPduId
                                                   ,Dcm_MsgType   data                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                   ,PduLengthType length)
{
  Dcm_NetArEnvNotifResultType notifResult = DCM_NET_ARENV_NTFRSLT_NOT_OK;
  BufReq_ReturnType bufReq;
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) rxPduInfoPtr = NULL_PTR;

#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  Dcm_DebugAssert((Dcm_NetGetConnIdOfRxPduId(rxPduId) < Dcm_PbCfgNetNumConnections), DCM_SID_INTERNAL, DCM_E_PARAM)                                  /* COV_DCM_RTM_DEV_DEBUG XF */
#  endif

  /* start virtual request; */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Initiate reception for the required RxPduID. Mark this reception as an internal one in order to get correct
   * ComM management.
   */
  bufReq = Dcm_NetProvideRxBuffer(rxPduId, length, &rxPduInfoPtr, DCM_NET_TOBJ_FLAG_INTERNAL);                                                       /* SBSW_DCM_POINTER_FORWARD_STACK */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */

  if(bufReq == BUFREQ_OK)
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfRxPduId(rxPduId));

    if(pTranspObj == NULL_PTR)                                                                                                                       /* COV_DCM_RTM_UNREACHABLE XF */
    {
      /* Check for valid call state */
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                   /* COV_DCM_RTM_DEV_DEBUG XF */
    }
    else
    {
#  if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      /* If not a pseudo parallel request */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) == 0)
#  endif
      {
#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
        /* since buffer status is BUFREQ_OK and the TransportObj is not busy, the provided buffer must be valid and
        *  large enough!
        */
        if(rxPduInfoPtr == NULL_PTR)                                                                                                                 /* COV_DCM_RTM_UNREACHABLE XF */
        {
          Dcm_DebugCatchCriticalError(DCM_EXT_SID_NETRXINDINTERNAL);
        }
        else
#  endif
        {
          /* Copy received data */
          Dcm_UtiMemCopySafe(data, rxPduInfoPtr->SduDataPtr, 0u, rxPduInfoPtr->SduLength, length);                                                   /* SBSW_DCM_POINTER_WRITE_RXPDUINFO */
          notifResult = DCM_NET_ARENV_NTFRSLT_OK;
        }
      } /* else - a pseudo parallel request will not be processed over an internal request */
    }

    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_RxIndication(rxPduId, notifResult);
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

  } /* else - no reception possible, exit with fail */

  return Dcm_NetArEnvGetTransmResult(notifResult);
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)
# if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxIndInternal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_NetRxIndInternal(PduIdType     rxPduId
                                                   ,Dcm_MsgType   data                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                   ,PduLengthType length)
{
  Dcm_NetArEnvNotifResultType notifResult = DCM_NET_ARENV_NTFRSLT_NOT_OK;
  BufReq_ReturnType bufReq;
  PduLengthType     bufferSize;

#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  Dcm_DebugAssert((Dcm_NetGetConnIdOfRxPduId(rxPduId) < Dcm_PbCfgNetNumConnections), DCM_SID_INTERNAL, DCM_E_PARAM)                                  /* COV_DCM_RTM_DEV_DEBUG XF */
#  endif

  /* start virtual request; */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* #10 Initiate reception for the required RxPduID. Mark this reception as an internal one in order to get correct
   * ComM management.
   */
  bufReq = Dcm_NetStartOfReception(rxPduId, length, &bufferSize, DCM_NET_TOBJ_FLAG_INTERNAL);                                                        /* SBSW_DCM_POINTER_FORWARD_STACK */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */

  /* #20 If reception accepted: */
  if(bufReq == BUFREQ_OK)
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    pTranspObj = Dcm_NetGetTranspObjOfConnectionOrNull(Dcm_NetGetConnIdOfRxPduId(rxPduId));

    if(pTranspObj == NULL_PTR)                                                                                                                       /* COV_DCM_RTM_UNREACHABLE XF */
    {
      /* Check for valid call state */
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                   /* COV_DCM_RTM_DEV_DEBUG XF */
    }
    else
    {
#  if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      /* #30 If not a pseudo parallel request */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) == 0)
#  endif
      {
        PduInfoType   pduInfo;

        pduInfo.SduDataPtr = data;
        pduInfo.SduLength = length;

        /* #40 Copy received data */
        bufReq = Dcm_CopyRxData(rxPduId, &pduInfo, &bufferSize);                                                                                     /* SBSW_DCM_POINTER_FORWARD_STACK */
        /* #50 If data copy succeeded: */
        if(bufReq == BUFREQ_OK)                                                                                                                      /* COV_DCM_RTM_UNREACHABLE TX */
        {
          /* #60 Notify DCM about successful reception */
          notifResult = DCM_NET_ARENV_NTFRSLT_OK;
        }/* else - Dcm_CopyRxData failed -> exit with Dcm_TpRxIndication(failed) */
      }/* else - a pseudo parallel request will not be processed over an internal request */
    }
    /* #70 Notify DCM about reception accomplishment only in case the reception was accepted */
    Dcm_TpRxIndication(rxPduId, notifResult);
  }/* else - no reception possible exit with fail */
  /* #80 Return the operation result to the caller */
  return Dcm_NetArEnvGetTransmResult(notifResult);
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_RepeaterSetCallee()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_RepeaterSetCallee(uint8 serviceProcessorIdx)
{
  Dcm_InstanceContext.Repeater.CalleeIdx = serviceProcessorIdx;
  Dcm_RepeaterNextStep(DCM_REPEATER_PROGRESS_INITIAL);
}

#if (DCM_REPEATER_EXT_CONTEXT_GETTER_ENABLED == STD_ON)                                                                                              /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_RepeaterGetExtSvcContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Dcm_GenericDcmRamNoInitPtrType, DCM_CODE) Dcm_RepeaterGetExtSvcContext(Dcm_RepeaterSvcContextHandleType handle)
{
  Dcm_GenericDcmRamNoInitPtrType lResult;
  uint8                lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(handle);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */
# if (DCM_DEV_ERROR_DETECT == STD_ON)
  lResult  = NULL_PTR;
  if(handle != DCM_REPEATER_EXT_CNTXT_SVC86)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    lResult = (Dcm_GenericDcmRamNoInitPtrType)(&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc86.ExtSvc86RepeaterContext));
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
  return lResult;
}
#endif
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODE_ROE_ENABLED == STD_ON)                                                                                                                /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ModeSwitchRoE()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ModeSwitchRoE(Rte_ModeType_DcmResponseOnEvent mode)
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_ModeOnRoEModeChange(mode);

  DCM_IGNORE_UNREF_PARAM(lStdResult);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
  Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
}
# endif
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_TskSetEvent()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TskSetEvent(Dcm_TskTaskIdOptType taskId
                                    ,Dcm_TskTaskEvMemType ev)
{
  Dcm_TskSchedulerContextPtrType pSchedulerContext;
  Dcm_TskTaskContextPtrType      pTaskContext;

  /* No zero events are allowed! Possibly the Dcm_TskTaskEvMemType is too small to hold the value? */
  Dcm_DebugAssert((ev != DCM_TSK_EV_NONE), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                            /* COV_DCM_RTM_DEV_DEBUG XF */

  pSchedulerContext = Dcm_TskGetSchedulerContextOrNull(Dcm_TskTaskInfo[taskId].TskPrio);
  pTaskContext = Dcm_TskGetTaskContextOrNull(taskId);

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if ( (pSchedulerContext != NULL_PTR)
     &&(pTaskContext != NULL_PTR) )                                                                                                                  /* COV_DCM_RTM_RUNTIME_CHECK TX tx tx */
#endif
  {
    /* Enter critical section (Reason: a task event can be set during any ISR or higher priority task processing.) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
#if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)
    /* If the task is marked as suspended, do set only those new events that are non-killable */
    if(Dcm_TskIsFlagSet(pTaskContext, DCM_TSK_TASK_FLAG_KILLED))
    {
      /* mask all to be set events, except the non-killable ones! */
      ev &= Dcm_TskTaskInfo[taskId].NonKillEvents;
    }
#endif
    /* Add any masked/unmasked new events */
    Dcm_UtiBitOpSet(Dcm_TskTaskEvMemType, pTaskContext->TaskEvents, ev);                                                                             /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */
    /* Activate the scheduler associated with the task */
    pSchedulerContext->SchdIsActive = TRUE;                                                                                                          /* SBSW_DCM_POINTER_WRITE_SCHEDULERCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
}

/**********************************************************************************************************************
 *  Dcm_TskClrEvent()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TskClrEvent(Dcm_TskTaskIdOptType taskId
                                    ,Dcm_TskTaskEvMemType ev)
{
  Dcm_TskTaskContextPtrType pTaskContext;

  /* No zero events are allowed! Possibly the Dcm_TskTaskEvMemType is too small to hold the value? */
  Dcm_DebugAssert((ev != DCM_TSK_EV_NONE), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                            /* COV_DCM_RTM_DEV_DEBUG XF */

  pTaskContext = Dcm_TskGetTaskContextOrNull(taskId);

#if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                               /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (pTaskContext != NULL_PTR)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK TX */
#endif
  {
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_UtiBitOpClr(Dcm_TskTaskEvMemType, pTaskContext->TaskEvents, ev);                                                                             /* PRQA S 0291 */ /* MD_Dcm_BitNegation_0291 */ /* SBSW_DCM_POINTER_WRITE_TASKCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
}
/**********************************************************************************************************************
 *  Dcm_TmrStartTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TmrStartTimer(Dcm_TmrTimerIdOptType timerId, Dcm_TmrTimerCntrMemType timeTicks)
{
  /* Timer Id out of range */
  Dcm_DebugAssert((timerId < DCM_TMR_NUM_TIMERS_CASTED), DCM_SID_INTERNAL, DCM_E_PARAM)                                                              /* COV_DCM_RTM_DEV_DEBUG XF */
  /* No zero times are allowed! Possibly the Dcm_TmrTimerCntrMemType is too small to hold the value? */
  Dcm_DebugAssert((timeTicks != 0u), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */

  /* Enter critical section (Reason: A timer can be modified from an ISR or higher priority task) */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Update the corresponding timer counter */
  Dcm_TmrSetTimer(timerId, timeTicks);
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /* Signal the Dcm_TmrTaskTimer() that at least one timer is active */
  Dcm_TskSetEvent(DCM_TSK_ID_TIMER, DCM_TSK_EV_TIMER_ACTIVE);
}

/**********************************************************************************************************************
 *  TmrMgrStopTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TmrStopTimer(Dcm_TmrTimerIdOptType timerId)
{
  /* Timer Id out of range */
  Dcm_DebugAssert((timerId < DCM_TMR_NUM_TIMERS_CASTED), DCM_SID_INTERNAL, DCM_E_PARAM)                                                              /* COV_DCM_RTM_DEV_DEBUG XF */

  /* Enter critical section (Reason: A timer can be modified from an ISR or higher priority task) */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Reset the corresponding timer counter */
  Dcm_TmrSetTimer(timerId, 0u);
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_NVM_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadNvMSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrNvMReadSignal(Dcm_OpStatusType                opStatus
                                                      ,Dcm_MsgType                     data
                                                      ,uint16                          blockId)
{
  return Dcm_UtiNvMRead(opStatus, data, blockId);
}
# endif

# if (DCM_DIDMGR_NVM_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWriteNvMSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrNvMWriteSignal(Dcm_ReadOnlyMsgType data
                                                       ,Dcm_OpStatusType opStatus
                                                       ,Dcm_NegativeResponseCodePtrType errorCode
                                                       ,uint16 blockId)
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_UtiNvMSwcDataWrite(opStatus, data, blockId);

  if(lStdResult == DCM_E_NOT_OK)
  {
    *errorCode = DCM_E_GENERALPROGRAMMINGFAILURE;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  return lStdResult;
}
# endif

# if (DCM_DIDMGR_SR_IO_CONTROL_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_DidMgrIoCtrlSRHandler_Control()
*********************************************************************************************************************/
/*!
* Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
*********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoCtrlSRHandler_Control(Dcm_CfgDidMgrIoCtrlSRHandlersRefOptType srEntryIndex
                                                   ,uint8 ioOperation
                                                   ,Dcm_ReadOnlyMsgType reqData
                                                   ,Dcm_OpStatusType opStatus
                                                   ,uint32 cemr
                                                   ,Dcm_NegativeResponseCodePtrType  errorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  Dcm_IOOperationResponseType ioResponse;
  Dcm_DidMgrIoCtrlSRHandlersConstPtrType pIoControlSrHandlers = &(Dcm_CfgDidMgr_IOControlSenderReceiverHandlers[srEntryIndex]);

  *errorCode = DCM_E_POSITIVERESPONSE;

  /* ignore parameter reqData if no IO Did supports ShortTermAdjustment */
  DCM_IGNORE_UNREF_PARAM(reqData);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if (opStatus == DCM_INITIAL)
  {
    /* Clear IsUpdated flag */
    lStdResult = pIoControlSrHandlers->IoCtrlResRead(&ioResponse);

#  if (DCM_DIDMGR_SR_IO_SHORT_TERM_ADJUSTMENT_ENABLED == STD_ON)
    if ((ioOperation == 0x03u) && (lStdResult == DCM_E_OK))
    {
      Dcm_DebugAssert((reqData != NULL_PTR), DCM_SID_INTERNAL, DCM_E_PARAM_POINTER)                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      /* Transfer requested data */
      lStdResult = pIoControlSrHandlers->IoCtrlReqCtrlStateWrite(reqData);
    }
#  endif

    if (lStdResult == DCM_E_OK)
    {
      /* Transfer new IO operation and new CEMR  */
      lStdResult = pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(ioOperation, cemr);
    }
  }

  /* OpStatus == DCM_CANCEL has no negative effect -> leave it unhandled */

  /* Get acknowledge */
  if (lStdResult == DCM_E_OK)
  {
    if (pIoControlSrHandlers->IoCtrlResIsUpdated() == TRUE)
    {
      lStdResult = pIoControlSrHandlers->IoCtrlResRead(&ioResponse);
      if (lStdResult == DCM_E_OK)
      {
        switch (ioResponse)
        {
        case DCM_POSITIVE_RESPONSE:
        {
          uint32 underControl;
          lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlRead(&underControl);
          if (lStdResult == DCM_E_OK)
          {
            lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlWrite(underControl | cemr);
          }
          /* Set IO Operation to Idle (0xFF); return value is not evaulated due to final response of application */
          (void)pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(0xFFu, cemr);
        }
          break;
        case DCM_RESPONSE_PENDING:
        case DCM_IDLE: /* still no result */
          lStdResult = DCM_E_PENDING;
          break;
        default: /* any NRC */
          /* Set IO Operation to Idle (0xFF); return value is not evaulated due to final response of application */
          (void)pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(0xFFu, cemr);
          *errorCode = ioResponse;
          lStdResult = DCM_E_NOT_OK;
          break;
        }
      }
    }
    else
    {
      lStdResult = DCM_E_PENDING;
    }
  }

  if ((lStdResult == DCM_E_NOT_OK) && (*errorCode == DCM_E_POSITIVERESPONSE))
  {
    *errorCode = DCM_E_PANIC_NRC;
  }/* else:RTE error codes are handled in DCM core */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6060, 6080 */ /* MD_MSR_STCYC,  MD_Dcm_Design_6060, MD_MSR_STMIF */
# endif

# if (DCM_DIDMGR_SR_IO_CONTROL_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_DidMgrIoCtrlSRHandler_Reset()
*********************************************************************************************************************/
/*!
* Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
*********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoCtrlSRHandler_Reset(Dcm_CfgDidMgrIoCtrlSRHandlersRefOptType srEntryIndex
                                                 ,uint32 cemr
                                                 ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint32 underControl;

  Dcm_DidMgrIoCtrlSRHandlersConstPtrType pIoControlSrHandlers = &(Dcm_CfgDidMgr_IOControlSenderReceiverHandlers[srEntryIndex]);

  /* Update under control elements */
  lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlRead(&underControl);

  if (lStdResult == DCM_E_OK)
  {
    lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlWrite(underControl & ~cemr);
  }

  if (lStdResult == DCM_E_OK)
  {
    /* Transfer new IO operation and new CEMR  */
    lStdResult = pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(0x00u, cemr);
  }

  if (lStdResult == DCM_E_NOT_OK)
  {
    *errorCode = DCM_E_PANIC_NRC;
  }/* else:RTE error codes are handled in DCM core */

  return lStdResult;
}
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_EXT_NEED_API_DIAGGETACTIVITYSTATE_ENABLED == STD_ON)                                                                                        /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagGetActivityState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Dcm_DiagProcessorStateType, DCM_CODE) Dcm_DiagGetActivityState(void)
{
  return Dcm_InstanceContext.Diag.State;
}
#endif
#if (DCM_EXT_NEED_API_VARMGRGETACTIVECOMVARIANT_ENABLED == STD_ON)                                                                                   /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VarMgrGetActiveComVariant()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Dcm_CfgVarMgrComVariantType, DCM_CODE) Dcm_VarMgrGetActiveComVariant(void)
{
  return Dcm_SingletonContext.VarMgr.ActiveComVariant;
}
#endif
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27Init()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Service27Init(void)
{
  Dcm_Svc27ResetSequence();
# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
  {
    /* For each security level: */
    uint8_least lSecLvlIter;

    for(lSecLvlIter = 0; lSecLvlIter < DCM_STATE_SECURITY_NUM_LEVELS; ++lSecLvlIter)
    {
      /* Initialize the security timer and counter */
      Dcm_Svc27TimerReset(lSecLvlIter);
      Dcm_Svc27CounterReset(lSecLvlIter);

#  if(DCM_STATE_SEC_DELAY_ON_BOOT_ENABLED == STD_ON)
      /* If a delay time on boot is supported: */
      if(Dcm_CfgStateSecurityInfo[lSecLvlIter].DelayTimeOnBoot != 0u)
      {
        /* Start the appropriate security timer */
        Dcm_Svc27TimerSet(lSecLvlIter, Dcm_CfgStateSecurityInfo[lSecLvlIter].DelayTimeOnBoot);                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */
        Dcm_Svc27TimerStart(lSecLvlIter);                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
      }
#  endif
    }
  }

  /* Initialize the bit masks related to Get- and Set-AttemptCounter APIs */
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.Services.Svc27.GetAttCntrEventMask = DCM_SVC_27_LEVEL_MASK;
  Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask = 0u;
#   if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.Services.Svc27.ReloadMask = 0u;
#   endif
  Dcm_InstanceContext.Diag.Services.Svc27.GetAttOpStatus = DCM_INITIAL;
  Dcm_InstanceContext.Diag.Services.Svc27.SetAttOpStatus = DCM_INITIAL;

  /* Trigger the reading of the attempt counter values */
  Dcm_TskSetEvent(DCM_TSK_ID_SVC27, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_READ);
#  endif
# endif
}
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service2AInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Service2AInit(void)
{
  Dcm_Service2ASchedulerInit();
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrRead(Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
                                                  ,Dcm_OpStatusType opStatus
                                                  ,Dcm_MsgType data)
{
  Std_ReturnType lStdReturn;

  /* The DDDID shall be a defined one! */
  Dcm_DebugAssert((Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Count != 0u), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                  /* COV_DCM_RTM_DEV_DEBUG XF */

  lStdReturn = Dcm_Svc2CDefMgrReadCheckAccessAndInit(dynDidHandle, &opStatus);

  if(lStdReturn == DCM_E_OK)
  {
    if(opStatus == DCM_INITIAL)
    {
# if (DCM_DIDMGR_DYNDID_ASYNC_SUPPORT_ENABLED == STD_ON)
      Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse = dynDidHandle;
# endif
      Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress = Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle);
      Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemToStop = (Dcm_CfgDidMgrDynDidHandleMemType)(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress + Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Count);
      Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ResData = data;
    }

    /* Process source items */
    lStdReturn = Dcm_Svc2CDefMgrReadSrcItems(opStatus);
  }

# if (DCM_DIDMGR_DYNDID_ASYNC_SUPPORT_ENABLED == STD_ON)
  if(lStdReturn != DCM_E_PENDING)
  {
    /* Release resource */
    Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse = DCM_SVC2C_INVALID_DYNDID_HDL;
  }
# endif
  return lStdReturn;
}

# if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_COND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrConditionCheckRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrConditionCheckRead(Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
                                                                ,Dcm_OpStatusType opStatus
                                                                ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK; /* if the DynDID does not contain any DID sources -> always OK */
  /* The DDDID shall be a defined one! */
  Dcm_DebugAssert((Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Count != 0u), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                  /* COV_DCM_RTM_DEV_DEBUG XF */

  if(opStatus == DCM_INITIAL)
  {
    Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress = Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle);
    Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemToStop = (Dcm_CfgDidMgrDynDidHandleMemType)(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress + Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Count);
  }

  for(;
      ( Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress
       <Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemToStop);
      ++Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress)
  {
#  if (DCM_SVC_2C_HYBRID_MODE_ENABLED == STD_ON)
    if(Dcm_Svc2CIsDidSrcItem(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress))
#  endif
    {
#  if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ALL_ENABLED == STD_OFF)
      if(Dcm_DidMgrIsOpTypeSupported(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress].DidDescriptor.DidContext.Descriptor.DidOpInfoPtr, DCM_DIDMGR_OPTYPE_READCHKCOND))
#  endif
      {
        Dcm_DidMgrGetOpClassInfo(&(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress].DidDescriptor.DidContext)
                                ,DCM_DIDMGR_OPTYPE_READCHKCOND);

        lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                            ,&(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress].DidDescriptor.DidContext)
                                            ,&(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].DidOpTypeContext)
                                            ,errorCode);
        if(lStdResult == DCM_E_OK)
        {
          /* prepare for next item */
          opStatus = DCM_INITIAL;
        }
        else
        {
          break; /* just delegate the return value */                                                                                                /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
        }
      }/* else - no check condition supported by this signal */
    }/* else - memory ranges cannot be checked in advance! */
  }
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadDataLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadDataLength(Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
                                                            ,Dcm_DidMgrDidLengthPtrType dataLength)
{
  *dataLength = Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Length;
  return DCM_E_OK;
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service2CInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Service2CInit(void)
{
  Dcm_Svc2CDefMgrInit();
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service2FInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Service2FInit(void)
{
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  Dcm_CfgDidMgrIoDidHandleOptType ioDidIter;

  Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid = FALSE;
  for(ioDidIter = 0; ioDidIter < Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS_CONST); ++ioDidIter)
  {
    Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids[ioDidIter] = 0u;
  }
# endif
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service86Init()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Service86Init(void)
{
  Dcm_ExtService86Init();/* delegate to the extension */
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Module call-out implementations
---------------------------------------------- */
#define DCM_START_SEC_CALLOUT_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferDataPadding()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_PagedBufferDataPadding(Dcm_DiagDataContextPtrType pDataContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode)                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /* Check for remaining parts to be padded */
  Dcm_UtiMemSetUintX(Dcm_DiagGetDataContextBuffer(pDataContext), Dcm_MsgItemType, 0x00u, pDataContext->AvailLen);                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
  /* Signalize that all requested data are provided */
  Dcm_DiagCommitData(pDataContext, pDataContext->AvailLen);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  /* Enforce transmission of the current part */
  return DCM_E_BUFFERTOOLOW;
}
#endif
/**********************************************************************************************************************
 *  Dcm_RepeaterDeadEnd()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_RepeaterDeadEnd(Dcm_OpStatusType opStatus
                                                  ,Dcm_MsgContextPtrType pMsgContext                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                  ,Dcm_NegativeResponseCodePtrType ErrorCode)                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return DCM_E_STOP_REPEATER;
}
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_DID_F186_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgr_F186_ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_DidMgr_F186_ReadData(P2VAR(uint8, AUTOMATIC, DCM_VAR_NOINIT) Data)
{
  return Dcm_GetSesCtrlType(Data);
}
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service01Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdReturn = DCM_E_OK;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_InstanceContext.Repeater.Contexts.Context.Svc01.ParserDesc.GetMaskFunc = Dcm_Svc01GetAvailabilityMask;
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc01.ParserDesc.ParseFlags  = DCM_OBDIDMGR_PFLAG_NONE;

  *ErrorCode = Dcm_ObdIdMgrParseReqAndPrepRes(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc01.ParserDesc, pMsgContext);                         /* SBSW_DCM_PARAM_PTR_WRITE */

  if(*ErrorCode == DCM_E_POSITIVERESPONSE)
  {
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc01.ParserDesc.IsAvailabilityId == FALSE)
    {
      Std_ReturnType lStdResult;
      Dcm_ObdIdMgrListItemPtrType lIdList = Dcm_InstanceContext.Repeater.Contexts.Context.Svc01.ParserDesc.ParseResult;
      uint8_least pidIter = Dcm_InstanceContext.Repeater.Contexts.Context.Svc01.ParserDesc.ParseCount;

      do
      {
        --pidIter;
        /* compose response record */
        Dcm_DiagProvideResDataAsU8(pMsgContext, lIdList->Id);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdResult = Dcm_CfgSvc01ServiceInfoTable[lIdList->Result.Handle].OpFunc(Dcm_DiagGetResData(pMsgContext));                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
        if(lStdResult != DCM_E_OK)
        {
          *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdReturn = DCM_E_NOT_OK;
          break;
        }/* else - already set to positive response */

        Dcm_DiagProvideResData(pMsgContext, Dcm_CfgSvc01ServiceInfoTable[lIdList->Result.Handle].Length); /* data size */                            /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_UtiNextItemByPtr(lIdList, 1u);/* next item */
      }
      while(pidIter != 0u);

    }/* else - already copied data */
  }
  else
  {
    lStdReturn = DCM_E_NOT_OK;
  }

  return lStdReturn;
}
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service02Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdReturn = DCM_E_NOT_OK;
  *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* At maximum 3 PID + 3 FF can be requested */
  if( (pMsgContext->reqDataLen <= 6u)
    &&(pMsgContext->reqDataLen >  0u) /* at least one byte (actually 2, but the even number check covers that) */
    &&((pMsgContext->reqDataLen & 0x01u) == 0) )/* request length must be an even number */
  {
    Dcm_ObdIdMgrHandleOptType pidIter = (Dcm_ObdIdMgrHandleOptType)pMsgContext->reqDataLen;
    uint8_least pidTypeMask = 0x00u;
    uint8 pidList[6];
    uint8 freezeFrameId;
    uint8 pid;
    uint8 processedPids = 0u;

    /* Store the requested data */
    Dcm_DiagConsumeReqDataAsUN(pMsgContext, pidList,  6u, pMsgContext->reqDataLen);                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */

    do
    {
      /* OBD specification does not specify the order of PIDs in the response, thus it is ok to scan the requested PIDs backwards */
      --pidIter;      /* navigate to the FF */
      freezeFrameId = pidList[pidIter];
      --pidIter;      /* navigate to the PID */
      pid = pidList[pidIter];

      pidTypeMask |= (uint8)(Dcm_ObdIdMgrIsAvailabilityId(pid)?0x01u:0x02u);  /* mark availability/DATA PID found (never matter whether it is supported or not!) */

      if(pidTypeMask != 0x03u)
      {
        uint32 maskValue;
        sint16_least lLookUpResult = Dcm_ObdIdMgrGetAvailabilityMask(pid, Dcm_CfgSvc02LookUpTable, Dcm_CfgSvc02ExecPrecondTable, Dcm_CfgSvc02SupportedIdMask, &maskValue);

        if( (lLookUpResult >= 0)    /* check if PID is supported */
          &&(freezeFrameId == 0x00u) ) /* Accept only FF = 0 */
        {
          processedPids += Dcm_Svc02ReadPidData(pid, pMsgContext, maskValue);
        }/* else:
          - FreezeFrame != 0 --> ignore
          - PID not supported --> ignore */
      }
      else
      {
        /* PID mixing --> ignore */
        break;
      }
    }
    while(pidIter != 0u);

    /* At least one processed PID */
    if(processedPids != 0u)
    {
      /* PIDs of one type detected */
      if(pidTypeMask != 0x03u)
      {
        *ErrorCode = DCM_E_POSITIVERESPONSE;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdReturn = DCM_E_OK;
      }/* else - ErrorCode is already set */
    }/* else - ErrorCode is already set */
  }/* else - ErrorCode is already set */

  return lStdReturn;
}
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service03Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType  lStdResult;

  Dcm_ObdDtcManagerContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc03.ReadDtcContext;
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
  if(opStatus == DCM_INITIAL)
  {
    pRepContext->DemClientId = Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol());
  }
# endif

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_ObdDtcMgrDemSetDTCFilter(DCM_DTC_BIT_CONF_DTC, DEM_DTC_ORIGIN_PRIMARY_MEMORY, pMsgContext, ErrorCode, pRepContext);
    Dcm_RepeaterNextStep(DCM_SVC03_PROGRESS_READDTCBYSTATUSMASK);
    break;
  case DCM_SVC03_PROGRESS_READDTCBYSTATUSMASK:
    lStdResult = Dcm_ObdDtcMgrReadDtcByStatusMask(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  default:
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service03Updater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service03Updater(Dcm_DiagDataContextPtrType pDataContext
                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  return Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(pDataContext, ErrorCode, &Dcm_InstanceContext.Repeater.Contexts.Context.Svc03.ReadDtcContext);
}
# endif
#endif /* (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service04Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service04Processor(Dcm_OpStatusType                opStatus
                                                             ,Dcm_MsgContextPtrType           pMsgContext                                            /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lStdResult;
  Dcm_Svc04RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc04;

# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
  if(opStatus == DCM_INITIAL)
  {
    pRepContext->DemClientId = Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol());
  }
# endif

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc04Handler(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  case DCM_SVC04_PROGRESS_REPEATERPROXY_SELECT_DTC:
    lStdResult = Dcm_Svc04_XX_RepeaterProxy_SelectDTC(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# endif
  case DCM_SVC04_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc04_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_Service06Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service06Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8 lObdMid = pMsgContext->reqData[0];

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if ((pMsgContext->reqDataLen > 0u)         /* At least one ID must be there */
    && (pMsgContext->reqDataLen <= 6u))      /* Up to 6 IDs possible */
  {
    /* #10 If request length is valid  */
    if (Dcm_ObdIdMgrIsAvailabilityId(lObdMid))
    {
      /* #20 If first MID in request is a availabilty MID */
      /* #30 Process availability MID request */
      lStdResult = Dcm_Service06Process_SupportedMid(pMsgContext, ErrorCode);
    }
    else if (pMsgContext->reqDataLen == 1u)
    {
      /* #40 Otherwise if request length is equal 1 (Not allowed to request multiple data MIDs) */
      /* #50 Process single data MID request */
      lStdResult = Dcm_Service06Process_SingleMid(pMsgContext, ErrorCode);
    }
    else
    {
      /* #60 Otherwise return NRC DCM_E_REQUESTOUTOFRANGE */
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;
      lStdResult=DCM_E_NOT_OK;
    }
  }
  else
  {
    /* #70 Otherwise return NRC DCM_E_REQUESTOUTOFRANGE */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_Service06Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service06Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_InstanceContext.Repeater.Contexts.Context.Svc06.ParserDesc.GetMaskFunc = Dcm_Svc06GetAvailabilityMask;
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc06.ParserDesc.ParseFlags  = DCM_OBDIDMGR_PFLAG_SINGLEDATAID;

  *ErrorCode = Dcm_ObdIdMgrParseReqAndPrepRes(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc06.ParserDesc, pMsgContext);                         /* SBSW_DCM_PARAM_PTR_WRITE */

  if((*ErrorCode == DCM_E_POSITIVERESPONSE)
    &&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc06.ParserDesc.IsAvailabilityId == FALSE) )
  {
    uint16             lTestValue;
    uint16             lMinLimit;
    uint16             lMaxLimit;
    Dcm_DTRStatusType  lStatus;

    /* data MID -> only one possible */

    Dcm_ObdIdMgrListItemPtrType  lIdList = Dcm_InstanceContext.Repeater.Contexts.Context.Svc06.ParserDesc.ParseResult;
    P2CONST(Dcm_CfgSvc06MidTidInfoType, AUTOMATIC, DCM_CONST) tidObject = &Dcm_CfgSvc06MidTidInfoTable[Dcm_CfgSvc06Mid2TidRefMap[lIdList->Result.Handle]];
    Dcm_CfgSvc06Mid2TidRefOptType numTids = (Dcm_CfgSvc06Mid2TidRefOptType)( Dcm_CfgSvc06Mid2TidRefMap[lIdList->Result.Handle + 1]
                                                                           - Dcm_CfgSvc06Mid2TidRefMap[lIdList->Result.Handle + 0]);

    for(; numTids != 0; --numTids)
    {
      if(tidObject->OpFunc(opStatus, &lTestValue, &lMinLimit, &lMaxLimit, &lStatus) == DCM_E_OK)
      {
        if(lStatus == DCM_DTRSTATUS_INVISIBLE)
        {
          lTestValue = 0;
          lMinLimit  = 0;
          lMaxLimit  = 0;
        }

        /* Copy data */
        Dcm_DiagProvideResDataAsU8(pMsgContext, lIdList->Id);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_DiagProvideResDataAsU8(pMsgContext, tidObject->Tid);                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_DiagProvideResDataAsU8(pMsgContext, tidObject->Uasid);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_DiagProvideResDataAsU16(pMsgContext, lTestValue);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DiagProvideResDataAsU16(pMsgContext, lMinLimit);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DiagProvideResDataAsU16(pMsgContext, lMaxLimit);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_UtiNextItemByPtr(tidObject,1u);/* next MIDTID object */
      }
      else
      {
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        break;
      }
    }
  }
  else
  {
    lStdResult = DCM_E_NOT_OK; /* ErrorCode already set */
  }

  return lStdResult;
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service07Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service07Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType  lStdResult;

  Dcm_ObdDtcManagerContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc07.ReadDtcContext;
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
  if(opStatus == DCM_INITIAL)
  {
    pRepContext->DemClientId = Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol());
  }
# endif

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_ObdDtcMgrDemSetDTCFilter(DCM_DTC_BIT_PNDG_DTC, DEM_DTC_ORIGIN_PRIMARY_MEMORY, pMsgContext, ErrorCode, pRepContext);
    Dcm_RepeaterNextStep(DCM_SVC07_PROGRESS_READDTCBYSTATUSMASK);
    break;
  case DCM_SVC07_PROGRESS_READDTCBYSTATUSMASK:
    lStdResult = Dcm_ObdDtcMgrReadDtcByStatusMask(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service07Updater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service07Updater(Dcm_DiagDataContextPtrType pDataContext
                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  return Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(pDataContext, ErrorCode, &Dcm_InstanceContext.Repeater.Contexts.Context.Svc07.ReadDtcContext);
}
# endif
#endif /* (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service08Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service08Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  Dcm_MsgLenType lNumObdIds = pMsgContext->reqDataLen;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_InstanceContext.Repeater.Contexts.Context.Svc08.ParserDesc.GetMaskFunc = Dcm_Svc08GetAvailabilityMask;
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc08.ParserDesc.ParseFlags  = (Dcm_ObdIdMgrParserFlagsType)(DCM_OBDIDMGR_PFLAG_SINGLEDATAID|DCM_OBDIDMGR_PFLAG_REQHASDATA);

  *ErrorCode = Dcm_ObdIdMgrParseReqAndPrepRes(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc08.ParserDesc, pMsgContext);                         /* SBSW_DCM_PARAM_PTR_WRITE */

  if(*ErrorCode == DCM_E_POSITIVERESPONSE)
  {
  if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc08.ParserDesc.IsAvailabilityId == FALSE)
    {
      CONSTP2CONST(Dcm_CfgSvc08ServiceInfoType, AUTOMATIC, DCM_CONST) tidInfoEntry = &Dcm_CfgSvc08ServiceInfoTable[Dcm_InstanceContext.Repeater.Contexts.Context.Svc08.ParserDesc.ParseResult[0].Result.Handle];
      /* data TID -> only one possible */
      if(tidInfoEntry->ReqDataLen == lNumObdIds)
      {
        if (tidInfoEntry->OpFunc(Dcm_DiagGetResDataRel(pMsgContext, 1), Dcm_DiagGetReqData(pMsgContext)) != DCM_E_OK)/* execute operation */
        {
          *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
        else
        {
          Dcm_DiagProvideResData(pMsgContext, tidInfoEntry->ResDataLen);/* prepare for positive response with specific length + TID length */        /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }
      else
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE; /* request is with invalid length - use NRC 0x31 to reject/suppress response */                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }/* else - already copied data */
  }
  else
  {
    lStdResult = DCM_E_NOT_OK; /* ErrorCode already set */
  }

  return lStdResult;
}
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service09Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service09Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lStdResult;

  Dcm_Svc09RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc09;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc09Handler(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  case DCM_SVC09_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc09_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service0AProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service0AProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType  lStdResult;

  Dcm_ObdDtcManagerContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc0A.ReadDtcContext;
# if (DCM_DEM_CLIENTID_ENABLED == STD_ON)
  if(opStatus == DCM_INITIAL)
  {
    pRepContext->DemClientId = Dcm_NetGetDemClientId(Dcm_NetGetProtIdOfActiveProtocol());
  }
# endif

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_ObdDtcMgrDemSetDTCFilter(DCM_DTC_BIT_DONT_CARE, DEM_DTC_ORIGIN_PERMANENT_MEMORY, pMsgContext, ErrorCode, pRepContext);
    Dcm_RepeaterNextStep(DCM_SVC0A_PROGRESS_READDTCBYSTATUSMASK);
    break;
  case DCM_SVC0A_PROGRESS_READDTCBYSTATUSMASK:
    lStdResult = Dcm_ObdDtcMgrReadDtcByStatusMask(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service0AUpdater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service0AUpdater(Dcm_DiagDataContextPtrType pDataContext
                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  return Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(pDataContext, ErrorCode, &Dcm_InstanceContext.Repeater.Contexts.Context.Svc0A.ReadDtcContext);
}
# endif
#endif /* (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Service10Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service10Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc10RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc10;

  switch(Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc10Handler(opStatus, pMsgContext, ErrorCode , pRepContext);                                                                   /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
  case DCM_SVC10_PROGRESS_WAIT_RESET_ACK:
    lStdResult = Dcm_Svc10_WaitForResetAck(opStatus, pMsgContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
#  if (DCM_DIAG_RCRRP_ON_BOOT_ENABLED == STD_ON)
  case DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK:
    lStdResult = Dcm_Svc10_WaitForRcrRpAck(opStatus, pMsgContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
#  endif
  case DCM_SVC10_PROGRESS_SET_PRGCOND:
    lStdResult = Dcm_Svc10_SetProgConditions(opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service10FastPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service10FastPostProcessor(Dcm_ConfirmationStatusType status)
{
  if(status == DCM_RES_POS_OK)
  {
    Dcm_DiagSetP2Timings(Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.SesStateIdx
                        ,Dcm_NetGetProtIdOfActiveProtocol());

# if (DCM_SVC_10_RESET_AFTER_RESPONSE == STD_ON)
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ResetMode != DCM_MODEMGR_ARENV_MODE_ECURESET_NONE)
    {
      Dcm_SingletonContext.Network.RxAllowed = FALSE; /* lock any further communication while the ECU is getting reset */
    }
# endif
  }
}

/**********************************************************************************************************************
 *  Dcm_Service10PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service10PostProcessor(Dcm_ConfirmationStatusType status)
{
  if(status == DCM_RES_POS_OK)
  {
    /* execute transition */
    Dcm_StateSetSession(Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.SesStateIdx);
# if (DCM_SVC_10_RESET_AFTER_RESPONSE == STD_ON)
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ResetMode != DCM_MODEMGR_ARENV_MODE_ECURESET_NONE)
    {
      /* fire and forget - if failed - no chance to send any NRC from here */
      (void)Dcm_ModeMgrArEnvSwitchReqEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_EXECUTE);
    }
# endif
  }
  else
  {
    /* on the way of changing a session */
    if(0 == ( Dcm_SingletonContext.StateMgr.Preconditions.Session
            & Dcm_SingletonContext.StateMgr.PendingSession) )
    {
      /* undo pending session expectation */
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
      Dcm_UtiArEnvEnterCriticalSection();/* avoid interrupt from the Dcm_NetTaskRx || Dcm_NetStartOfReception() */                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */
# else
      Dcm_SplitTaskEnterCS();/* avoid interrupt from the Dcm_NetTaskRx */                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
# endif
      /*=================================*
        BEGIN CRITICAL SECTION
       *=================================*/
      Dcm_StateSyncPendingSession();/* synchronize with the currently active session */
      /*=================================*
        END CRITICAL SECTION
       *=================================*/
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
      Dcm_UtiArEnvLeaveCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
# else
      Dcm_SplitTaskLeaveCS();                                                                                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
# endif
    }/* else - nothing to undo */
  }
}
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc11RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc11;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc11Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC11_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc11SubFuncHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
  case DCM_SVC11_PROGRESS_ECURST_WAITFORACK:
    lStdResult = Dcm_Svc11_EcuRst_WaitForAck(opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
  case DCM_SVC11_RAPPWRDWN_WAITFORACK:
    lStdResult = Dcm_Svc11_RapPwrDwn_WaitForAck(opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service11PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service11PostProcessor(Dcm_ConfirmationStatusType status)
{
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
  if(status == DCM_RES_POS_OK)
  {
#  if (DCM_SVC_11_ECURESET_EXEC_FILTER_ENABLED == STD_ON)
    if( (Dcm_InstanceContext.Repeater.Contexts.Context.Svc11.SubFuncId > 0x00u)
      &&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc11.SubFuncId < 0x04u) )
#  endif
    {
      /* reset only on 0x01 (hard), 0x02 (soft), 0x03 (keyOnOff) */
      (void)Dcm_ModeMgrArEnvSwitchReqEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_EXECUTE);
    }
  }
# endif
}

/**********************************************************************************************************************
 *  Dcm_Service11FastPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service11FastPostProcessor(Dcm_ConfirmationStatusType status)
{
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
  if(status == DCM_RES_POS_OK)
  {
#  if (DCM_SVC_11_ECURESET_EXEC_FILTER_ENABLED == STD_ON)
    if( (Dcm_InstanceContext.Repeater.Contexts.Context.Svc11.SubFuncId > 0x00u)
      &&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc11.SubFuncId < 0x04u) )
#  endif
    {
      Dcm_SingletonContext.Network.RxAllowed = FALSE;
    }
  }
# endif
}
# if (DCM_SVC_11_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_01Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /* Delegate job to the concrete mode manager */
  return Dcm_Svc11_ProcessEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_HARD, ErrorCode);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
# if (DCM_SVC_11_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_02Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Delegate job to the concrete mode manager */
  return Dcm_Svc11_ProcessEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_KEYONOFF, ErrorCode);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
# if (DCM_SVC_11_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_03Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Delegate job to the concrete mode manager */
  return Dcm_Svc11_ProcessEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_SOFT, ErrorCode);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
# if (DCM_SVC_11_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_04Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_04Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Prepare for a positive response */
  Dcm_DiagProvideResDataAsU8(pMsgContext, DCM_SVC_11_POWERDOWNTIME);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Delegate job to the concrete mode manager */
  return Dcm_Svc11_ProcessRapPwrDwn(DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_ENABLE, ErrorCode);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
# if (DCM_SVC_11_05_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_05Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_05Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Delegate job to the concrete mode manager */
  return Dcm_Svc11_ProcessRapPwrDwn(DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_DISABLE, ErrorCode);                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service14Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service14Processor(Dcm_OpStatusType                opStatus
                                                             ,Dcm_MsgContextPtrType           pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc14RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc14;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc14Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  case DCM_SVC14_PROGRESS_REPEATERPROXY_SELECT_DTC:
    lStdResult = Dcm_Svc14_XX_RepeaterProxySelectDTC(opStatus, pMsgContext, ErrorCode, pRepContext);                                                 /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC14_PROGRESS_REPEATERPROXY_CHECK_SELECTION_RESULT:
    lStdResult = Dcm_Svc14_XX_RepeaterProxyCheckSelectionResult(opStatus, pMsgContext, ErrorCode, pRepContext);                                      /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
  case DCM_SVC14_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc14_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19Processor(Dcm_OpStatusType                opStatus
                                                             ,Dcm_MsgContextPtrType           pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc19Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC19_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc19SubFuncHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# if (DCM_SVC_19_COPY_LINEAR_DATA_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_UTI_COPYLINEARDATA:
    lStdResult = Dcm_Svc19UtiCpyLinearData(opStatus, pMsgContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_DEM_API_SELECT_DTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_SELECT_DTC:
    lStdResult = Dcm_Svc19UtiDemSelectDTC(opStatus, pMsgContext, ErrorCode, pRepContext);                                                            /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_DISABLERECORDUPDATE:
    lStdResult = Dcm_Svc19UtiDemDisableRecordUpdate(opStatus, pMsgContext, ErrorCode, pRepContext);                                                  /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETSTATUSOFDTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETSTATUSOFDTC:
    lStdResult = Dcm_Svc19UtiDemGetStatusOfDtc(opStatus, pMsgContext, ErrorCode, pRepContext);                                                       /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_DEM_API_SELECT_FFR_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_SELECTFFREC:
    lStdResult = Dcm_Svc19UtiDemSelectFFData(pRepContext);                                                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETSIZEOFFFRECORD_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFFFREC:
    lStdResult = Dcm_Svc19UtiDemGetSizeOfFFRecord(opStatus, pMsgContext, ErrorCode, pRepContext);                                                    /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_DEM_API_SELECT_EDR_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_SELECTEXTDATAREC:
    lStdResult = Dcm_Svc19UtiDemSelectExtRecord(opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETSIZEOFEXTRECORD_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETSIZEOFEXTDATAREC:
    lStdResult = Dcm_Svc19UtiDemGetSizeOfExtRecord(opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETNUMFILTEREDDTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETNUMFLTRDDTC:
    lStdResult = Dcm_Svc19UtiDemGetNumFltrdDtc(opStatus, pMsgContext, ErrorCode, pRepContext);                                                       /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDSEVERITY:
    lStdResult = Dcm_Svc19UtiDemGetNxtFltrdSeverity(opStatus, pMsgContext, ErrorCode, pRepContext);                                                  /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETSEVERITYOFDTC:
    lStdResult = Dcm_Svc19UtiDemGetSeverityOfDtc(opStatus, pMsgContext, ErrorCode, pRepContext);                                                     /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETFUNCUNITOFDTC:
    lStdResult = Dcm_Svc19UtiDemGetFuncUnitOfDtc(opStatus, pMsgContext, ErrorCode, pRepContext);                                                     /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDDTC:
    lStdResult = Dcm_Svc19UtiDemGetNxtFltrdDtc(opStatus, pMsgContext, ErrorCode, pRepContext);                                                       /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_PUTNUMFLTRDDTC:
    lStdResult = Dcm_Svc19UtiPutNumFilteredDtc(opStatus, pMsgContext, ErrorCode, pRepContext);                                                       /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_GETNEXTFLTRDFDC:
    lStdResult = Dcm_Svc19UtiDemGetNxtFltrdFDC(opStatus, pMsgContext, ErrorCode, pRepContext);                                                       /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_DEMCHAIN_WWHOBD_GETNEXTFLTRDSEVERITY:
    lStdResult = Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity(opStatus, pMsgContext, ErrorCode, pRepContext);                                            /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_19_CHAIN_END_ENABLED == STD_ON)
  case DCM_SVC19_PROGRESS_CHAIN_END:
    lStdResult = DCM_E_OK;
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_Service19PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service19PostProcessor(Dcm_ConfirmationStatusType status)
{
# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
#  endif
# endif

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  (void)Dcm_DemAPI(EnableDTCRecordUpdate)(pRepContext->DemClientId);
#  else
  (void)Dcm_DemAPI(EnableDTCRecordUpdate)();
#  endif
# endif
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19Updater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19Updater(Dcm_DiagDataContextPtrType      pDataContext
                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  return Dcm_Service19UtiCopyData(pDataContext, ErrorCode, pRepContext);                                                                             /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif
# if (DCM_SVC_19_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_01Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  uint8 reqDtcStatusMask;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &reqDtcStatusMask);                                                                                        /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

  return Dcm_Svc19UtiReportNumDtcByStatusMaskData(DCM_SVC_19_DEM_SETFILTER_CLASS_01
                                                 ,reqDtcStatusMask
                                                 ,0
                                                 ,pMsgContext
                                                 ,ErrorCode
                                                 ,pRepContext);                                                                                      /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_02Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportDtcByStatusMaskData(DCM_SVC_19_DEM_SETFILTER_CLASS_01
                                              ,DCM_SVC_19_USE_MASK_REQ
                                              ,pMsgContext
                                              ,ErrorCode
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_03Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext                                         /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType             lStdResult;
  Dcm_DemReturnSetFilterType demResult;
  uint16                     numOfRecords;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  demResult = Dcm_DemAPI(SetFreezeFrameRecordFilter)(
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
      pRepContext->DemClientId,
#  endif
      DEM_DTC_FORMAT_UDS,
      &numOfRecords);                                                                                                                                /* SBSW_DCM_POINTER_FORWARD_STACK */
  if (demResult == DCM_DEM_RET_FILTER_ACCEPTED)
  {
    lStdResult =  Dcm_Sv19UtiStartReporting(DCM_SVC_19_UPDATE_GET_NXT_FLTRD_RECORD
                                           ,(Dcm_MsgLenType)(numOfRecords * 4)
                                           ,pRepContext);                                                                                            /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }
  else
  { /* Any DEM error */
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_DemApiNrcMapSetDTCFilter);                                                            /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_04Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_04Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext                                         /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)                                          /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportDtcFFRByDtc(DEM_DTC_ORIGIN_PRIMARY_MEMORY, pMsgContext, pRepContext);                                                     /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_05_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_05Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_05Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdReturn;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &(pRepContext->RecordNum));                                                                                /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

  if( (pRepContext->RecordNum == 0x00u)
    ||(pRepContext->RecordNum == DCM_SVC_19_RECNUM_ALL) )
  {
    uint16 recordLength;
    Dcm_MsgType freezeFrameDataBuffer;
    Dcm_DemReturnGetFreezeFrameDataByRecordType demResult;

    /* Report immediately the only possible SSRN (0x00) */
    Dcm_DiagProvideResDataAsU8(pMsgContext, 0x00u);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    /* Calculate remaining length for SSRN data provision by DEM
     * (i.e. subtract the DTC (3bytes) and status mask (1 Byte) from the current available response buffer, that will be written later)
     */
    recordLength = (uint16)Dcm_DiagGetRemainingResLenWithOffset(pMsgContext, 4u);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    freezeFrameDataBuffer = Dcm_DiagGetResDataRel(pMsgContext, 4);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

    pRepContext->Origin = DEM_DTC_ORIGIN_PRIMARY_MEMORY;                                                                                             /* SBSW_DCM_GLOBAL_PTR_WRITE */
    /* Gather the SSRN data (with offset of 4 bytes to the current position) and DTC number */
    demResult = Dcm_DemAPI_GetOBDFreezeFrameData(0x00u                                                                                               /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
                                                ,pRepContext->Origin
                                                ,&pRepContext->Dtc
                                                ,freezeFrameDataBuffer
                                                ,&recordLength);
    switch(demResult)
    {
    case DCM_DEM_RET_FFBYRECORD_OK:
      /* Commit the reported SSRN data */
      Dcm_DiagUpdateResLength(pMsgContext, recordLength);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
      /* Delegate the service processing to the "DTCAndStatusRecord" reporting utility (i.e. writes DTC and its status into the response) */
      lStdReturn = Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainGetDtcStatusEnd, pRepContext);                                                            /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
      break;
    case DCM_DEM_RET_FFBYRECORD_NO_DTC:
      /* Otherwise, if the DEM has found no matching DTC, just return the SSRN with no further data */
      lStdReturn = DCM_E_OK;
      break;
    default:
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(demResult, Dcm_Svc19NrcMapGetOBDFreezeFrameData);                                                  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
      break;
    }
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
# endif

# if (DCM_SVC_19_06_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_06Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_06Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportExtDataRecordByDtcNum(DEM_DTC_ORIGIN_PRIMARY_MEMORY
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_07_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_07Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_07Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  uint8 reqDtcStatusMask;
  uint8 reqDtcSeverityMask;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &reqDtcSeverityMask);                                                                                      /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &reqDtcStatusMask);                                                                                        /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

  return Dcm_Svc19UtiReportNumDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_02
                                                  ,reqDtcStatusMask
                                                  ,reqDtcSeverityMask
                                                  ,pMsgContext
                                                  ,ErrorCode
                                                  ,pRepContext);                                                                                     /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_08Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_08Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                    lStdResult;
  uint8                             dtcStatusMask;
  uint8                             dtcSeverityMask;
  uint8                             dtcSAM;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* save the requested masks */
  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &dtcSeverityMask);                                                                                         /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &dtcStatusMask);                                                                                           /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pRepContext->DemClientId
                                                       ,&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  if(lStdResult == E_OK)
  {
    Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter(&dtcStatusMask);                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /* Form the relevant status bits */
    dtcStatusMask &= dtcSAM;

    if(dtcStatusMask == 0u)
    {
      lStdResult = DCM_E_OK;/* no DTCs to report */
    }
    else
    {
      /* filter the DTCs */
      lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                              ,DCM_SVC_19_DEM_SETFILTER_CLASS_02
                                              ,dtcStatusMask
                                              ,dtcSeverityMask
                                              ,DCM_DEM_FILTER_FOR_FDC_NO
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
      if(lStdResult == DCM_E_OK)
      {
        lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19_08DemChain, pRepContext);                                                                      /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
      }
      else
      {
        /* Already set by Dcm_Svc19UtiDemSetDTCFilter */
      }
    }
  }
  else
  {
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_19_09_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_09Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_09Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  uint8 dtcSAM;

  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagConsumeReqDataAsU24(pMsgContext, &(pRepContext->Dtc));                                                                                     /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

  /* Gather the configured DEM SAM */
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pRepContext->DemClientId
                                                       ,&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(&dtcSAM);                                                                                    /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

  if(lStdResult == E_OK)
  {
    Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    pRepContext->Origin = DEM_DTC_ORIGIN_PRIMARY_MEMORY;                                                                                             /* SBSW_DCM_GLOBAL_PTR_WRITE */
    lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19_09DemChain, pRepContext);                                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }
  else
  {
    /* Otherwise, exit service processing with an appropriate NRC corresponding to the DEM operation error  */
    *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                           /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_0A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0AProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0AProcessor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_01
                                               ,DCM_SVC_19_USE_MASK_ALL
                                               ,pMsgContext
                                               ,ErrorCode
                                               ,pRepContext);                                                                                        /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_0B_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0BProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0BProcessor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(DEM_FIRST_FAILED_DTC
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_0C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0CProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0CProcessor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(DEM_FIRST_DET_CONFIRMED_DTC
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_0D_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0DProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0DProcessor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(DEM_MOST_RECENT_FAILED_DTC
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_0E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0EProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0EProcessor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(DEM_MOST_REC_DET_CONFIRMED_DTC
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_0F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0FProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0FProcessor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_03
                                               ,DCM_SVC_19_USE_MASK_REQ
                                               ,pMsgContext
                                               ,ErrorCode
                                               ,pRepContext);                                                                                        /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_10_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_10Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_10Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportExtDataRecordByDtcNum(DEM_DTC_ORIGIN_MIRROR_MEMORY
                                                ,pMsgContext
                                                ,ErrorCode
                                                ,pRepContext);                                                                                       /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_11_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_11Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_11Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  uint8 reqDtcStatusMask;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &reqDtcStatusMask);                                                                                        /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

  return Dcm_Svc19UtiReportNumDtcByStatusMaskData(DCM_SVC_19_DEM_SETFILTER_CLASS_03
                                                 ,reqDtcStatusMask
                                                 ,0
                                                 ,pMsgContext
                                                 ,ErrorCode
                                                 ,pRepContext);                                                                                      /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif
# if (DCM_SVC_19_12_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_12Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_12Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  uint8 reqDtcStatusMask;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &reqDtcStatusMask);                                                                                        /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

  return Dcm_Svc19UtiReportNumDtcByStatusMaskData(DCM_SVC_19_DEM_SETFILTER_CLASS_04
                                                 ,reqDtcStatusMask
                                                 ,0
                                                 ,pMsgContext
                                                 ,ErrorCode
                                                 ,pRepContext);                                                                                      /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_13_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_13Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_13Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportDtcByStatusMaskData(DCM_SVC_19_DEM_SETFILTER_CLASS_04
                                              ,DCM_SVC_19_USE_MASK_REQ
                                              ,pMsgContext
                                              ,ErrorCode
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif
# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_14Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_14Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext                                         /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType           lStdResult;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                          ,DCM_SVC_19_DEM_SETFILTER_CLASS_01
                                          ,0x00u
                                          ,0u /* not used */
                                          ,DCM_DEM_FILTER_FOR_FDC_YES
                                          ,pRepContext);                                                                                             /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
  if(lStdResult == DCM_E_OK)
  {
    lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19_14DemChain, pRepContext);                                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }
  else
  {
    /* Already set by Dcm_Svc19UtiDemSetDTCFilter */
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_15_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_15Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_15Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportDtcByStatusMaskData(DCM_SVC_19_DEM_SETFILTER_CLASS_05
                                              ,DCM_SVC_19_USE_MASK_ALL
                                              ,pMsgContext
                                              ,ErrorCode
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
}
# endif

# if (DCM_SVC_19_17_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_17Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_17Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext;
  uint8 lUserMemId;

  lUserMemId = Dcm_DiagGetReqDataAsU8Rel(pMsgContext, 1);
  pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_SVC_19_USER_MEM_ID_CHECK_ENABLED == STD_ON)
  if(lUserMemId != DCM_SVC_19_USER_MEM_ID)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
#  endif
  {
    Dcm_DiagBufferIndexType resUserMemIdx = pMsgContext->resIndex;

    /* Set the UserMid in response now */
    Dcm_DiagProvideResData(pMsgContext, 1);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_Svc19UtiReportDtcByStatusMaskData(DCM_SVC_19_DEM_SETFILTER_CLASS_06
                                                      ,DCM_SVC_19_USE_MASK_REQ
                                                      ,pMsgContext
                                                      ,ErrorCode
                                                      ,pRepContext);                                                                                 /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    /* place the UserMid to the response */
    Dcm_DiagSetResDataAsU8At(pMsgContext, resUserMemIdx, lUserMemId);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_18_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_18Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_18Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)                                          /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType lStdResult;
  uint8 lUserMemId;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext;

  pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  lUserMemId = Dcm_DiagGetReqDataAsU8Rel(pMsgContext, 4);

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_SVC_19_USER_MEM_ID_CHECK_ENABLED == STD_ON)
  if (lUserMemId != DCM_SVC_19_USER_MEM_ID)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
#  endif
  {
    /* save UserMid response location */
    Dcm_DiagBufferIndexType resUserMemIdx = pMsgContext->resIndex;
    /* Set the UserMid in response now */
    Dcm_DiagProvideResData(pMsgContext, 1);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_Svc19UtiReportDtcFFRByDtc(DEM_DTC_ORIGIN_SECONDARY_MEMORY
                                              ,pMsgContext
                                              ,pRepContext);                                                                                         /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    /* place the UserMid to the response */
    Dcm_DiagSetResDataAsU8At(pMsgContext, resUserMemIdx, lUserMemId);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_19Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_19Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  uint8 lUserMemId;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext;

  pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;
  lUserMemId = Dcm_DiagGetReqDataAsU8Rel(pMsgContext, 4);

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_SVC_19_USER_MEM_ID_CHECK_ENABLED == STD_ON)
  if (lUserMemId != DCM_SVC_19_USER_MEM_ID)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
#  endif
  {
    /* save UserMid response location */
    Dcm_DiagBufferIndexType resUserMemIdx = pMsgContext->resIndex;
    /* skip the UserMid in response now */
    Dcm_DiagProvideResData(pMsgContext, 1);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_Svc19UtiReportExtDataRecordByDtcNum(DEM_DTC_ORIGIN_SECONDARY_MEMORY
                                                        ,pMsgContext
                                                        ,ErrorCode
                                                        ,pRepContext);                                                                               /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    /* place the UserMid to the response */
    Dcm_DiagSetResDataAsU8At(pMsgContext, resUserMemIdx, lUserMemId);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_42Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_42Processor(Dcm_OpStatusType                opStatus
                                                                ,Dcm_MsgContextPtrType           pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lStdResult;
  uint8                         dtcStatusMask;
  uint8                         dtcSeverityMask;
  uint8                         functionalId;
  uint8                         dtcSAM;
  uint8                         dtcSevAM;
  Dcm_Svc19RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc19;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  Dcm_DiagConsumeReqDataAsU8(pMsgContext, &functionalId);                                                                                            /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

  if (functionalId == 0x33u)
  {
    Dcm_DiagConsumeReqDataAsU8(pMsgContext, &dtcStatusMask);                                                                                         /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    Dcm_DiagConsumeReqDataAsU8(pMsgContext, &dtcSeverityMask);                                                                                       /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

    /* Echo the requested functional group (do it here, otherwise the above extracted data could be overwritten in case of shared Rx-Tx-Buffers) */
    Dcm_DiagProvideResDataAsU8(pMsgContext, functionalId);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Gather the configured DEM SAM */
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
    lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pRepContext->DemClientId
                                                         ,&dtcSAM);                                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
    lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(&dtcSAM);                                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

    if(lStdResult == E_OK)
    {
      /* Report configured DEM SAM */
      Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSAM);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

#  if (DCM_DEM_API_430_ENABLED == STD_ON)
      lStdResult = Dcm_DemAPI(GetDTCSeverityAvailabilityMask)(pRepContext->DemClientId
                                                             ,&dtcSevAM);                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
#  else
      lStdResult = Dcm_DemAPI(GetDTCSeverityAvailabilityMask)(&dtcSevAM);                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif

      if(lStdResult == E_OK)
      {
        Dcm_DiagProvideResDataAsU8(pMsgContext, dtcSevAM);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
        /* Report the configured in DEM DTC format identifier */
#  if (DCM_DEM_API_430_ENABLED == STD_ON)
        Dcm_DiagProvideResDataAsU8(pMsgContext, Dcm_DemAPI(GetTranslationType)(pRepContext->DemClientId));                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
#  else
        Dcm_DiagProvideResDataAsU8(pMsgContext, Dcm_DemAPI(GetTranslationType)());                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
#  endif

        Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter(&dtcStatusMask);                                                                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */

        /* Form the relevant status bits */
        dtcStatusMask &= dtcSAM;

        if(dtcStatusMask == 0u)
        {
          lStdResult = DCM_E_OK;/* no DTCs to report */
        }
        else
        {
          /* filter the DTCs */
          lStdResult = Dcm_Svc19UtiDemSetDTCFilter(ErrorCode
                                                  ,DCM_SVC_19_DEM_SETFILTER_CLASS_07
                                                  ,dtcStatusMask
                                                  ,dtcSeverityMask
                                                  ,DCM_DEM_FILTER_FOR_FDC_NO
                                                  ,pRepContext);                                                                                     /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */

          if(lStdResult == DCM_E_OK)
          {
            lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19_42DemChain, pRepContext);                                                                  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
          }
          else
          {
            /* Already set by Dcm_Svc19UtiDemSetDTCFilter */
          }
        }
      }
      else
      {
        *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                       /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
    else
    {
      *ErrorCode = Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType);                                                         /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }
  else
  {
    /* Invalid functional group */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service22Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service22Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext                                                      /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lStdResult;

  Dcm_Svc22RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc22;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc22Handler(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  case DCM_SVC22_PROGRESS_DIDLOOKUP:
    lStdResult = Dcm_Svc22DidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
  case DCM_SVC22_PROGRESS_CHECKCONDITION:
    lStdResult = Dcm_Svc22CheckCondition(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# endif
  case DCM_SVC22_PROGRESS_GETLENGTH:
    lStdResult = Dcm_Svc22GetLength(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
  case DCM_SVC22_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc22CheckAccess(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# endif
  case DCM_SVC22_PROGRESS_READDATA:
    lStdResult = Dcm_Svc22ReadData(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE XX */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service22Updater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service22Updater(Dcm_DiagDataContextPtrType      pDataContext
                                                           ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lResult;

  Dcm_Svc22RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc22;

  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT

  /*
   *  Action/Return value | DCM_E_PENDING | DCM_E_BUFFERTOOLOW | DCM_E_OK
   * ---------------------+---------------+--------------------+----------
   *  call again          |      yes      |        yes         |   no
   *  data committed      |      no       |        yes         |   yes
   *  ready               |      no       |        no          |   yes
   */

  /* #10 For each requested DID */
  do
  {
    lResult = DCM_E_OK;

    if(pRepContext->OpStatus == DCM_INITIAL)
    {
      /* #30 Prepare for reading */
      lResult = Dcm_Svc22CopyPagedDataInit(pDataContext, pRepContext);
    }

    if(lResult == DCM_E_OK)
    {
      lResult = Dcm_Svc22ReadDidPaged(pDataContext, ErrorCode, pRepContext);

      /* #40 If all DIDs were read without any errors: */
      if(lResult == DCM_E_OK)
      {
        --pRepContext->NumDids;
        if(pRepContext->NumDids == 0)
        {
          /* #50 Finalize reading */
          break; /* return DCM_E_OK */
        }

        /* #60 Otherwise take next DID */
        Dcm_UtiNextItemByPtr(pRepContext->DidInfoContextPtr, 1u);

        DCM_UTIRTLMTR_CTR_NEXT
        DCM_UTIRTLMTR_CTR_HANDLE_NO_BREAK(lResult, DCM_E_PENDING)
      }
    }
  }
  while(lResult == DCM_E_OK);

  return lResult;
}
# endif /* (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) */

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service22Cancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service22Cancel(void)
{
  /* #10 If any read operation has to be canceled: */
  if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.OpStatus != DCM_INITIAL)
  {
    Dcm_MsgItemType               lData = 0u;
    Dcm_DiagDataContextType       lDataContext;
    Dcm_NegativeResponseCodeType  lNrc;

    Dcm_DiagInitDataContext(&lDataContext, &lData, 0u);

    /* #20 Notify the application about the cancellation */
    (void)Dcm_DidMgrReadDid(DCM_CANCEL
                           ,&lDataContext
                           ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr
                           ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidOpTypeContext)
                           ,&lNrc);
  }

#  if (DCM_DIDMGR_CANCEL_OP_ENABLED == STD_ON)
  /* #30 Cancel the ongoing DID operation */
  Dcm_DidMgrCancelOperation();
#  endif
}
# endif /* (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) */
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service23Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service23Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc23RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc23;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc23Handler(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  case DCM_SVC23_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc23CheckAccess(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# endif
  case DCM_SVC23_PROGRESS_READMEMORY:
    lStdResult = Dcm_Svc23ReadMemory(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service24Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service24Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext                                                      /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc24RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc24;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc24Handler(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  case DCM_SVC24_PROGRESS_DIDLOOKUP:
    lStdResult = Dcm_Svc24DidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  case DCM_SVC24_PROGRESS_EXECUTEOP:
    lStdResult = Dcm_Svc24ExecuteOp(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service27Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc27RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc27;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc27Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC27_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc27SubFuncHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# if (DCM_SVC_27_SUBFUNC_SUPPORT_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
  case DCM_SVC27_PROGRESS_SETATTEMPTCNTR:
    lStdResult = Dcm_Service27SetAttemptCntrRepeater(opStatus, pMsgContext, ErrorCode, pRepContext);                                                 /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_27_SUBFUNC_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC27_PROGRESS_SEEDREPEATER:
    lStdResult = Dcm_Service27SeedRepeater(opStatus, pMsgContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_27_SUBFUNC_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC27_PROGRESS_KEYREPEATER:
    lStdResult = Dcm_Service27KeyRepeater(opStatus, pMsgContext, ErrorCode, pRepContext);                                                            /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_27_SUBFUNC_SUPPORT_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
  case DCM_SVC27_PROGRESS_CHECKATTEMPTSEXCEEDED:
    lStdResult = Dcm_Service27CheckAttemptsExceededRepeater(opStatus, pMsgContext, ErrorCode, pRepContext);                                          /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service27PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service27PostProcessor(Dcm_ConfirmationStatusType status)
{
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc27;

  /* If a positive response was successfully sent */
  if(status == DCM_RES_POS_OK)
  {
    /* If it was a compare key request: */
    if(Dcm_Svc27IsKeyRequest(pRepContext->SubSvcRef))
    {
      /* Apply the new security state and reset sequence */
      Dcm_StateSetSecurity((Dcm_StateIndexOptType)((Dcm_Svc27GetSecLvlRef(pRepContext->SubSvcRef)) + 1u));/* locked = 0x00 -> level 1 = 0x01, etc */
    }
    else
    {
      /* If this was no zero seed response: */
      if(pRepContext->IsZeroSeed == FALSE)
      {
        /* Prepare for key acceptance */
        Dcm_InstanceContext.Diag.Services.Svc27.SeedLevel = Dcm_CfgStateSecurityInfo[(Dcm_Svc27GetSecLvlRef(pRepContext->SubSvcRef))].Value;
      }
      else
      {
        /* Otherwise, there is no key expected in that case after zero seed */
        Dcm_Svc27ResetSequence();
      }
    }
  }
  else if((DCM_DIAG_RES_NEG_ANY & status) != 0) /* Otherwise, if any negative response was sent: */
  {
    /* Reset the key-seed-sequence */
    Dcm_Svc27ResetSequence();
  }
  else /* POS_NOK */
  {
    /*
     * Otherwise no change required:
     *   - on SeedReq: the client shall retry the seed request or send another one
     *                 -> do not move to expect key for a certain level
     *   - on KeyReq:  the client may retry the key request to get a response
     *                 -> do not invalidate expect key for this level
     */
  }
}
# if (DCM_SVC_27_SUBFUNC_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SeedProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service27SeedProcessor(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext
                                                                 ,Dcm_NegativeResponseCodePtrType ErrorCode)                                         /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc27;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* If the attempt counters are currently read or written by the application: */
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  if(Dcm_TskGetEvent(DCM_TSK_ID_SVC27) != 0u)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
#  endif
  {
    pRepContext->IsZeroSeed = FALSE;                                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */

    /* If the security timer is not yet expired: */
#  if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
    if(Dcm_Svc27TimerExpired(pRepContext->SecLvlRef) == FALSE)
    {
      /* Send the NRC 0x37 */
      *ErrorCode = DCM_E_REQUIREDTIMEDELAYNOTEXPIRED;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else
#  endif
    {
      /* If seed level not yet unlocked: */
      if (0 == (Dcm_StateGetSecurity() & Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, (pRepContext->SecLvlRef + 1u))))
      {
        /* New seed request / repetition of the same seed request. Get application generated seed */
        Dcm_RepeaterNextStep(DCM_SVC27_PROGRESS_SEEDREPEATER);
        lStdResult = DCM_E_LOOP;/* Speed up processing */
      }
      else
      {
        Dcm_CfgNetBufferSizeMemType lSeedSize = Dcm_CfgSvc27SecLevelInfo[pRepContext->SecLvlRef].SeedResLength;

#  if (DCM_DEV_RUNTIME_CHECKS == STD_ON)                                                                                                             /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
        if(Dcm_DiagCheckResBuffer(pMsgContext, lSeedSize) == FALSE)                                                                                  /* COV_DCM_RTM_RUNTIME_CHECK TX */ /* SBSW_DCM_PARAM_PTR_FORWARD */
        {
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
        else
#  endif
        {
          /* return zero seed */
          pRepContext->IsZeroSeed = TRUE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
          Dcm_UtiMemSetUintX(Dcm_DiagGetResData(pMsgContext), Dcm_MsgItemType, 0x00u, lSeedSize);                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */ /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_RESBUFFER */
          Dcm_DiagProvideResData(pMsgContext, lSeedSize);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
          lStdResult = DCM_E_OK;
        }
      }
    }
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_27_SUBFUNC_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27KeyProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service27KeyProcessor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc27;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* If the attempt counters are currently read or written by the application: */
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  if(Dcm_TskGetEvent(DCM_TSK_ID_SVC27) != 0u)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
#  endif
  {
    /* If the security level of the requested key matches to the previously sent seed request: */
    if(Dcm_CfgStateSecurityInfo[pRepContext->SecLvlRef].Value == Dcm_InstanceContext.Diag.Services.Svc27.SeedLevel)
    {
      /* Get application key comparator */
      Dcm_RepeaterNextStep(DCM_SVC27_PROGRESS_KEYREPEATER);
      lStdResult = DCM_E_LOOP; /* Speed up processing */
    }
    else
    {
      /* Send NRC 0x24 */
      *ErrorCode = DCM_E_REQUESTSEQUENCEERROR;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

#  if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
      /* If a seed request has been sent: */
      if(Dcm_Svc27IsKeyRequestExpected())
      {
        /* Increment attempt counter  */
        Dcm_Svc27CounterInc(pRepContext->SecLvlRef);                                                                                                 /* PRQA S 3109 */ /* MD_MSR_14.3 */

#   if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
        /* Notify application about new attempt counter and wait until it is stored */
        Dcm_RepeaterNextStep(DCM_SVC27_PROGRESS_SETATTEMPTCNTR);
        pRepContext->ErrorCode = *ErrorCode; /* will be used in next step */                                                                         /* SBSW_DCM_GLOBAL_PTR_WRITE */
        lStdResult = DCM_E_LOOP;
#   else
        lStdResult = DCM_E_NOT_OK;
#   endif
      }
      else
#  endif
      {
        /* Otherwise - send prepared NRC */
        lStdResult = DCM_E_NOT_OK;
      }
    }
  }
  return lStdResult;
}
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service28_XXProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service28_XXProcessor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8   msgType;
  boolean validParam = TRUE;
  Dcm_Svc28RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc28;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Extract and validate the requested network type (i.e. request data byte[0], high nibble) */
  {
    sint16_least lookUpResult;
    lookUpResult = Dcm_UtiLookUpUint8(Dcm_CfgSvc28SubNetIdLookUp, (uint8)(Dcm_DiagGetReqDataAsU8(pMsgContext) >> 4u));                               /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

    if(lookUpResult >= 0)
    {
      pRepContext->NetworkRef = Dcm_CfgSvc28SubNetIdMap[lookUpResult];                                                                               /* SBSW_DCM_GLOBAL_PTR_WRITE */
# if (DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON)
      if(pRepContext->NetworkRef == DCM_SVC_28_NETWORK_CURRENT)
      {
        pRepContext->NetworkRef = Dcm_PbCfgNetConnComMChannelMap[Dcm_PbCfgNetConnectionInfo[Dcm_DiagGetTranspObj()->ConnId].NetworkIdRef];           /* SBSW_DCM_GLOBAL_PTR_WRITE */
      }
# endif
    }
    else
    {
      validParam = FALSE;
    }
  }

  /* Extract and validate the requested message type (i.e. request data byte[0], low nibble) */
  {
    msgType = (uint8)(Dcm_DiagGetReqDataAsU8(pMsgContext) & 0x0Fu);

    if(Dcm_UtiLookUpUint8(Dcm_CfgSvc28MessageTypeLookUpTable, msgType) < 0)                                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    {
      validParam = FALSE;
    }
  }

  if(validParam == TRUE)
  {
    /*--------------------------------------------------------------
    Message types      |   Operations                |ComParamValue
    (Affected = 1,     |                             |
     Not affected = 0) | (Enable = 0, Disable = 1)   |
    ------+------------+-----------------+-----------+
    NM    |    Appl    |    RxPath       |  TxPath   |
    ------+------------+-----------------+-----------+--------------
      0   |     0      |        x        |    x      |    -
      0   |     1      |        0        |    0      |    4
      0   |     1      |        0        |    1      |    5
      0   |     1      |        1        |    0      |    6
      0   |     1      |        1        |    1      |    7
      1   |     0      |        0        |    0      |    8
      1   |     0      |        0        |    1      |    9
      1   |     0      |        1        |    0      |    10
      1   |     0      |        1        |    1      |    11
      1   |     1      |        0        |    0      |    12
      1   |     1      |        0        |    1      |    13
      1   |     1      |        1        |    0      |    14
      1   |     1      |        1        |    1      |    15
    ------+------------+-----------------+-----------+--------------
    => ModeValue := ((msgType) & 0x03) << 2) | ((RxPath) & 0x01) << 1) | ((TxPath) & 0x01) ) ) - 4
    SubFunc == ((RxPath) & 0x01) << 1) | ((TxPath) & 0x01);
    => ModeValue := ((msgType) & 0x03) << 2) | (SubFunc) ) - 4
    */
    pRepContext->ComMode = (Dcm_CommunicationModeType)( ( ((msgType & 0x03u) << 2) | (pRepContext->SubServiceId & DCM_SVC_28_CTRL_OP_MASK) ) - 4);   /* SBSW_DCM_GLOBAL_PTR_WRITE */
# if (DCM_SVC_28_USER_ENABLED == STD_ON)
    /* Mark current service execution as internally handled to perform the post-processing step later on */
    pRepContext->IsInternallyProcessed = TRUE;                                                                                                       /* SBSW_DCM_GLOBAL_PTR_WRITE */
# endif
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service28Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service28Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lStdResult;
  Dcm_Svc28RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc28;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc28Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC28_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc28SubFuncHandler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                             /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service28PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service28PostProcessor(Dcm_ConfirmationStatusType status)
{
  if(status == DCM_RES_POS_OK)
  {
# if (DCM_SVC_28_USER_ENABLED == STD_ON)
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.IsInternallyProcessed == TRUE)
# endif
    {
      Dcm_Svc28ApplyCommControl(Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.NetworkRef,
                                Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.ComMode);
    }
  }
}
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service2AProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2AProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2AHandler(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  case DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP:
    lStdResult = Dcm_Svc2AScheduledDidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# if (DCM_DIDMGR_PERIODICDID_CHK_COND_ENABLED == STD_ON)
  case DCM_SVC2A_PROGRESS_DID_CHECKCONDITION:
    lStdResult = Dcm_Svc2ADidCheckCondition(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# endif
  case DCM_SVC2A_PROGRESS_DID_GETLENGTH:
    lStdResult = Dcm_Svc2ADidGetLength(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  case DCM_SVC2A_PROGRESS_STOPPED_DID_LOOKUP:
    lStdResult = Dcm_Svc2AStoppedDidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service2APostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2APostProcessor(Dcm_ConfirmationStatusType status)
{
  if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.UdsRate != 4u)
  {
    if(status == DCM_RES_POS_OK)
    {
      Dcm_Svc2ASchdCommit(Dcm_Svc2AMakeSchdRateFromUdsRate(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.UdsRate));
      Dcm_NetPeriodicMsgSetConnection(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.ConnId);
    }
    else
    {
      Dcm_Svc2ASchdDiscard();
    }
  }/* else - nothing */
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2C_01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2C_01Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdReturn;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C;

  lStdReturn = Dcm_Svc2CParseAndCheckDynDid(opStatus, pMsgContext, ErrorCode, pRepContext);

  if(lStdReturn == DCM_E_OK)
  {
    /* there shall be an iteration (+[4Byte]) */
    if( (pMsgContext->reqDataLen > 0u)
      &&( (pMsgContext->reqDataLen % 4u) == 0) )
    {
      uint8 numReqItems = (uint8)(pMsgContext->reqDataLen / 4);/* calculate number of source items to be processed */

      /* check DynDID capacity */
      *ErrorCode = Dcm_Svc2CCheckNumOfItems(numReqItems, pRepContext);                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
      if(*ErrorCode == DCM_E_POSITIVERESPONSE)
      {
        Dcm_RepeaterNextStep(DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP);
        lStdReturn =  DCM_E_LOOP;/* speed up processing */
      }
      else
      {
        /* else - lNrc already set */
        lStdReturn = DCM_E_NOT_OK;
      }
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
  }/* else - just return the value: DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2C_02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2C_02Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdReturn;
  uint8          lAlfid;
  uint8          lBlockLength;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C;

  lStdReturn = Dcm_Svc2CParseAndCheckDynDid(opStatus, pMsgContext, ErrorCode, pRepContext);

  if(lStdReturn == DCM_E_OK)
  {
    /* the ALFID availability is checked within next call */
    *ErrorCode = Dcm_MemMgrValidateAlfid(pMsgContext, &lAlfid, &lBlockLength);                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    if (*ErrorCode == DCM_E_POSITIVERESPONSE)
    {
      Dcm_MemMgrMemBlockType lMemBlock;

      /* pMsgContext->reqDataLen cannot be zero! */
      if((pMsgContext->reqDataLen % lBlockLength) == 0) /* the remained request length shall be a multiple of the memory address and size request block */
      {
        uint8 numReqItems = (uint8)(pMsgContext->reqDataLen / lBlockLength);/* calculate number of source items to be processed */

        /* check DynDID capacity */
        *ErrorCode = Dcm_Svc2CCheckNumOfItems(numReqItems, pRepContext);                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
        if (*ErrorCode == DCM_E_POSITIVERESPONSE)
        {
          do
          {
            Dcm_MemMgrParseMemStream(lAlfid, pMsgContext, &lMemBlock);
            lStdReturn = Dcm_MemMgrCheckMemBlock(&lMemBlock, DCM_MEMMGR_OP_READ, ErrorCode);

            if (lStdReturn == DCM_E_NOT_OK)
            {
              /* stop immediately and report the error */
              pRepContext->ReqNumOfItems = 0; /* break */
            } /* else - check for definition length overflow */
            else if( (lMemBlock.Length > DCM_SVC_2C_READ_BUFFER_SIZE)
              || (!Dcm_UtiIsAdditionSafe(uint32, pRepContext->DynDidLength, lMemBlock.Length))
              || (Dcm_UtiPromotedSum(uint32, pRepContext->DynDidLength, lMemBlock.Length) > pRepContext->MaxAllowedLength))
            {
              *ErrorCode = DCM_E_REQUESTOUTOFRANGE;/* too much data referenced  */                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
              lStdReturn = DCM_E_NOT_OK;
              /* finish service processing immediately */
              pRepContext->ReqNumOfItems = 0; /* break */
            }
            else
            {
              /* else - add this address to the DynDID definition */

              /* update total length of the DynDID for commitment */
              pRepContext->DynDidLength += (Dcm_CfgNetBufferSizeMemType)(lMemBlock.Length);

              Dcm_UtiAssignStruct(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[pRepContext->SrcItemIndex].MemDescriptor.MemBlock                 /* PRQA S 0310 */ /* MD_Dcm_GenericStructAssign_0310 */
                                 ,lMemBlock);                                                                                                        /* PRQA S 3109 */ /* MD_Dcm_CfgDepend_3109 */

              Dcm_Svc2CSetMemSrcItem(pRepContext->SrcItemIndex); /* set the type of the source item to MEMORY */
              ++(pRepContext->SrcItemIndex); /* next item to be configured */
              ++(pRepContext->DynDidItemCount); /* update number of items for commitment */
              --(pRepContext->ReqNumOfItems);/* commit processed item */
            }
          }
          while (pRepContext->ReqNumOfItems != 0);
        }
        else
        {
          /* else - ErrorCode already set */
          lStdReturn = DCM_E_NOT_OK;
        }
      }
      else
      {
        /* else - ErrorCode set to 0x13 */
        *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdReturn = DCM_E_NOT_OK;
      }
    }
    else
    {
      /* else - ErrorCode already set */
      lStdReturn = DCM_E_NOT_OK;
    }
  }/* else - DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2C_03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2C_03Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType ErrorCode)                                          /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType lStdReturn;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pRepContext->DynDidItemCount = 0u; /* prepare for a successful clear */

  if(pMsgContext->reqDataLen == 0u)
  {
    /* clear all DynDID definitions */
    Dcm_CfgDidMgrDynDidHandleOptType dynDidIter;
    for(dynDidIter = 0; dynDidIter < DCM_NUM_DYNDIDS; ++dynDidIter)
    {
      Dcm_Svc2CDefMgrClear((Dcm_CfgDidMgrDynDidHandleMemType)dynDidIter);
    }
    lStdReturn = DCM_E_OK;
  }
  else if (pMsgContext->reqDataLen == 2u)
  {
    Dcm_RepeaterNextStep(DCM_SVC2C_PROGRESS_03_DIDLOOKUP); /* next job */
    lStdReturn = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  return lStdReturn;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Service2CProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2CProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lStdResult;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2CHandler(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  case DCM_SVC2C_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc2CSubFuncHandler(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP:
    lStdResult = Dcm_Svc2C_01SrcDidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
#  if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
  case DCM_SVC2C_PROGRESS_01SRC_DIDCHECKCONDITIONS:
    lStdResult = Dcm_Svc2C_01SrcDidCheckCondition(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
#  endif
  case DCM_SVC2C_PROGRESS_01SRC_DIDGETLENGTH:
    lStdResult = Dcm_Svc2C_01SrcDidGetLength(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# endif
# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC2C_PROGRESS_03_DIDLOOKUP:
    lStdResult = Dcm_Svc2C_03DidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service2CPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2CPostProcessor(Dcm_ConfirmationStatusType status)
{
  if(status == DCM_RES_POS_OK)
  {
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidItemCount != 0u)/* this is a definition service , not the clear one */
    {
# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON) && \
     (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
      uint16 lDid = Dcm_DidMgrGetDynDidIdFromHandle(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidHandle);
      /* Kill any still not finished read periodic DID jobs to avoid inconsistent response data/length ! */
      Dcm_Svc2ASchdCancelReadByDid(lDid);
# endif
      /* Commit DynDID definition immediately */
      Dcm_InstanceContext.Diag.Services.Svc2C.Items[Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidHandle].Length = Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidLength;
      Dcm_InstanceContext.Diag.Services.Svc2C.Items[Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidHandle].Count  = Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidItemCount;
    } /* else - the dynDid has been already cleared */
  } /* else - the dynDid list properties will not be changed - all prepared data will be discarded */
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service2EProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2EProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc2E;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2EHandler(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# if (DCM_DIDMGR_2E_ACCESS_LOCK_ENABLED == STD_ON)
  case DCM_SVC2E_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc2ECheckAccess(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# endif
  case DCM_SVC2E_PROGRESS_ECECUTEOP:
    lStdResult = Dcm_Svc2EExecuteOp(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service2FProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2FProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2FHandler(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# if (DCM_DIDMGR_2F_ACCESS_LOCK_ENABLED == STD_ON)
  case DCM_SVC2F_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc2FCheckAccess(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# endif
  case DCM_SVC2F_PROGRESS_EXECUTEOP:
    lStdResult = Dcm_Svc2FExecuteOp(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# if (DCM_SVC_2F_READ_RES_DATA_LEN_ENABLED == STD_ON)
  case DCM_SVC2F_PROGRESS_GETLENGTH:
    lStdResult = Dcm_Svc2FGetLength(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# endif
# if(DCM_DIDMGR_IODID_READ_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC2F_PROGRESS_READDATA:
    lStdResult = Dcm_Svc2FReadData(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service2FPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2FPostProcessor(Dcm_ConfirmationStatusType status)
{
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DIDMGR_2F_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.DidMgr.DidRsrcContext.Io = 0u;
# endif
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service31Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service31Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lStdResult;

  Dcm_Svc31RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc31;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc31Handler(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  case DCM_SVC31_PROGRESS_EXECUTEOP:
    lStdResult = Dcm_RidMgrExecuteRoutine(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service3DProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service3DProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lStdResult;

  Dcm_Svc3DRepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc3D;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc3DHandler(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  case DCM_SVC3D_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc3DCheckAccess(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
# endif
  case DCM_SVC3D_PROGRESS_WRITEMEMORY:
    lStdResult = Dcm_Svc3DWriteMemory(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service3EProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service3EProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_DiagSubServiceRefOptType  subSvcRef;

  /* Check initialization state */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                             ,Dcm_CfgSvc3ESubFuncLookUpTable
                                             ,Dcm_CfgSvc3ESubFuncExecPrecondTable
                                             ,Dcm_DiagSvcWithOnlySubFuncReqLengthGetter
                                             ,&subSvcRef
                                             ,ErrorCode);                                                                                            /* SBSW_DCM_CALL_VERIFY_SERVICE_WITH_SUBFUNCTION */

}
#endif /* (DCM_SVC_3E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service85Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service85Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;

  Dcm_Svc85RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc85;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc85Handler(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC85_PROGRESS_REPEATERPROXY:
    lStdResult = Dcm_Svc85_XX_RepeaterProxy(opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PARAM_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service85PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service85PostProcessor(Dcm_ConfirmationStatusType status)
{
  /* If a positive response was (successfully) sent: */
  if((status & DCM_DIAG_RES_NEG_ANY) == 0)
  {
    /* Trigger the requested mode switch */
    Dcm_ModeSwitchDtcSetting(Dcm_InstanceContext.Repeater.Contexts.Context.Svc85.ReqMode
                            ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc85.DTCGroup
                            ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc85.DemClientId);
  }
}
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service86Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service86Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext
                                                             ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType                lStdResult;

  Dcm_Svc86RepeaterProxyContextPtrType pRepContext = &Dcm_InstanceContext.Repeater.Contexts.Context.Svc86;

  switch (Dcm_RepeaterGetProgress())
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc86Handler(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  case DCM_SVC86_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc86SubFuncHandler(opStatus, pMsgContext, ErrorCode, pRepContext);
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CALLOUT_CODE
/*lint -save -esym(961, 19.1) */
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore */
/* ----------------------------------------------
 ~&&&   Component Detailed Design of generated functions
---------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_ModeRule<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_ModeCondGet_<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_ModeOnComControlModeChange()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 *  Dcm_SvcWrapper_<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_SubSvcWrapper_<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_ServiceNoPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_ServiceNoUpdater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  Dcm_ServiceNoCancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
/* ----------------------------------------------
 ~&&&   MISRA
---------------------------------------------- */
/* module specific MISRA deviations:

   MD_Dcm_BitNegation_0277:
     Description: Rule 3.1
                  All usage of implementation-defined behavior shall be documented.
     Reason:      Using the ~ operator avoids errors in manually typed bit masks.
     Risk:        May generate compiler warnings although explicit casts are used.
     Prevention:  None.

   MD_Dcm_QacIssue_0504:
     Description: Rule 1.2
                  Dereferencing pointer value that is apparently NULL.
     Reason:      Pointer is checked against NULL, but prior dereferencing it it is assigned to a non-NULL value. Seems to be an issue in QAC.
     Risk:        No risks, since pointer value is definitely non-zero.
     Prevention:  None.

   MD_Dcm_Optimize_0759:
     Description: Rule 18.4
                  An object of union type has been defined.
     Reason:      An union object has been defined to optimize RAM usage for not in parallel executed jobs.
     Risk:        No risks, since all members of this shared RAM have always mutually exclusive access (i.e. service processor cannot be executed in parallel to another one).
     Prevention:  None.

   MD_Dcm_CfgDepend_0777:
     Description: Rule 5.1
                  Identifiers (internal and external) shall not rely on the significance of more than 31 characters.
     Reason:      It depends on the module's configuration (user settings) on how long the identifiers will be.
     Risk:        Compilation errors are possible.
     Prevention:  The user shall choose shorter names while configuring the module.

   MD_Dcm_Understand_0779:
     Description: Rule 5.1
                  Identifiers (internal and external) shall not rely on the significance of more than 31 characters.
     Reason:      Code maintainability requires structured names conflicting with this limitation.
     Risk:        Compilation errors are possible.
     Prevention:  Compiler compatibility is tested during integration.

   MD_Dcm_CodingRule_3218:
     Description: Rule 8.7
                  Objects shall be defined at block scope if they are only accessed from within a single function.
     Reason:      Vector style guide prevents usage of static variables/constant objects in function scope.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_3353:
    Description: Rule 9.1: The variable '%s' is possibly unset at this point.
    Reason:      A variable is only set under certain conditions in another branch; when used later, a preceding check which verifies that the specific condition are fulfilled is not recognized by QAC.
    Risk:        Variable may be unset.
    Prevention:  Review, runtime tests in test suite.

   MD_Dcm_AbstractTokenReplacement_3410:
     Description: Rule 19.10
                  Macro parameter not enclosed in ().
     Reason:      The macro parameter represents an abstract token: either data type or operation, or structure member, etc.. If enclosed in () the code will not compile.
     Risk:        In worst case, the code will not compile due to unknown or not expected token.
     Prevention:  None.

   MD_Dcm_3415:
     Description: Rule 12.4
                  The right hand operand of a logical && or || operator shall not contain side effects
     Reason:      The function called on the right hand side has no side effects.
     Risk:        The function may introduce side effects at a later time.
     Prevention:  None.

   MD_Dcm_OptimizedInlineCode_3440:
     Description: Rule 12.13
                  Result of ++ or -- operator used in expression.
     Reason:      This kind of operator is used only in case of function-like macros where also a return value is expected. Needed for maximum inlining efficiency and less other MISRA deviations.
     Risk:        The risks are at minimum since the affected locations are simple expressions.
     Prevention:  These code sections are thoroughly tested by dedicated unit tests.

   MD_Dcm_0313:
     Description: Rule 11.1
                  Conversions shall not be performed between a pointer to a function and any type other than an integral type.
     Reason:      No efficient dynamic-cast operation available in ANSI-C.
     Risk:        Data corruption due to miscast.
     Prevention:  Covered by descriptive pointer types and code review for correct usage.

   MD_Dcm_GenericStructAssign_0310:
     Description: Rule 11.4
                  A cast should not be performed between a pointer to object type and a different pointer to object type.
     Reason:      For some compilers there is a workaround that helps perform generic structure assignments. Usually this operation is left to the compiler.
     Risk:        Compile error/warnings.
     Prevention:  Compiler compatibility is tested during integration.

   MD_Dcm_DifferentPointerType_0310:
     Description: Rule 11.4
                  A cast should not be performed between a pointer to object type and a different pointer to object type.
     Reason:      To optimize access without the need of local variable, pointers to data types of the same size (uint8, sint8) will be casted to the corresponding target pointer type.
     Risk:        Compile error/warnings.
     Prevention:  Compiler compatibility is tested during integration.

   MD_Dcm_3355:
     Description: Rule 13.7
                  Boolean operations whose results are invariant shall not be permitted.
     Reason:      The expression is not invariant. Depending on supported features invariant value is possible but
                  the resulting code modification will adversely affect maintainability of already complicated code
                  paths.
     Risk:        Compile error/warnings.
     Prevention:  None.

   MD_Dcm_3358:
     Description: Rule 13.7
                  Boolean operations whose results are invariant shall not be permitted.
     Reason:      The expression is not invariant. Depending on supported features invariant value is possible but
                  the resulting code modification will adversely affect maintainability of already complicated code
                  paths.
     Risk:        Compile error/warnings.
     Prevention:  None.

   MD_Dcm_3219:
     Description: Rule 14.1
                  There shall be no unreachable code.
     Reason:      This statement is used to avoid warnings caused by APIs that are used as library functions and are therefore always available.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_3112:
     Description: Rule 14.2
                  All non-null statements shall either (i) have at least one side-effect however executed, or
                  (ii) cause control flow to change.
     Reason:      This statement is used to avoid warnings caused by unused parameters. Parameters are defined by
                  standardized API requirements, and not needed in case a feature is disabled by configuration.
                  It is either impossible due to API standardization or necessary code duplication (severe maintenance
                  increase) to provide feature dependent APIs with different signatures.
     Risk:        Unavoidable compiler warning or error because of either unused statements or unused parameter.
     Prevention:  None.

   MD_Dcm_CfgDepend_3109:
     Description: Rule 14.3
                  Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a
                  comment provided that the first character following the null statement is a white-space character.
     Reason:      The statement can be empty or not - it is configuration parameter dependent.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Optimize_0771:
     Description: Rule 14.6
                  For any iteration statement there shall be at most one break statement used for loop termination.
     Reason:      The loop needs multiple exit points since error conditions cannot be verified prior to the loop.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Optimize_2006:
     Description: Rule 14.7
                  A function shall have a single point of exit at the end of the function.
     Reason:      For code run-time/ROM usage reason this function terminates immediately.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_APIStd_3673:
     Description: Rule 16.7
                  A pointer parameter in a function prototype should be declared as pointer to const if the pointer is
                  not used to modify the addressed object.
     Reason:      The API is defined by the AUTOSAR standardization.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Design_3673:
     Description: Rule 16.7
                  A pointer parameter in a function prototype should be declared as pointer to const if the pointer is
                  not used to modify the addressed object.
     Reason:      The API has to be compatible to a common prototype, defined by module's design to serve generic purposes.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_StructMemberAbstr_3410:
     Description: Rule 19.10
                  In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##.
     Reason:      This is a special deviation in order to make dynamic structure member reference: #define a(idx, member)  (myStruct[idx].Member).
     Risk:        Compile error will occur if the macro parameter is enclosed in ().
     Prevention:  None.

   MD_Dcm_Optimize_0750:
     Description: Rule 18.4
                  Unions shall not be used
     Reason:      Data without shared lifetime is stored in union for efficiency.
     Risk:        None due to no shared lifetime.
     Prevention:  None.

  MD_Dcm_Consistency_0342:
     Description: Rule 19.13
                  The # and ## preprocessor operators should not be used.
     Reason:      Simplifies and improves the consistency on for function name convention change within AR releases.
     Risk:        If a preprocessor does not support this ISO operator, then a compile error will occur.
     Prevention:  Compiler compatibility is tested during integration.

  MD_Dcm_BitNegation_0290:
     Description: Rule 21.1
                  Minimization of run-time failures shall be ensured by the use of at least one of (a) static analysis
                  tools/techniques; (b) dynamic analysis tools/techniques; (c) explicit coding of checks to handle
                  run-time faults.
     Reason:      False positive due to insufficient data flow analysis. Despite thorough review no defect could be
                  recognized.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_BitNegation_0291:
     Description: Rule 21.1
                  Minimization of run-time failures shall be ensured by the use of at least one of (a) static analysis
                  tools/techniques; (b) dynamic analysis tools/techniques; (c) explicit coding of checks to handle
                  run-time faults.
     Reason:      False positive due to insufficient data flow analysis. Despite thorough review no defect could be
                  recognized.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_Optimize_2003:
     Description: Rule 15.2
                  The preceding non-empty 'case' or 'default' clause does not end with an explicit 'break' or 'return' statement.
     Reason:      To use optimal design small switch-case dispatchers use fall-through cases.
     Risk:        None, since documented as an explicit fall-through case.
     Prevention:  None.

  MD_Dcm_RteSpecific_1330:
     Description: Rule 16.4
                  The parameter identifiers in this function declaration differ from those in a previous declaration.
     Reason:      The function declaration generated by the RTE are RTE-implementation specific and unknown at the DCM development time.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_Design_6060:
     Description: Metric STPAR
                  Number of function parameters defined by HIS shall be in range 0..5.
     Reason:      DCM uses flyweight pattern to minimize shared resource management complexity and risks of overwritten RAM.
                  This pattern requires more input data in comparison with functions with access to global RAM.
     Risk:        Stack usage and runtime too high for target uC.
     Prevention:  Use local inline functions to minimize stack and run-time usage.
*/
/* ----------------------------------------------
 ~&&&   COVERAGE
---------------------------------------------- */
/* COV_JUSTIFICATION_BEGIN

\ID COV_DCM_MACRO_OVERRIDE
  \ACCEPT TX
  \ACCEPT XF
  \REASON The value of a macro may be overridden by user config for test purposes. Since this is not officially
          supported, it is not covered by the test suite.

\ID COV_DCM_UNSUPPORTED
  \REASON [COV_MSR_UNSUPPORTED]

\ID COV_DCM_SUPPORT_PARTIALLY
  \REASON [COV_MSR_UNSUPPORTED]

\ID COV_DCM_SUPPORT_ALWAYS
  \REASON This configuration switch is always on, but the code is enclosed in a pre-processor precondition for consistency reasons and safe future changes.

\ID COV_DCM_SUPPORT_RESTRICTED
  \REASON This configuration switch is always on/off, due to feature range limitation.

\ID COV_DCM_SUPPORT_XOR
  \REASON Disjunction of configuration switches that are mutually exclusive and one of them is always true.

\ID COV_DCM_SUPPORT_WITH_MSR_DEM
  \REASON This configuration switch is always on as long as MSR4 DEM is used (required for SafeBSW context).

\ID COV_DCM_REQUIRED_BY_SAFEBSW
  \REASON This configuration switch is always on as required by SafeBSW context.

\ID COV_DCM_DEPENDS_ON_UNSUPPORTED
  \REASON This configuration switch is always on/off due to a justified expression it is involved in.

\ID COV_DCM_DEV_DEBUG
  \REASON The justified object is uncovered, since it is only used during component development to ease the detection of errors!

\ID COV_DCM_RTM_NO_RCR_RP_TX
  \ACCEPT XX
  \REASON The justified object is unreachable, since the configuration does not support any feature that could use it.
          A complete encapsulation of all use-cases where no RCR-RP will be sent would be too complex and risky.

\ID COV_DCM_RTM_DEV_DEBUG
  \REASON [COV_DCM_DEV_DEBUG]

\ID COV_DCM_RTM_UNREACHABLE
  \REASON The justified object is uncovered, since it is not intended to be reached! It just exists because of other reasons like MISRA (default case in a switch)
          or because of added debug assert monitoring for development purposes (see COV_DCM_RTM_DEV_DEBUG).

\ID COV_DCM_RTM_UNREACHABLE_COMPLEXITY
  \REASON The justified object is uncovered, since it can be reached only in very rare situations (i.e. interrupt, multiple events in a specific sequence, etc.)!
          But at the same time it is part of the (sub-)component design and cannot be removed.

\ID COV_DCM_RTM_DESIGN_LOWER_LAYER
  \REASON The justified object is uncovered, since it is a basic (lower layer) functionality and is designed to behave in different situations.
          These situations are not necessarily supported by all configurations. Due to the high complexity of dependent functionalities
          the concrete usage of the uncovered functionality is left to the upper layers in DCM!

\ID COV_DCM_RTM_RUNTIME_CHECK
  \REASON This condition depends on a NULL_PTR returned due to a triggered runtime check.

\ID COV_DCM_RTM_DEPENDS_ON_UNSUPPORTED
  \REASON The justified object is uncovered, since it can vary only if a specific (non supported in SafeBSW context) configuration is activated.

\ID COV_DCM_RTM_DEPENDS_ON_CFG
  \ACCEPT TX
  \ACCEPT XF
  \REASON The justified expression evaluates always depending on the configuration either to true or false.

COV_JUSTIFICATION_END */
/* ----------------------------------------------
 ~&&&   SafeBSW
---------------------------------------------- */
/* SBSW_JUSTIFICATION_BEGIN

\ID SBSW_DCM_PARAM_PTR_WRITE
  \DESCRIPTION    In a function, data is written through a pointer passed as function argument.
  \COUNTERMEASURE \N [CM_DCM_N_PASS_PARAM_PTR]

\ID SBSW_DCM_GEN_PARAM_PTR_WRITE
  \DESCRIPTION    In a generated function, called only by DCM static code, data is written through a
                  pointer passed as function argument.
  \COUNTERMEASURE \S [CM_DCM_S_GEN_PARAM_PTR_WRITE]

\ID SBSW_DCM_PARAM_PTR_FORWARD
  \DESCRIPTION    A pointer received in a function is passed to a function expecting a valid pointer.
  \COUNTERMEASURE \N [CM_DCM_N_PASS_PARAM_PTR]

\ID SBSW_DCM_GEN_PARAM_PTR_FORWARD
  \DESCRIPTION    A pointer received in a generated function, called only by DCM static code, is passed to
                  a function expecting a valid pointer.
  \COUNTERMEASURE \S [CM_DCM_S_GEN_PARAM_PTR_FORWARD]

\ID SBSW_DCM_PARAM_FUNCPTR_CALL
  \DESCRIPTION    In a function, a function pointer passed as function argument is called.
  \COUNTERMEASURE \N [CM_DCM_N_CALL_PARAM_FUNCPTR]

\ID SBSW_DCM_GLOBAL_PTR_WRITE
  \DESCRIPTION    In a function, data is written through a pointer taken from a global variable.
  \COUNTERMEASURE \N The pointer is taken from a global variable, as such it is always valid.

\ID SBSW_DCM_POINTER_FORWARD_STACK
  \DESCRIPTION    A pointer is passed to a function expecting a valid pointer. The called function does not store its
                  pointer parameter(s).
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DCM_GEN_POINTER_FORWARD_STACK
  \DESCRIPTION    A pointer is passed to a function expecting a valid pointer (i.e. to return data through it).
                  The called function does not store its pointer parameter(s) for deferred writing.
  \COUNTERMEASURE \S [CM_DCM_S_GEN_POINTER_FORWARD_STACK]

\ID SBSW_DCM_POINTER_FORWARD_GLOBAL
  \DESCRIPTION    A pointer is passed to a function expecting a valid pointer. The called function does not store its
                  pointer parameters.
  \COUNTERMEASURE \N The pointer is taken from a global variable, as such it is always valid.

\ID SBSW_DCM_COMB_PARAM_PTR_FORWARD
  \DESCRIPTION    A combination of pointers is passed to a function expecting valid pointers. The called function does not store its
                  pointer parameters.The pointer is taken from one of the following locations:
                     - global variable;
                     - local (stack) variable;
                     - is an argument of the caller function (refer also to CM_DCM_N_PASS_PARAM_PTR);
                     - is a pointer initialized with one of the following associated initialization function that returns always a
                       valid Pointer: Dcm_DiagInitDataContext(), Dcm_DiagGetDataContextBuffer(), Dcm_DiagInitiateServiceProcessing(),
                                      Dcm_DiagGetResDataAt(), Dcm_NetGetBufferInfos(), Dcm_NetGetTransportObject()
                     as such it is always valid.
\COUNTERMEASURE \M [CM_DCM_M_SIZEOF_BUFFERINFO]
                \R [CM_DCM_R_GET_BUFFERINFO]
                \R [CM_DCM_R_SET_DATA_CONTEXT_USAGE]

\ID SBSW_DCM_POINTER_WRITE_BUFFERINFO
  \DESCRIPTION    In an internal function, data is written through a pointer to a buffer info element, or the
                  pointer is passed to a function expecting a valid reference to a buffer info element.
                  The memory entry pointer is initialized by Dcm_NetGetBufferInfos() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_BUFFERINFO]
                  \R [CM_DCM_R_GET_BUFFERINFO]

\ID SBSW_DCM_POINTER_WRITE_COMMCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a ComM context element, or the
                  pointer is passed to a function expecting a valid reference to a ComM context element.
                  The memory entry pointer is initialized by Dcm_NetGetComMContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_COMMCONTEXT]
                  \R [CM_DCM_R_GET_COMMCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a buffer context element, or the
                  pointer is passed to a function expecting a valid reference to a buffer context element.
                  The memory entry pointer is initialized by Dcm_NetGetBufferContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_BUFFERCONTEXT]
                  \R [CM_DCM_R_GET_BUFFERCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetGetTransportObject() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]

\ID SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_DiagGetQueuedTranspObj() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]

\ID SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetGetTranspObjOfConnectionOrNull() which will always return a
                  pointer to a valid memory entry or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TOBJ_OF_CONNECTION]

\ID SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetAllocateOrGetTranspObjectOrNull() which will always return a
                  pointer to a valid memory entry or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_ALLOCATEDTOBJ]

\ID SBSW_DCM_POINTER_WRITE_RESERVEDTOBJ
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetLockConnectionOrNull() which will always return a
                  pointer to a valid memory entry or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_RESERVEDTOBJ]

\ID SBSW_DCM_POINTER_WRITE_TASKCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a task context object.
                  The memory entry pointer is initialized by Dcm_TskGetTaskContextOrNull() which will always return a
                  pointer to a valid memory entry or NULL_PTR.
  \COUNTERMEASURE \R [CM_DCM_R_GET_TASKCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_SCHEDULERCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a scheduler context object.
                  The memory entry pointer is initialized by Dcm_TskGetSchedulerContextOrNull() which will always return a
                  pointer to a valid memory entry or NULL_PTR.
  \COUNTERMEASURE \R [CM_DCM_R_GET_SCHEDULERCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_RXPDUINFO
  \DESCRIPTION    In an internal function, data is written through a pointer to a Rx-PduInfo, or the
                  pointer is passed to a function expecting a valid reference to a Rx-PduInfo element.
                  The memory entry pointer is initialized by Dcm_NetProvideRxBuffer() which will always return a
                  pointer to a valid memory entry if the return values is BUFREQ_OK.
  \COUNTERMEASURE \R [CM_DCM_R_GET_RXPDUINFO]

\ID SBSW_DCM_POINTER_INIT_MESSAGE_CONTEXT
  \DESCRIPTION    The global message context variable is passed to Dcm_DiagInitiateServiceProcessing() for initialization.
                  That initalization function ensures that all pointer members are pointing to valid memory entry pointer
                  and the corresponding buffer size members are matching to the pointed memory entry sizes.
  \COUNTERMEASURE \N The pointer is taken from a global variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_REQBUFFER
  \DESCRIPTION    In an internal function, data is written through a pointer to a message context request buffer,
                  or the pointer is passed to a function expecting a valid reference to a message context
                  request buffer. The caller ensures that the reqData member points to a valid memory entry pointer
                  and the reqBufSize member matches to the pointed memory entry size.
  \COUNTERMEASURE \R [CM_DCM_R_SET_MESSAGE_CONTEXT_REQBUFFER]

\ID SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_RESBUFFER
  \DESCRIPTION    In an internal function, data is written through a pointer to a message context response buffer,
                  or the pointer is passed to a function expecting a valid reference to a message context
                  response buffer. The caller ensures that the resData member points to a valid memory entry pointer
                  and the resBufSize member matches to the pointed memory entry size.
  \COUNTERMEASURE \R [CM_DCM_R_SET_MESSAGE_CONTEXT_RESBUFFER]

\ID SBSW_DCM_POINTER_INIT_DATA_CONTEXT
  \DESCRIPTION    The data context pointer is locally allocated and passed to Dcm_DiagInitDataContext() for initialization.
                  The caller ensures that the passed buffer pointer points to a valid memory entry pointer and the
                  passed buffer size matches to the pointed memory entry size.
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_DATA_CONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a data context, or the
                  pointer is passed to a function expecting a valid reference to a data context.
                  The pointer is initialized by Dcm_DiagInitDataContext(), which will always initialize it to point
                  to a valid memory entry. A data context ensures that the sum of Usage and AvailLen member is always
                  equal to or smaller as the referenced buffer size.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DATA_CONTEXT_BUFFER]
                  \R [CM_DCM_R_SET_DATA_CONTEXT_USAGE]

\ID SBSW_DCM_POINTER_MEMCPY_BUFFER
  \DESCRIPTION    In an internal function, data is copied into a buffer through a pointer using memcpy, or the
                  buffer pointer with the appropriate buffer size are passed to a function expecting a valid pair
                  of buffer pointer and buffer size.
  \COUNTERMEASURE \R [CM_DCM_R_MEMCPY_PASS_BUFFER]
                  \R [CM_DCM_R_MEMCPY_WRITE]

\ID SBSW_DCM_CALL_FUNCPTR_TASKINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_TskGetTaskInfoOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \R [CM_DCM_R_GET_TASKINFO]

\ID SBSW_DCM_CALL_FUNCPTR_TIMERINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_TmrGetTimerInfoOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \R [CM_DCM_R_GET_TIMERINFO]

\ID SBSW_DCM_CALL_FUNCPTR_SVCPOSTPROCESSORS
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_DiagGetPostProcessorFunc() which will always return a valid function pointer.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVCPOSTPROCESSORS]
                  \R [CM_DCM_R_GET_SVCPOSTPROCESSORS]

\ID SBSW_DCM_CALL_FUNCPTR_SVCUPDATERS
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_DiagGetUpdateFunc() which will always return a valid function pointer.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVCUPDATERS]
                  \R [CM_DCM_R_GET_SVCUPDATERS]

\ID SBSW_DCM_CALL_FUNCPTR_SVCCANCELLERS
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_DiagGetCancelFunc() which will always return a valid function pointer.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVCCANCELLERS]
                  \R [CM_DCM_R_GET_SVCCANCELLERS]

\ID SBSW_DCM_CALL_FUNCPTR_MODEMGRRULES
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgModeMgrRulesGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_MODEMGRRULES]
                  \R [CM_DCM_R_GET_MODEMGRRULES]

\ID SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST
  \DESCRIPTION    In an internal function, iteration over all elements of a given table is done.
                  Each element is a function pointer or a structure containing only function pointer members.
                  The end of iteration is marked by NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_TERMINATED_LIST]
                  \R [CM_DCM_R_TERMINATED_LIST]

\ID SBSW_DCM_POINTER_WRITE_TOBJ_ADDBUFFER
  \DESCRIPTION    In an internal function, data is written to array AddBuffer[] of a specific transport object using a
                  function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_TOBJ_ADDBUFFER]

\ID SBSW_DCM_POINTER_WRITE_COMCONTROLCHANNEL
  \DESCRIPTION    In an internal function, data is written to array Dcm_PbRamNetComCtrlChannels[] using a
                  function argument as index.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_COMCONTROLCHANNEL]
                  \R [CM_DCM_R_SET_COMCONTROLCHANNEL]

\ID SBSW_DCM_POINTER_WRITE_TOBJHANDLE
  \DESCRIPTION    In an internal function, data is written to array Dcm_PbRamNetConnId2TObjMap[] using a
                  function argument as index.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TOBJHANDLE]
                  \R [CM_DCM_R_SET_TOBJHANDLE]

\ID SBSW_DCM_POINTER_WRITE_TIMER
  \DESCRIPTION    In an internal function, data is written to array Dcm_SingletonContext.TimerMgr.Timer[] using a
                  function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_TIMER]

\ID SBSW_DCM_POINTER_WRITE_START_UP_FBL_RES_BUFFER
  \DESCRIPTION    In an internal function, data is written to array Dcm_InstanceContext.Diag.StartUpFbl.ResBuffer[]
                  using a function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_START_UP_FBL_RES_BUFFER]

\ID SBSW_DCM_POINTER_WRITE_CURRENT_TASK_PRIO_STACK
  \DESCRIPTION    In an internal function, data is written to array CurrentTaskPrioStack.Stack[] using a
                  function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_CURRENT_TASK_PRIO_STACK]

\ID SBSW_DCM_POINTER_WRITE_ATTEMPTCOUNT
  \DESCRIPTION    In an internal function, data is written to array Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[] using a
                  function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_ATTEMPTCOUNT]

\ID SBSW_DCM_POINTER_WRITE_DELAYTIME
  \DESCRIPTION    In an internal function, data is written to array Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[] using a
                  function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DELAYTIME]

\ID SBSW_DCM_CALL_VERIFY_SERVICE_WITH_SUBFUNCTION
  \DESCRIPTION    In an internal function, the function Dcm_DiagVerifyServiceWithSubFunction() is called and some
                  pointers are passed as function arguments.
  \COUNTERMEASURE \N The passed pointers are addresses of either global struct arrays (lookup-tables), global functions,
                  local variables or simply received function arguments (pMsgContext) and therefore always valid.

\ID SBSW_DCM_CALL_FUNCPTR_SVC11SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc11SubFuncInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC11SUBFUNC]
                  \R [CM_DCM_R_GET_SVC11SUBFUNC]

\ID SBSW_DCM_CALL_FUNCPTR_SVC19SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc11SubFuncInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC19SUBFUNC]
                  \R [CM_DCM_R_GET_SVC19SUBFUNC]

\ID SBSW_DCM_CALL_FUNCPTR_SVC27SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc27SubFuncInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC27SUBFUNC]
                  \R [CM_DCM_R_GET_SVC27SUBFUNC]

\ID SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc27SecLevelInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC27SECLEVEL]
                  \R [CM_DCM_R_GET_SVC27SECLEVEL]

\ID SBSW_DCM_CALL_FUNCPTR_SVC27GETSEED
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc27SecLevelInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC27SECLEVEL]
                  \R [CM_DCM_R_GET_SVC27SECLEVEL]
                  \S [CM_DCM_S_GET_SEED_FUNC_SIGNATURE]
                  \S [CM_DCM_S_GET_SEED_FUNC_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC28SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc28SubFuncInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC28SUBFUNC]
                  \R [CM_DCM_R_GET_SVC28SUBFUNC]

\ID SBSW_DCM_CALL_FUNCPTR_SVC85SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc85SubFuncInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC85SUBFUNC]
                  \R [CM_DCM_R_GET_SVC85SUBFUNC]

\ID SBSW_DCM_CALL_FUNCPTR_SERVICEINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgDiagServiceInfoGetEntryOrNull() which will always return a valid function pointer or NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SERVICEINFO]
                  \R [CM_DCM_R_GET_SERVICEINFO]

SBSW_JUSTIFICATION_END */

/*
\CM CM_DCM_N_PASS_PARAM_PTR
  The caller ensures the pointers passed to this function are valid.

\CM CM_DCM_S_GEN_PARAM_PTR_WRITE
  Verify that the generated function does not modify the pointer passed as an argument, but only writes a new value.
  SMI-37386

\CM CM_DCM_S_GEN_PARAM_PTR_FORWARD
  Verify that the generated function does not modify the pointer passed as an argument, but only forwards it.
  SMI-37387

\CM CM_DCM_S_GEN_POINTER_FORWARD_STACK
  Verify that the generated function does not modify the pointer, taken from a local variable,
  and that the function receiving those pointer parameter(s) does not store the adresses after return.
  SMI-37386

\CM CM_DCM_S_GET_SEED_FUNC_SIGNATURE
  Verify that the generated GetSeed functions match the signatures expected by the DCM.
  SMI-40607

\CM CM_DCM_S_GET_SEED_FUNC_WRITE_DATA_LENGTH
  Verify that the generated GetSeed functions do not write more data than specified by SeedResLength parameter.
  SMI-49478

\CM CM_DCM_N_CALL_PARAM_FUNCPTR
  The caller ensures the pointers passed to this function are valid.

\CM CM_DCM_M_DEV_ERROR_DETECT
  Verify that development error detection is active in the configuration.

\CM CM_DCM_M_SIZEOF_BUFFERINFO
  Verify Dcm_PbCfgNetBufferInfo[] is defined for each id in range [0..Dcm_PbCfgNetNumBuffers[.

\CM CM_DCM_M_SIZEOF_COMMCONTEXT
  Verify Dcm_PbRamNetComMContext[] is defined for each id in range [0..Dcm_PbCfgNetNumComMChannels[.

\CM CM_DCM_M_SIZEOF_BUFFERCONTEXT
  Verify Dcm_PbRamNetBufferContext[] is defined for each id in range [0..Dcm_PbCfgNetNumBuffers[.

\CM CM_DCM_M_SIZEOF_TRANSPORTOBJECT
  Verify Dcm_PbRamNetTransportObject[] is defined for each id in range [0..Dcm_PbCfgNetNumTransportObjects[.

\CM CM_DCM_M_SIZEOF_COMCONTROLCHANNEL
  Verify Dcm_PbRamNetComCtrlChannels[] is defined for each id in range [0..Dcm_PbCfgNetNumComMChannels[.

\CM CM_DCM_M_SIZEOF_TOBJHANDLE
  Verify Dcm_PbRamNetConnId2TObjMap[] is defined for each id in range [0..Dcm_PbCfgNetNumConnections[.

\CM CM_DCM_M_SIZEOF_SVCPOSTPROCESSORS
  Verify Dcm_CfgDiagSvcPostProcessors[] is defined for each id in range [0..DCM_CFGDIAGSVCIDEXECPRECONDTABLE_SIZE[.

\CM CM_DCM_M_SIZEOF_SVCUPDATERS
  Verify Dcm_CfgDiagSvcUpdaters[] is defined for each id in range [0..DCM_CFGDIAGSVCUPDATERS_SIZE[.

\CM CM_DCM_M_SIZEOF_SVCCANCELLERS
  Verify Dcm_CfgDiagSvcCancellers[] is defined for each id in range [0..DCM_CFGDIAGSVCCANCELLERS_SIZE[.

\CM CM_DCM_M_SIZEOF_MODEMGRRULES
  Verify Dcm_CfgModeMgrRulesGetEntryOrNull[] is defined for each id in range [0..DCM_CFGMODEMGRRULES_SIZE[.

\CM CM_DCM_M_TERMINATED_LIST
  Verify that the last element of the given table is a NULL_PTR.

\CM CM_DCM_M_SIZEOF_SVC11SUBFUNC
  Verify Dcm_CfgSvc11SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC11SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC19SUBFUNC
  Verify Dcm_CfgSvc11SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC19SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC27SUBFUNC
  Verify Dcm_CfgSvc27SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC27SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC27SECLEVEL
  Verify Dcm_CfgSvc27SecLevelInfo[] is defined for each id in range [0..DCM_CFGSVC27SECLEVELINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC28SUBFUNC
  Verify Dcm_CfgSvc28SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC28SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC85SUBFUNC
  Verify Dcm_CfgSvc85SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC85SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SERVICEINFO
  Verify Dcm_CfgDiagServiceInfo[] is defined for each id in range [0..DCM_CFGDIAGSERVICEINFO_SIZE[.

\CM CM_DCM_R_CHECK_REMAINING_BUFFER
  Before writing data to a buffer, check that the buffer is large enough for the data written to it.

\CM CM_DCM_R_GET_BUFFERINFO
  Dcm_NetGetBufferInfo() will always return a valid buffer info element even when the passed memory index is
  not a handle to a buffer info element.

\CM CM_DCM_R_GET_COMMCONTEXT
  Dcm_NetGetComMContext() will always return a valid ComM context element even when the passed memory index is
  not a handle to a ComM context element.

\CM CM_DCM_R_GET_BUFFERCONTEXT
  Dcm_NetGetBufferContext() will always return a valid buffer context element even when the passed memory index is
  not a handle to a buffer context element.

\CM CM_DCM_R_GET_TRANSPORTOBJECT
  Dcm_NetGetTransportObject() will always return a valid transport object even when the passed memory index is
  not a handle to a transport object.

\CM CM_DCM_R_GET_TOBJ_OF_CONNECTION
  Dcm_NetGetTranspObjOfConnectionOrNull() will return a valid transport object or NULL_PTR. Therefore the user must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_ALLOCATEDTOBJ
  Dcm_NetAllocateOrGetTranspObjectOrNull() will return a valid transport object or NULL_PTR. Therefore the user must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_RESERVEDTOBJ
  Dcm_NetLockConnectionOrNull() will return a valid transport object or NULL_PTR. Therefore the user must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_TASKCONTEXT
  Dcm_TskGetTaskContextOrNull() will return a valid task context or NULL_PTR. Therefore the user must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it, unless
  when it can be guaranteed that the passed memory index is valid.

\CM CM_DCM_R_GET_SCHEDULERCONTEXT
  Dcm_TskGetSchedulerContextOrNull() will return a valid scheduler context or NULL_PTR. Therefore the user must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_RXPDUINFO
  Verify that the local pointer initialized as a NULL_PTR is set after calling Dcm_NetProvideRxBuffer().

\CM CM_DCM_R_GET_TASKINFO
  Dcm_TskGetTaskInfoOrNull() will return a valid task info or NULL_PTR. Therefore the user must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it, unless
  when it can be guaranteed that the passed memory index is valid.

\CM CM_DCM_R_GET_SVC11SUBFUNC
  Dcm_CfgSvc11SubFuncInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the user must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC19SUBFUNC
  Dcm_CfgSvc19SubFuncInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the user must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC27SUBFUNC
  Dcm_CfgSvc27SubFuncInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the user must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC27SECLEVEL
  Dcm_CfgSvc27SecLevelInfoGetEntryOrNull() will return a valid security level info or NULL_PTR. Therefore the user must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC28SUBFUNC
  Dcm_CfgSvc28SubFuncInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the user must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SVC85SUBFUNC
  Dcm_CfgSvc85SubFuncInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the user must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_SERVICEINFO
  Dcm_CfgDiagServiceInfoGetEntryOrNull() will return a valid subfunction info or NULL_PTR. Therefore the user must
  explicitly verify that the retrieved pointer is unequal to NULL_PTR before forwarding or writing to it.

\CM CM_DCM_R_GET_TIMERINFO
  Dcm_TmrGetTimerInfoOrNull() will always return a valid task info even when the passed memory index is
  not a handle to a timer info.

\CM CM_DCM_R_GET_SVCPOSTPROCESSORS
  Dcm_DiagGetPostProcessorFunc() will always return a valid function pointer even when the passed memory index is
  not a handle to a post-processor function.

\CM CM_DCM_R_GET_SVCUPDATERS
  Dcm_DiagGetUpdateFunc() will always return a valid function pointer even when the passed memory index is
  not a handle to an update function.

\CM CM_DCM_R_GET_SVCCANCELLERS
  Dcm_DiagGetCancelFunc() will always return a valid function pointer even when the passed memory index is
  not a handle to a cancellation function.

\CM CM_DCM_R_GET_MODEMGRRULES
  Dcm_CfgModeMgrRulesGetEntryOrNull() will return a valid function pointer if the passed memory index is a valid one
  or NULL_PTR if not. Therefore the user must explicitly verify that the retrieved function pointer is unequal
  to NULL_PTR before calling it.

\CM CM_DCM_R_TERMINATED_LIST
  The for loop ensures that the index never exceeds the size of the given table.

\CM CM_DCM_R_SET_TOBJ_ADDBUFFER
  Verify that the array index is in range before writing to AddBfufer[] of a specific transport object.

\CM CM_DCM_R_SET_COMCONTROLCHANNEL
  Verify that the array index is in range before writing to Dcm_PbRamNetComCtrlChannels[].

\CM CM_DCM_R_SET_TOBJHANDLE
  Verify that the array index is in range before writing to Dcm_PbRamNetConnId2TObjMap[].

\CM CM_DCM_R_SET_TIMER
  Verify that the array index is in range before writing to Dcm_SingletonContext.TimerMgr.Timer[].

\CM CM_DCM_R_SET_START_UP_FBL_RES_BUFFER
  Verify that the array index is in range before writing to Dcm_InstanceContext.Diag.StartUpFbl.ResBuffer[].

\CM CM_DCM_R_SET_CURRENT_TASK_PRIO_STACK
  Verify that the array index is in range before writing to CurrentTaskPrioStack.Stack[].

\CM CM_DCM_R_SET_ATTEMPTCOUNT
  Verify that the array index is in range before writing to Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[].

\CM CM_DCM_R_SET_DELAYTIME
  Verify that the array index is in range before writing to Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[].

\CM CM_DCM_R_SET_DATA_CONTEXT_BUFFER
  Verify that the array index is in range [0..pDataContext->Size[ before writing to pDataContext->Buffer.

\CM CM_DCM_R_SET_MESSAGE_CONTEXT_RESBUFFER
  Verify that the array index is in range [0..pMsgContext->resBufSize[ before writing to pMsgContext->resData.

\CM CM_DCM_R_SET_MESSAGE_CONTEXT_REQBUFFER
  Verify that the array index is in range [0..pMsgContext->reqBufSize[ before writing to pMsgContext->reqData.

\CM CM_DCM_R_SET_DATA_CONTEXT_USAGE
  Verify that the sum of pDataContext->Usage and pDataContext->AvailLen is always equal to or smaller as
  pDataContext->Size.

\CM CM_DCM_R_MEMCPY_PASS_BUFFER
  Verify that the passed pair of buffer pointer and buffer size matches to referenced memory entry and memory size.

\CM CM_DCM_R_MEMCPY_WRITE
  Verify that the array index is in range between 0 and the passed buffer size before writing to the passed
  buffer pointer.

*/
/* ********************************************************************************************************************
 * END OF FILE: Dcm.c
 * ******************************************************************************************************************** */
