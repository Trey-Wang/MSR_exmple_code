/****************************************************************************
 ** Main author: Ubr                     Creation date: 03/18/05
 ** $Author:: mneuhaus                 $ $JustDate:: 03/18/05             $
 ** $Workfile:: actIHashMAC.c          $ $Revision:: 2295                 $
 ** $NoKeywords::                                                         $
 **
 **
 ** \copyright(cv cryptovision GmbH, 1999 - 2005                          )
 **
 ** \version(1.0 (beta )                                                  )
 ***************************************************************************/

/****************************************************************************
 **
 **     Part of the actCLibrary
 **
 **     Layer: User Module - Interface
 **
 ***************************************************************************/

/****************************************************************************
 **
 ** This file contains: A GHash implementation, which is needed e.g. for GCM
 **
 ** constants:
 **
 ** types:
 **
 ** macros:
 **
 ** local functions:
 **   rightShiftBlock
 **   actGF128Mul
 **   actGHashTransformBlock
 **
 ** global functions:
 **   actGHashInit
 **   actGHashUpdate
 **   actGHashZeroPad
 **   actGHashFinalize
 **
 ***************************************************************************/


#include "actConfig.h"
#include "actIGHash.h"
#include "actUtilities.h"
#include "actWatchdog.h"


/*
 ###########################################################################
 ##
 ##   LIMIT SPEED UP SETTING!
 ##   Please read the "library/es Porting Guide"
 ##   on how to further speed up GHash!
 ##
 ###########################################################################
*/
#if (actGHASH_SPEED_UP > 1)
  #define actGHASH_SPEED_UP   1   /*  limit speedup */
#endif


/* Compute Z = X + Y for full blocks X and Y, which is a simple XOR in GF(2^128) */
static CRYPTOCV_FUNC( void ) gf128_block_add (
   CRYPTOCV_P2VAR_PARA( actU32 ) Z,
   CRYPTOCV_P2CONST_PARA( actU32 ) X,
   CRYPTOCV_P2CONST_PARA( actU32 ) Y )
{
   Z[3] = X[3] ^ Y[3];
   Z[2] = X[2] ^ Y[2];
   Z[1] = X[1] ^ Y[1];
   Z[0] = X[0] ^ Y[0];
}

/* Compute Z = 2 * X for a full block X, which is a simple bitshift in GF(2^128).
 * If the result is greater than the field polynomial, it is reduced. */
static CRYPTOCV_FUNC( void ) gf128_block_double (
   CRYPTOCV_P2VAR_PARA( actU32 ) Z,
   CRYPTOCV_P2CONST_PARA( actU32 ) X )
{
   int carry = X[3] & 1;
   
   Z[3] = (X[3] >> 1) | ((X[2] & 1) << 31);
   Z[2] = (X[2] >> 1) | ((X[1] & 1) << 31);
   Z[1] = (X[1] >> 1) | ((X[0] & 1) << 31);
   Z[0] = (X[0] >> 1);
   if (carry)
      Z[0] ^= GF128POLY;
}


/*---------------------------------------------------------------------------*/
#if (actGHASH_SPEED_UP == 0)
/*---------------------------------------------------------------------------*/

/****************************************************************************
 **
 ** FUNCTION:
 ** static void actGF128Mul(actGHASHSTRUCT* info, actU32 *Z, const actU8 *X)
 **
 **  This function performs a multiplication Z = X * H, with Z in GF(2^128), 
 **  using the GCM reduction polynomial R = 1 + a + a^2 + a^7 + a^128.
 **  
 ** input:
 ** - info: pointer to context structure
 ** - Z:    pointer to memory location for the result
 ** - X:    pointer to the polynomial to multiply
 **
 ** output:
 ** - Z:    the result, Z = X * H with H being the internally stored subkey
 **
 ** assumes:
 **
 ** uses:
 **
 ***************************************************************************/
static CRYPTOCV_FUNC( void ) actGF128Mul (
   CRYPTOCV_P2VAR_PARA( actGHASHSTRUCT ) info,
   CRYPTOCV_P2VAR_PARA( actU32 ) Z,
   CRYPTOCV_P2CONST_PARA( actU8 ) X )
{
   actU32 H [actGHASH_WORDS_PER_BLOCK];   /* Hash subkey */
   int    i;

   actMemcpy ((CRYPTOCV_P2VAR_PARA( actU8 )) H, (CRYPTOCV_P2VAR_PARA( actU8 )) info->H, actGHASH_BLOCK_SIZE);  /* initialize H */

   actMemset ((CRYPTOCV_P2VAR_PARA( actU8 )) Z, 0, actGHASH_BLOCK_SIZE); /* Z = 0 */
   for (i = 0; i < actGHASH_BLOCK_SIZE; i++) {      /* loop over X, MSB...LSB */
      int   j;
      actU8 X_i;

      X_i = X [i];                                  /* next byte */
      for (j = 7; j >= 0; j--) {                    /* loop over next byte, MSbit...LSbit */
         if (X_i & 0x80)
            gf128_block_add (Z, Z, H);              /* if (bit set) Z += H */
         X_i <<= 1;
         gf128_block_double (H, H);                 /* Z *= 2 */
      }
   }
}


/*---------------------------------------------------------------------------*/
#elif (actGHASH_SPEED_UP < 4)   /* 1..3 */
/*---------------------------------------------------------------------------*/


/* Reduction table R:
 * This table was generated by computing the 2^i possible different 
 * XOR-combinations of the k-bit-shifted reduction polynomial 0xe1
 * for i = 4 and 0 <= k < i. 
 * Having this, one can shift by one blocksize of i bits and reduce by 
 * just XORing the table item with the out-shifted value as table index.
 */
CRYPTOCV_CONST( STATIC, actU16 ) R[16] = {
      0x0000, 0x1c20, 0x3840, 0x2460, 0x7080, 0x6ca0, 0x48c0, 0x54e0, 
      0xe100, 0xfd20, 0xd940, 0xc560, 0x9180, 0x8da0, 0xa9c0, 0xb5e0
};

/* Rightshift by 4 bit positions. Instead of reducing directly, return the 
 * bits that were shifted out.
 */
CRYPTOCV_CONST( STATIC, actU8 ) gf128_rightshift_4(actU32 *block) {
   actU8 v = block[actGHASH_WORDS_PER_BLOCK-1] & 0xf;
   
   /* Right-shift the given block by 4 bit positions. 
    * Does not reduce, but return the bits that were shifted out! */
   block[3] = (block[3] >> 4) | ((block[2]&0xf) << 28);
   block[2] = (block[2] >> 4) | ((block[1]&0xf) << 28);
   block[1] = (block[1] >> 4) | ((block[0]&0xf) << 28);
   block[0] >>= 4;
   
   return v;
}


/****************************************************************************
 **
 ** FUNCTION:
 ** static void actGF128Mul(actGHASHSTRUCT* info, actU32 *Z, const actU8 *X)
 **
 **  This function performs a multiplication Z = X * H, with Z in GF(2^128), 
 **  using the GCM reduction polynomial R = 1 + a + a^2 + a^7 + a^128.
 **  
 ** input:
 ** - info: pointer to context structure
 ** - Z:    pointer to memory location for the result
 ** - X:    pointer to the polynomial to multiply
 **
 ** output:
 ** - Z:    the result, Z = X * H with H being the internally stored subkey
 **
 ** assumes:
 **
 ** uses:
 **
 ***************************************************************************/
static CRYPTOCV_FUNC( void ) actGF128Mul (
   CRYPTOCV_P2VAR_PARA( actGHASHSTRUCT ) info,
   CRYPTOCV_P2VAR_PARA( actU32 ) Z,
   CRYPTOCV_P2CONST_PARA( actU8 ) X )
{
   int    i;
   

   actMemset ((CRYPTOCV_P2VAR_PARA( actU8 )) Z, 0, actGHASH_BLOCK_SIZE);   /* Z = 0 */
   
   for (i = actGHASH_BLOCK_SIZE -1; i >= 0; i--) {    /* loop over X: MSB ... LSB */
      actU8  X_i, A;


      X_i = X [i];                                    /* next byte */

      A = gf128_rightshift_4 (Z);                     /* Z *= 16 */
      Z [0] ^= (R [A] << 16);                         /* handle carry bits */
      gf128_block_add (Z, Z, info->M [X_i & 0xf]);    /* Z += (X * (4 MSbits)) */

      A = gf128_rightshift_4 (Z);                     /* Z *= 16 */
      Z [0] ^= (R [A] << 16);                         /* handle carry bits */
      gf128_block_add (Z, Z, info->M [X_i >> 4]);     /* Z += (X * (4 next bits)) */
   }
}


/*---------------------------------------------------------------------------*/
#else   /* actGHASH_SPEED_UP >= 4 */
/*---------------------------------------------------------------------------*/


/* Reduction table R:
 * This table was generated by computing the 2^i possible different 
 * XOR-combinations of the k-bit-shifted reduction polynomial 0xe1
 * for i = 8 and 0 <= k < i. 
 * Having this, one can shift by one blocksize of i bits and reduce by 
 * just XORing the table item with the out-shifted value as table index.
 */
CRYPTOCV_CONST( STATIC, actU16 ) R[256] = {
      0x0000, 0x01c2, 0x0384, 0x0246, 0x0708, 0x06ca, 0x048c, 0x054e, 
      0x0e10, 0x0fd2, 0x0d94, 0x0c56, 0x0918, 0x08da, 0x0a9c, 0x0b5e, 
      0x1c20, 0x1de2, 0x1fa4, 0x1e66, 0x1b28, 0x1aea, 0x18ac, 0x196e, 
      0x1230, 0x13f2, 0x11b4, 0x1076, 0x1538, 0x14fa, 0x16bc, 0x177e, 
      0x3840, 0x3982, 0x3bc4, 0x3a06, 0x3f48, 0x3e8a, 0x3ccc, 0x3d0e, 
      0x3650, 0x3792, 0x35d4, 0x3416, 0x3158, 0x309a, 0x32dc, 0x331e, 
      0x2460, 0x25a2, 0x27e4, 0x2626, 0x2368, 0x22aa, 0x20ec, 0x212e, 
      0x2a70, 0x2bb2, 0x29f4, 0x2836, 0x2d78, 0x2cba, 0x2efc, 0x2f3e, 
      0x7080, 0x7142, 0x7304, 0x72c6, 0x7788, 0x764a, 0x740c, 0x75ce, 
      0x7e90, 0x7f52, 0x7d14, 0x7cd6, 0x7998, 0x785a, 0x7a1c, 0x7bde, 
      0x6ca0, 0x6d62, 0x6f24, 0x6ee6, 0x6ba8, 0x6a6a, 0x682c, 0x69ee, 
      0x62b0, 0x6372, 0x6134, 0x60f6, 0x65b8, 0x647a, 0x663c, 0x67fe, 
      0x48c0, 0x4902, 0x4b44, 0x4a86, 0x4fc8, 0x4e0a, 0x4c4c, 0x4d8e, 
      0x46d0, 0x4712, 0x4554, 0x4496, 0x41d8, 0x401a, 0x425c, 0x439e, 
      0x54e0, 0x5522, 0x5764, 0x56a6, 0x53e8, 0x522a, 0x506c, 0x51ae, 
      0x5af0, 0x5b32, 0x5974, 0x58b6, 0x5df8, 0x5c3a, 0x5e7c, 0x5fbe, 
      0xe100, 0xe0c2, 0xe284, 0xe346, 0xe608, 0xe7ca, 0xe58c, 0xe44e, 
      0xef10, 0xeed2, 0xec94, 0xed56, 0xe818, 0xe9da, 0xeb9c, 0xea5e, 
      0xfd20, 0xfce2, 0xfea4, 0xff66, 0xfa28, 0xfbea, 0xf9ac, 0xf86e, 
      0xf330, 0xf2f2, 0xf0b4, 0xf176, 0xf438, 0xf5fa, 0xf7bc, 0xf67e, 
      0xd940, 0xd882, 0xdac4, 0xdb06, 0xde48, 0xdf8a, 0xddcc, 0xdc0e, 
      0xd750, 0xd692, 0xd4d4, 0xd516, 0xd058, 0xd19a, 0xd3dc, 0xd21e, 
      0xc560, 0xc4a2, 0xc6e4, 0xc726, 0xc268, 0xc3aa, 0xc1ec, 0xc02e, 
      0xcb70, 0xcab2, 0xc8f4, 0xc936, 0xcc78, 0xcdba, 0xcffc, 0xce3e, 
      0x9180, 0x9042, 0x9204, 0x93c6, 0x9688, 0x974a, 0x950c, 0x94ce, 
      0x9f90, 0x9e52, 0x9c14, 0x9dd6, 0x9898, 0x995a, 0x9b1c, 0x9ade, 
      0x8da0, 0x8c62, 0x8e24, 0x8fe6, 0x8aa8, 0x8b6a, 0x892c, 0x88ee, 
      0x83b0, 0x8272, 0x8034, 0x81f6, 0x84b8, 0x857a, 0x873c, 0x86fe, 
      0xa9c0, 0xa802, 0xaa44, 0xab86, 0xaec8, 0xaf0a, 0xad4c, 0xac8e, 
      0xa7d0, 0xa612, 0xa454, 0xa596, 0xa0d8, 0xa11a, 0xa35c, 0xa29e, 
      0xb5e0, 0xb422, 0xb664, 0xb7a6, 0xb2e8, 0xb32a, 0xb16c, 0xb0ae, 
      0xbbf0, 0xba32, 0xb874, 0xb9b6, 0xbcf8, 0xbd3a, 0xbf7c, 0xbebe
};

/* Rightshift by 8 bit positions. Instead of reducing directly, return the 
 * bits that were shifted out.
 */
static CRYPTOCV_FUNC( actU8 ) gf128_rightshift_8 (
   CRYPTOCV_P2VAR_PARA( actU32 ) block )
{
   actU8 v = block[actGHASH_WORDS_PER_BLOCK-1] & 0xff;
   
   /* Right-shift the given block by 8 bit positions. 
    * Does not reduce, but return the bits that were shifted out! */
   block[3] = (block[3] >> 8) | ((block[2]&0xff) << 24);
   block[2] = (block[2] >> 8) | ((block[1]&0xff) << 24);
   block[1] = (block[1] >> 8) | ((block[0]&0xff) << 24);
   block[0] >>= 8;
   
   return v;
}


/****************************************************************************
 **
 ** FUNCTION:
 ** static void actGF128Mul(actGHASHSTRUCT* info, actU32 *Z, const actU8 *X)
 **
 **  This function performs a multiplication Z = X * H, with Z in GF(2^128), 
 **  using the GCM reduction polynomial R = 1 + a + a^2 + a^7 + a^128.
 **  
 ** input:
 ** - info: pointer to context structure
 ** - Z:    pointer to memory location for the result
 ** - X:    pointer to the polynomial to multiply
 **
 ** output:
 ** - Z:    the result, Z = X * H with H being the internally stored subkey
 **
 ** assumes:
 **
 ** uses:
 **
 ***************************************************************************/
static CRYPTOCV_FUNC( void ) actGF128Mul (
   CRYPTOCV_P2VAR_PARA( actGHASHSTRUCT ) info,
   CRYPTOCV_P2VAR_PARA( actU32 ) Z,
   CRYPTOCV_P2CONST_PARA( actU8 ) X )
{
   int i;
   

   actMemset ((CRYPTOCV_P2VAR_PARA( actU8 ))Z, 0, actGHASH_BLOCK_SIZE);    /* Z = 0 */
   
   for (i = actGHASH_BLOCK_SIZE-1; i >= 0; i--) {     /* loop over X, MSB...LSB */
      actU8 A;
      
      A = gf128_rightshift_8 (Z);                     /* Z *= 256 */
      Z [0] ^= (R [A] << 16);                         /* handle carry bits */
      gf128_block_add (Z, Z, info->M [X [i]]);        /* Z += (X * (next byte)) */
   }
}

/*---------------------------------------------------------------------------*/
#endif
/*---------------------------------------------------------------------------*/


/****************************************************************************
 **
 ** FUNCTION:
 ** static void actGHashTransformBlock(actGHASHSTRUCT* info, const actU8 *block)
 **
 **  This function GHashes a complete input block and stores the result.
 **  
 ** input:
 ** - info        pointer to context structure
 ** - X           pointer to input block
 **
 ** output:
 ** - info->Y:    the result, Y_i = (Y_i-1 XOR X) * H
 **
 ** assumes:
 ** - X is a complete block of actGHASH_BLOCK_SIZE
 **
 ** uses:
 **
 ***************************************************************************/
static CRYPTOCV_FUNC( void ) actGHashTransformBlock (
   CRYPTOCV_P2VAR_PARA( actGHASHSTRUCT ) info,
   CRYPTOCV_P2CONST_PARA( actU8 ) X )
{
   int i;
   actU32 tmpY[actGHASH_WORDS_PER_BLOCK];
   
   /* Y_i = Y_i-1 XOR X_i */
   actXOR(info->Y, X, actGHASH_BLOCK_SIZE);
   /* Y_i = Y_i * H */
   actGF128Mul(info, tmpY, info->Y);
   
   /* Convert actU32 to actU8 and store internally */
   for (i = 0; i < actGHASH_WORDS_PER_BLOCK; i++) {
      actLongToByte(info->Y+(i*actGHASH_WORD_SIZE), tmpY[i]);
   }
}


/****************************************************************************
 **
 ** FUNCTION:
 ** actRETURNCODE actGHashReset(actGHASHSTRUCT* info)
 **
 **  This function resets the hash-block Y to zero
 **  It does NOT import the hash-subkey
 **  
 ** input:
 ** - info        pointer to context structure
 **
 ** output:
 ** - info:       initialized context structure
 ** - returns:    actOK always
 **
 ** assumes:
 **
 ** uses:
 **
 ***************************************************************************/
CRYPTOCV_FUNC( actRETURNCODE ) actGHashReset (
   CRYPTOCV_P2VAR_PARA( actGHASHSTRUCT ) info )
{
   /* Y = 0^128 */
   actMemset(info->Y, 0, actGHASH_BLOCK_SIZE);
   
   info->buffer_used = 0;

   return actOK;
}


/****************************************************************************
 **
 ** FUNCTION:
 ** actRETURNCODE actGHashInit(actGHASHSTRUCT* info,
 **                            const actU8 H[actAES_BLOCK_SIZE])
 **
 **  This function initializes the hash-block Y to zero
 **  
 ** input:
 ** - info        pointer to context structure
 ** - H:          the hash subkey in big endian format
 ** - watchdog:   pointer to watchdog reset function
 **
 ** output:
 ** - info:       initialized context structure
 ** - returns:    actOK always
 **
 ** assumes:
 **
 ** uses:
 **
 ***************************************************************************/
CRYPTOCV_FUNC( actRETURNCODE ) actGHashInit (
   CRYPTOCV_P2VAR_PARA( actGHASHSTRUCT ) info,
   CRYPTOCV_P2CONST_PARA( actU8 ) H,
   CRYPTOCV_P2FUNC( CRYPTOCV_NONE, void, watchdog )( void ) )
{
#if (actGHASH_SPEED_UP > 0)
   int i;
#endif

   /* Store the subkey internally */

#ifdef LITTLE_ENDIAN
   info->H[0] = actSwap(*((CRYPTOCV_P2VAR_PARA( actU32 ))H));
   info->H[1] = actSwap(*((CRYPTOCV_P2VAR_PARA( actU32 ))(H+4)));
   info->H[2] = actSwap(*((CRYPTOCV_P2VAR_PARA( actU32 ))(H+8)));
   info->H[3] = actSwap(*((CRYPTOCV_P2VAR_PARA( actU32 ))(H+12)));
#else
   info->H[0] = *((CRYPTOCV_P2VAR_PARA( actU32 ))H);
   info->H[1] = *((CRYPTOCV_P2VAR_PARA( actU32 ))(H+4));
   info->H[2] = *((CRYPTOCV_P2VAR_PARA( actU32 ))(H+8));
   info->H[3] = *((CRYPTOCV_P2VAR_PARA( actU32 ))(H+12));
#endif

/*---------------------------------------------------------------------------*/
#if (actGHASH_SPEED_UP == 0)
/*---------------------------------------------------------------------------*/
   /* no precomputation! */

/*---------------------------------------------------------------------------*/
#elif (actGHASH_SPEED_UP < 4)   /* 1..3 */
/*---------------------------------------------------------------------------*/
   /* Algorithm 3 from the paper for precomputing the lookup-table */
   /* somewhat awkward indexing, as the bit-order of the index is inverted (little-endian) */
   /* must be adhered to for the powers of two only, because an addition is just an XOR! */
   actMemset((CRYPTOCV_P2VAR_PARA( actU8 ))info->M[0], 0, actGHASH_BLOCK_SIZE);
   actMemcpy((CRYPTOCV_P2VAR_PARA( actU8 ))info->M[8], (CRYPTOCV_P2VAR_PARA(actU8))info->H, 16);

   /* Powers of 2 by shifting */
   for (i = 4; i > 0; i /= 2) {
      gf128_block_double(info->M[i], info->M[2* i]);
   }
   /* Compose the rest by adding */
   for (i = 2; i <= 8; i *= 2) {
      int j;
      for (j = 1; j < i; j++) {
         gf128_block_add(info->M[i+j], info->M[i], info->M[j]);
      }
   }   

/*---------------------------------------------------------------------------*/
#else   /* actGHASH_SPEED_UP >= 4 */
/*---------------------------------------------------------------------------*/
   /* Algorithm 3 from the paper for precomputing the lookup-table */
   /* somewhat awkward indexing, as the bit-order of the index is inverted (little-endian) */
   /* must be adhered to for the powers of two only, because an addition is just an XOR! */
   actMemset((CRYPTOCV_P2VAR_PARA( actU8 ))info->M[0], 0, actGHASH_BLOCK_SIZE);
   actMemcpy((CRYPTOCV_P2VAR_PARA( actU8 ))info->M[128], (CRYPTOCV_P2VAR_PARA( actU8 ))info->H, 16);
   
   /* Powers of 2 by shifting */
   for (i = 64; i > 0; i /= 2) {
      gf128_block_double(info->M[i], info->M[2* i]);
   }
   /* Compose the rest by adding */
   for (i = 2; i <= 128; i *= 2) {
      int j;
      for (j = 1; j < i; j++) {
         gf128_block_add(info->M[i+j], info->M[i], info->M[j]);
      }
   }   
/*---------------------------------------------------------------------------*/
#endif
/*---------------------------------------------------------------------------*/

   actL1trigger (watchdog);
   return actGHashReset (info);
}


/****************************************************************************
 **
 ** FUNCTION:
 ** actRETURNCODE actGHashUpdate(actGHASHSTRUCT* info,
 **                              const actU8* X,
 **                              int X_len,
 **                              void (*watchdog) (void))
 **
 **  This function hashes the given data and can be called arbitrarily
 **  often between an initialize and finalize of the GHash algorithm.
 **  Incomplete blocks are padded with zeroes.
 **  
 ** input:
 ** - info:       pointer to initialized context structure
 ** - X:          the input string
 ** - X_len:      length of X in bytes
 ** - watchdog:   pointer to watchdog reset function
 **
 ** output:
 ** - info:       the updated context structure
 ** - returns:    actOk always
 **
 ** assumes:
 ** - actGHashInit() is called once before calling this function
 ** - X != NULL is a valid pointer
 **
 ** uses:
 **
 ***************************************************************************/
CRYPTOCV_FUNC( actRETURNCODE ) actGHashUpdate (
   CRYPTOCV_P2VAR_PARA( actGHASHSTRUCT ) info,
   CRYPTOCV_P2CONST_PARA( actU8 ) X,
   int X_len,
   CRYPTOCV_P2FUNC( CRYPTOCV_NONE, void, watchdog )( void ) )
{
   int i, blocks, diff = 0;
   
   actL1trigger (watchdog);
   
   /* left overs of the last update */
   if ( info->buffer_used > 0 ) {
      diff = actMin(X_len, (int)(actGHASH_BLOCK_SIZE - info->buffer_used));
      actMemcpy(info->buffer + info->buffer_used, X, (unsigned int)diff);
      info->buffer_used += diff;
      if( info->buffer_used < actGHASH_BLOCK_SIZE ) {
         return actOK;
      } else {
         actGHashTransformBlock(info, info->buffer);
         actL2trigger (watchdog);
      }
   }

   /* loop through (remaining) X, blockwise */
   blocks = (X_len - diff) / actGHASH_BLOCK_SIZE;
   X += diff;
   
   for (i = blocks; i > 0; --i, X += actGHASH_BLOCK_SIZE) {
      actGHashTransformBlock(info, X);
      actL2trigger (watchdog);
   }   

   /* copy left overs into buffer */
   info->buffer_used = X_len - (diff + actGHASH_BLOCK_SIZE * blocks);
   actMemcpy(info->buffer, X, (unsigned int)(info->buffer_used));
   
   actL1trigger (watchdog);
   
   return actOK;
}


/****************************************************************************
 **
 ** FUNCTION:
 ** actRETURNCODE actGHashZeroPad(actGHASHSTRUCT* info)
 **
 **  If there is input left in the buffer, this function pads it with 
 **  zeroes and hashes it, otherwise the hash doesn't need to be padded. 
 **  
 ** input:
 ** - info:       pointer to initialized context structure
 ** - watchdog:   pointer to watchdog reset function
 **
 ** output:
 ** - info:       the updated context structure
 ** - returns:    actOk always
 **
 ** assumes:
 ** - actGHashInit() is called once before calling this function
 **
 ** uses:
 **
 ***************************************************************************/
CRYPTOCV_FUNC( actRETURNCODE ) actGHashZeroPad (
   CRYPTOCV_P2VAR_PARA( actGHASHSTRUCT ) info,
   CRYPTOCV_P2FUNC( CRYPTOCV_NONE, void, watchdog )( void ) )
{
   if (info->buffer_used > 0) {      
      /* Pad buffer with zeroes */
      actMemset(info->buffer + info->buffer_used, 0, actGHASH_BLOCK_SIZE - info->buffer_used);
      /* Hash the buffer block */
      actGHashTransformBlock(info, info->buffer);
/*    actL2trigger (watchdog);  */ /* WD is triggered at end of function anyway! */
      /* Reset buffer_used */
      info->buffer_used = 0;
   }
   
   actL1trigger (watchdog);
   return actOK;
}


/****************************************************************************
 **
 ** FUNCTION:
 ** actRETURNCODE actGHashFinalize(actGHASHSTRUCT* info,
 **                               actU8 hash[actGHASH_BLOCK_SIZE])
 **
 **  This function finalizes the GHash algorithm and outputs the hash value
 **  
 ** input:
 ** - info:       pointer to initialized context structure
 ** - hash:       byte array to contain the hash value
 ** - watchdog:   pointer to watchdog reset function
 **
 ** output:
 ** - hash:       the final hash value
 ** - returns:    actOK always
 **
 ** assumes:
 ** - actGHashInit() is called once before calling this function
 **
 ** uses:
 **
 ***************************************************************************/
CRYPTOCV_FUNC( actRETURNCODE ) actGHashFinalize (
   CRYPTOCV_P2VAR_PARA( actGHASHSTRUCT ) info,
   actU8 hash[actGHASH_BLOCK_SIZE],
   CRYPTOCV_P2FUNC( CRYPTOCV_NONE, void, watchdog )( void ) )
{
   /* zero-pad and hash possible leftovers in the buffer */
   if (info->buffer_used > 0)
      actGHashZeroPad(info, watchdog);
   
   actMemcpy(hash, info->Y, actGHASH_BLOCK_SIZE);
   
   actL1trigger (watchdog);
   return actOK;
}
